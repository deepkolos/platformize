'use strict';

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var PlatformManager = /*#__PURE__*/ function() {
    function PlatformManager() {
        _classCallCheck(this, PlatformManager);
        this.polyfill = {};
    }
    var _proto = PlatformManager.prototype;
    _proto.set = function set(platform) {
        this.platform = platform;
        this.polyfill = platform.polyfill;
    };
    _proto.dispose = function dispose() {
        var ref;
        (ref = this.platform) === null || ref === void 0 ? void 0 : ref.dispose();
        this.platform = null;
        this.polyfill = null;
    };
    return PlatformManager;
}();
var PlatformManager$1 = new PlatformManager();

/**
 * Defines how the bounding volumes intersects or contain one another.
 */ var ContainmentType;
(function(ContainmentType) {
    ContainmentType[ContainmentType[/** Indicates that there is no overlap between two bounding volumes. */ "Disjoint"] = 0] = "Disjoint";
    ContainmentType[ContainmentType[/** Indicates that one bounding volume completely contains another volume. */ "Contains"] = 1] = "Contains";
    ContainmentType[ContainmentType[/** Indicates that bounding volumes partially overlap one another. */ "Intersects"] = 2] = "Intersects";
})(ContainmentType || (ContainmentType = {}));

/**
 * Defines the intersection between a plane and a bounding volume.
 */ var PlaneIntersectionType;
(function(PlaneIntersectionType) {
    PlaneIntersectionType[PlaneIntersectionType[/** There is no intersection, the bounding volume is in the back of the plane. */ "Back"] = 0] = "Back";
    PlaneIntersectionType[PlaneIntersectionType[/** There is no intersection, the bounding volume is in the front of the plane. */ "Front"] = 1] = "Front";
    PlaneIntersectionType[PlaneIntersectionType[/** The plane is intersected. */ "Intersecting"] = 2] = "Intersecting";
})(PlaneIntersectionType || (PlaneIntersectionType = {}));

/**
 * Frustum face
 */ var FrustumFace;
(function(FrustumFace) {
    FrustumFace[FrustumFace[/** Near face */ "Near"] = 0] = "Near";
    FrustumFace[FrustumFace[/** Far face */ "Far"] = 1] = "Far";
    FrustumFace[FrustumFace[/** Left face */ "Left"] = 2] = "Left";
    FrustumFace[FrustumFace[/** Right face */ "Right"] = 3] = "Right";
    FrustumFace[FrustumFace[/** Bottom face */ "Bottom"] = 4] = "Bottom";
    FrustumFace[FrustumFace[/** Top face */ "Top"] = 5] = "Top";
})(FrustumFace || (FrustumFace = {}));

function _defineProperties$4(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$4(Constructor, staticProps);

    return Constructor;
}

/**
 * Common utility methods for math operations.
 */ var MathUtil$1 = /*#__PURE__*/ function() {
    function MathUtil() {}
    /**
   * Clamps the specified value.
   * @param v - The specified value
   * @param min - The min value
   * @param max - The max value
   * @returns The result of clamping a value between min and max
   */ MathUtil.clamp = function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    };
    /**
   * Checks if a and b are almost equals.
   * The absolute value of the difference between a and b is close to zero.
   * @param a - The left value to compare
   * @param b - The right value to compare
   * @returns True if a almost equal to b, false otherwise
   */ MathUtil.equals = function equals(a, b) {
        return Math.abs(a - b) <= MathUtil.zeroTolerance;
    };
    /**
   * Determines whether the specified v is pow2.
   * @param v - The specified v
   * @returns True if the specified v is pow2, false otherwise
   */ MathUtil.isPowerOf2 = function isPowerOf2(v) {
        return (v & v - 1) === 0;
    };
    /**
   * Modify the specified r from radian to degree.
   * @param r - The specified r
   * @returns The degree value
   */ MathUtil.radianToDegree = function radianToDegree(r) {
        return r * MathUtil.radToDegreeFactor;
    };
    /**
   * Modify the specified d from degree to radian.
   * @param d - The specified d
   * @returns The radian value
   */ MathUtil.degreeToRadian = function degreeToRadian(d) {
        return d * MathUtil.degreeToRadFactor;
    };
    return MathUtil;
}();
(function() {
    /** The value for which all absolute numbers smaller than are considered equal to zero. */ MathUtil$1.zeroTolerance = 1e-6;
})();
(function() {
    /** The conversion factor that radian to degree. */ MathUtil$1.radToDegreeFactor = 180 / Math.PI;
})();
(function() {
    /** The conversion factor that degree to radian. */ MathUtil$1.degreeToRadFactor = Math.PI / 180;
})();

/**
 * Describes a 3D-vector.
 */ var Vector3 = /*#__PURE__*/ function() {
    function Vector3(x, y, z) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
    }
    var _proto = Vector3.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return _x * _x + _y * _y + _z * _z;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector3.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * This vector performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformNormal = function transformNormal(m) {
        Vector3.transformNormal(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given 4x4 matrix.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformToVec3 = function transformToVec3(m) {
        Vector3.transformToVec3(this, m, this);
        return this;
    };
    /**
   * This vector performs a coordinate transformation using the given 4x4 matrix.
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformCoordinate = function transformCoordinate(m) {
        Vector3.transformCoordinate(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given quaternion.
   * @param quaternion - The transform quaternion
   * @returns This vector
   */ _proto.transformByQuat = function transformByQuat(quaternion) {
        Vector3.transformByQuat(this, quaternion, this);
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector3(this._x, this._y, this._z);
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector3.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector3.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector3.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector3.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector3.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
    };
    /**
   * Determines the cross product of two vectors.
   * @param left - The first vector to cross
   * @param right - The second vector to cross
   * @param out - The cross product of two vectors
   */ Vector3.cross = function cross(left, right, out) {
        var ax = left._x;
        var ay = left._y;
        var az = left._z;
        var bx = right._x;
        var by = right._y;
        var bz = right._z;
        out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector3.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return Math.sqrt(x * x + y * y + z * z);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector3.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return x * x + y * y + z * z;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector3.equals = function equals(left, right) {
        return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector3.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector3.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector3.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector3.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector3.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
        if (len > MathUtil$1.zeroTolerance) {
            len = 1 / len;
            out.set(_x * len, _y * len, _z * len);
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector3.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param v - The normal vector to transform
   * @param m - The transform matrix
   * @param out - The transformed normal
   */ Vector3.transformNormal = function transformNormal(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8];
        out._y = _x * e[1] + _y * e[5] + _z * e[9];
        out._z = _x * e[2] + _y * e[6] + _z * e[10];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector3.transformToVec3 = function transformToVec3(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector4
   */ Vector3.transformToVec4 = function transformToVec4(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a coordinate transformation using the given 4x4 matrix.
   *
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param v - The coordinate vector to transform
   * @param m - The transform matrix
   * @param out - The transformed coordinates
   */ Vector3.transformCoordinate = function transformCoordinate(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        w = 1.0 / w;
        out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
        out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
        out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param quaternion - The transform quaternion
   * @param out - The transformed vector
   */ Vector3.transformByQuat = function transformByQuat(v, quaternion, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var qx = quaternion._x, qy = quaternion._y, qz = quaternion._z, qw = quaternion._w;
        // calculate quat * vec
        var ix = qw * _x + qy * _z - qz * _y;
        var iy = qw * _y + qz * _x - qx * _z;
        var iz = qw * _z + qx * _y - qy * _x;
        var iw = -qx * _x - qy * _y - qz * _z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class$4(Vector3, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector3;
}();
(function() {
    /** @internal */ Vector3._zero = new Vector3(0.0, 0.0, 0.0);
})();
(function() {
    /** @internal */ Vector3._one = new Vector3(1.0, 1.0, 1.0);
})();

/**
 * A bounding sphere.
 * */ var BoundingSphere = /*#__PURE__*/ function() {
    function BoundingSphere(center, radius) {
        if (center === void 0) center = null;
        if (radius === void 0) radius = 0;
        /** The center point of the sphere. */ this.center = new Vector3();
        /** The radius of the sphere. */ this.radius = 0;
        center && this.center.copyFrom(center);
        this.radius = radius;
    }
    var _proto = BoundingSphere.prototype;
    /**
   * Creates a clone of this sphere.
   * @returns A clone of this sphere
   */ _proto.clone = function clone() {
        return new BoundingSphere(this.center, this.radius);
    };
    /**
   * Copy this sphere from the specified sphere.
   * @param source - The specified sphere
   * @returns This sphere
   */ _proto.copyFrom = function copyFrom(source) {
        this.center.copyFrom(source.center);
        this.radius = source.radius;
        return this;
    };
    /**
   * Calculate a bounding sphere that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var len = points.length;
        var center = BoundingSphere._tempVec30;
        center.x = center.y = center.z = 0;
        // Calculate the center of the sphere.
        for(var i = 0; i < len; ++i){
            Vector3.add(points[i], center, center);
        }
        // The center of the sphere.
        Vector3.scale(center, 1 / len, out.center);
        // Calculate the radius of the sphere.
        var radius = 0.0;
        for(var i1 = 0; i1 < len; ++i1){
            var distance = Vector3.distanceSquared(center, points[i1]);
            distance > radius && (radius = distance);
        }
        // The radius of the sphere.
        out.radius = Math.sqrt(radius);
    };
    /**
   * Calculate a bounding sphere from a given box.
   * @param box - The given box
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromBox = function fromBox(box, out) {
        var center = out.center;
        var min = box.min, max = box.max;
        center.x = (min.x + max.x) * 0.5;
        center.y = (min.y + max.y) * 0.5;
        center.z = (min.z + max.z) * 0.5;
        out.radius = Vector3.distance(center, max);
    };
    return BoundingSphere;
}();
(function() {
    BoundingSphere._tempVec30 = new Vector3();
})();

/**
 * Axis Aligned Bound Box (AABB).
 */ var BoundingBox = /*#__PURE__*/ function() {
    function BoundingBox(min, max) {
        if (min === void 0) min = null;
        if (max === void 0) max = null;
        /** The minimum point of the box. */ this.min = new Vector3();
        /** The maximum point of the box. */ this.max = new Vector3();
        min && this.min.copyFrom(min);
        max && this.max.copyFrom(max);
    }
    var _proto = BoundingBox.prototype;
    /**
   * Get the center point of this bounding box.
   * @param out - The center point of this bounding box
   * @returns The center point of this bounding box
   */ _proto.getCenter = function getCenter(out) {
        Vector3.add(this.min, this.max, out);
        Vector3.scale(out, 0.5, out);
        return out;
    };
    /**
   * Get the extent of this bounding box.
   * @param out - The extent of this bounding box
   * @returns The extent of this bounding box
   */ _proto.getExtent = function getExtent(out) {
        Vector3.subtract(this.max, this.min, out);
        Vector3.scale(out, 0.5, out);
        return out;
    };
    /**
   * Get the eight corners of this bounding box.
   * @param out - An array of points representing the eight corners of this bounding box
   * @returns An array of points representing the eight corners of this bounding box
   */ _proto.getCorners = function getCorners(out) {
        if (out === void 0) out = [];
        var _this = this, min = _this.min, max = _this.max;
        var minX = min.x;
        var minY = min.y;
        var minZ = min.z;
        var maxX = max.x;
        var maxY = max.y;
        var maxZ = max.z;
        var len = out.length;
        // The array length is less than 8 to make up
        if (len < 8) {
            for(var i = 0, l = 8 - len; i < l; ++i){
                out[len + i] = new Vector3();
            }
        }
        out[0].set(minX, maxY, maxZ);
        out[1].set(maxX, maxY, maxZ);
        out[2].set(maxX, minY, maxZ);
        out[3].set(minX, minY, maxZ);
        out[4].set(minX, maxY, minZ);
        out[5].set(maxX, maxY, minZ);
        out[6].set(maxX, minY, minZ);
        out[7].set(minX, minY, minZ);
        return out;
    };
    /**
   * Transform a bounding box.
   * @param matrix - The transform to apply to the bounding box
   * @returns The transformed bounding box
   */ _proto.transform = function transform(matrix) {
        BoundingBox.transform(this, matrix, this);
        return this;
    };
    /**
   * Creates a clone of this box.
   * @returns A clone of this box
   */ _proto.clone = function clone() {
        return new BoundingBox(this.min, this.max);
    };
    /**
   * Copy this bounding box from the specified box.
   * @param source - The specified box
   * @returns This bounding box
   */ _proto.copyFrom = function copyFrom(source) {
        this.min.copyFrom(source.min);
        this.max.copyFrom(source.max);
        return this;
    };
    /**
   * Calculate a bounding box from the center point and the extent of the bounding box.
   * @param center - The center point
   * @param extent - The extent of the bounding box
   * @param out - The calculated bounding box
   */ BoundingBox.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding box
   */ BoundingBox.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var min = out.min, max = out.max;
        min.x = min.y = min.z = Number.MAX_VALUE;
        max.x = max.y = max.z = -Number.MAX_VALUE;
        for(var i = 0, l = points.length; i < l; ++i){
            var point = points[i];
            Vector3.min(min, point, min);
            Vector3.max(max, point, max);
        }
    };
    /**
   * Calculate a bounding box from a given sphere.
   * @param sphere - The given sphere
   * @param out - The calculated bounding box
   */ BoundingBox.fromSphere = function fromSphere(sphere, out) {
        var center = sphere.center, radius = sphere.radius;
        var min = out.min, max = out.max;
        min.x = center.x - radius;
        min.y = center.y - radius;
        min.z = center.z - radius;
        max.x = center.x + radius;
        max.y = center.y + radius;
        max.z = center.z + radius;
    };
    /**
   * Transform a bounding box.
   * @param source - The original bounding box
   * @param matrix - The transform to apply to the bounding box
   * @param out - The transformed bounding box
   */ BoundingBox.transform = function transform(source, matrix, out) {
        // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/
        var center = BoundingBox._tempVec30;
        var extent = BoundingBox._tempVec31;
        source.getCenter(center);
        source.getExtent(extent);
        Vector3.transformCoordinate(center, matrix, center);
        var x = extent.x, y = extent.y, z = extent.z;
        var e = matrix.elements;
        extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
        extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
        extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);
        // set minã€max
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that is as large as the total combined area of the two specified boxes.
   * @param box1 - The first box to merge
   * @param box2 - The second box to merge
   * @param out - The merged bounding box
   * @returns The merged bounding box
   */ BoundingBox.merge = function merge(box1, box2, out) {
        Vector3.min(box1.min, box2.min, out.min);
        Vector3.max(box1.max, box2.max, out.max);
        return out;
    };
    return BoundingBox;
}();
(function() {
    BoundingBox._tempVec30 = new Vector3();
})();
(function() {
    BoundingBox._tempVec31 = new Vector3();
})();

/**
 * Contains static methods to help in determining intersections, containment, etc.
 */ var CollisionUtil = /*#__PURE__*/ function() {
    function CollisionUtil() {}
    /**
   * Calculate the intersection point of three plane.
   * @param  p1 - Plane 1
   * @param  p2 - Plane 2
   * @param  p3 - Plane 3
   * @param out - intersection point
   */ CollisionUtil.intersectionPointThreePlanes = function intersectionPointThreePlanes(p1, p2, p3, out) {
        var p1Nor = p1.normal;
        var p2Nor = p2.normal;
        var p3Nor = p3.normal;
        Vector3.cross(p2Nor, p3Nor, CollisionUtil._tempVec30);
        Vector3.cross(p3Nor, p1Nor, CollisionUtil._tempVec31);
        Vector3.cross(p1Nor, p2Nor, CollisionUtil._tempVec32);
        var a = -Vector3.dot(p1Nor, CollisionUtil._tempVec30);
        var b = -Vector3.dot(p2Nor, CollisionUtil._tempVec31);
        var c = -Vector3.dot(p3Nor, CollisionUtil._tempVec32);
        Vector3.scale(CollisionUtil._tempVec30, p1.distance / a, CollisionUtil._tempVec30);
        Vector3.scale(CollisionUtil._tempVec31, p2.distance / b, CollisionUtil._tempVec31);
        Vector3.scale(CollisionUtil._tempVec32, p3.distance / c, CollisionUtil._tempVec32);
        Vector3.add(CollisionUtil._tempVec30, CollisionUtil._tempVec31, out);
        Vector3.add(out, CollisionUtil._tempVec32, out);
    };
    /**
   * Calculate the distance from a point to a plane.
   * @param plane - The plane
   * @param point - The point
   * @returns The distance from a point to a plane
   */ CollisionUtil.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
        return Vector3.dot(plane.normal, point) + plane.distance;
    };
    /**
   * Get the intersection type between a plane and a point.
   * @param plane - The plane
   * @param point - The point
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
        var distance = CollisionUtil.distancePlaneAndPoint(plane, point);
        if (distance > 0) {
            return PlaneIntersectionType.Front;
        }
        if (distance < 0) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a box (AABB).
   * @param plane - The plane
   * @param box - The box
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
        var min = box.min, max = box.max;
        var normal = plane.normal;
        var front = CollisionUtil._tempVec30;
        var back = CollisionUtil._tempVec31;
        if (normal.x >= 0) {
            front.x = max.x;
            back.x = min.x;
        } else {
            front.x = min.x;
            back.x = max.x;
        }
        if (normal.y >= 0) {
            front.y = max.y;
            back.y = min.y;
        } else {
            front.y = min.y;
            back.y = max.y;
        }
        if (normal.z >= 0) {
            front.z = max.z;
            back.z = min.z;
        } else {
            front.z = min.z;
            back.z = max.z;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {
            return PlaneIntersectionType.Back;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {
            return PlaneIntersectionType.Front;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a sphere.
   * @param plane - The plane
   * @param sphere - The sphere
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
        var center = sphere.center, radius = sphere.radius;
        var distance = CollisionUtil.distancePlaneAndPoint(plane, center);
        if (distance > radius) {
            return PlaneIntersectionType.Front;
        }
        if (distance < -radius) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a ray and a plane.
   * @param ray - The ray
   * @param plane - The plane
   * @returns The distance from ray to plane if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
        var normal = plane.normal;
        var zeroTolerance = MathUtil$1.zeroTolerance;
        var dir = Vector3.dot(normal, ray.direction);
        // Parallel
        if (Math.abs(dir) < zeroTolerance) {
            return -1;
        }
        var position = Vector3.dot(normal, ray.origin);
        var distance = (-plane.distance - position) / dir;
        if (distance < 0) {
            if (distance < -zeroTolerance) {
                return -1;
            }
            distance = 0;
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a box (AABB).
   * @param ray - The ray
   * @param box - The box
   * @returns The distance from ray to box if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
        var zeroTolerance = MathUtil$1.zeroTolerance;
        var origin = ray.origin, direction = ray.direction;
        var min = box.min, max = box.max;
        var dirX = direction.x;
        var dirY = direction.y;
        var dirZ = direction.z;
        var oriX = origin.x;
        var oriY = origin.y;
        var oriZ = origin.z;
        var distance = 0;
        var tmax = Number.MAX_VALUE;
        if (Math.abs(dirX) < zeroTolerance) {
            if (oriX < min.x || oriX > max.x) {
                return -1;
            }
        } else {
            var inverse = 1.0 / dirX;
            var t1 = (min.x - oriX) * inverse;
            var t2 = (max.x - oriX) * inverse;
            if (t1 > t2) {
                var temp = t1;
                t1 = t2;
                t2 = temp;
            }
            distance = Math.max(t1, distance);
            tmax = Math.min(t2, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirY) < zeroTolerance) {
            if (oriY < min.y || oriY > max.y) {
                return -1;
            }
        } else {
            var inverse1 = 1.0 / dirY;
            var t11 = (min.y - oriY) * inverse1;
            var t21 = (max.y - oriY) * inverse1;
            if (t11 > t21) {
                var temp1 = t11;
                t11 = t21;
                t21 = temp1;
            }
            distance = Math.max(t11, distance);
            tmax = Math.min(t21, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirZ) < zeroTolerance) {
            if (oriZ < min.z || oriZ > max.z) {
                return -1;
            }
        } else {
            var inverse2 = 1.0 / dirZ;
            var t12 = (min.z - oriZ) * inverse2;
            var t22 = (max.z - oriZ) * inverse2;
            if (t12 > t22) {
                var temp2 = t12;
                t12 = t22;
                t22 = temp2;
            }
            distance = Math.max(t12, distance);
            tmax = Math.min(t22, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a sphere.
   * @param ray - The ray
   * @param sphere - The sphere
   * @returns The distance from ray to sphere if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
        var origin = ray.origin, direction = ray.direction;
        var center = sphere.center, radius = sphere.radius;
        var m = CollisionUtil._tempVec30;
        Vector3.subtract(origin, center, m);
        var b = Vector3.dot(m, direction);
        var c = Vector3.dot(m, m) - radius * radius;
        if (b > 0 && c > 0) {
            return -1;
        }
        var discriminant = b * b - c;
        if (discriminant < 0) {
            return -1;
        }
        var distance = -b - Math.sqrt(discriminant);
        if (distance < 0) {
            distance = 0;
        }
        return distance;
    };
    /**
   * Check whether the boxes intersect.
   * @param boxA - The first box to check
   * @param boxB - The second box to check
   * @returns True if the boxes intersect, false otherwise
   */ CollisionUtil.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
        if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
            return false;
        }
        if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
            return false;
        }
        return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
    };
    /**
   * Check whether the spheres intersect.
   * @param sphereA - The first sphere to check
   * @param sphereB - The second sphere to check
   * @returns True if the spheres intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
        var radiisum = sphereA.radius + sphereB.radius;
        return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
    };
    /**
   * Check whether the sphere and the box intersect.
   * @param sphere - The sphere to check
   * @param box - The box to check
   * @returns True if the sphere and the box intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
        var center = sphere.center;
        var max = box.max;
        var min = box.min;
        var closestPoint = CollisionUtil._tempVec30;
        closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
        var distance = Vector3.distanceSquared(center, closestPoint);
        return distance <= sphere.radius * sphere.radius;
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param frustum - The frustum
   * @param box - The box
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ CollisionUtil.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            p.set(normal.x >= 0 ? max.x : min.x, normal.y >= 0 ? max.y : min.y, normal.z >= 0 ? max.z : min.z);
            if (Vector3.dot(normal, p) < -plane.distance) {
                return false;
            }
        }
        return true;
    };
    /**
   * Get the containment type between a frustum and a point.
   * @param frustum - The frustum
   * @param point - The point
   * @returns The containment type
   */ CollisionUtil.frustumContainsPoint = function frustumContainsPoint(frustum, point) {
        var distance = CollisionUtil.distancePlaneAndPoint(frustum.near, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.far, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.left, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.right, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.top, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        distance = CollisionUtil.distancePlaneAndPoint(frustum.bottom, point);
        if (Math.abs(distance) < MathUtil$1.zeroTolerance) {
            return ContainmentType.Intersects;
        } else if (distance < 0) {
            return ContainmentType.Disjoint;
        }
        return ContainmentType.Contains;
    };
    /**
   * Get the containment type between a frustum and a box (AABB).
   * @param frustum - The frustum
   * @param box - The box
   * @returns The containment type
   */ CollisionUtil.frustumContainsBox = function frustumContainsBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        var n = CollisionUtil._tempVec31;
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            if (normal.x >= 0) {
                p.x = max.x;
                n.x = min.x;
            } else {
                p.x = min.x;
                n.x = max.x;
            }
            if (normal.y >= 0) {
                p.y = max.y;
                n.y = min.y;
            } else {
                p.y = min.y;
                n.y = max.y;
            }
            if (normal.z >= 0) {
                p.z = max.z;
                n.z = min.z;
            } else {
                p.z = min.z;
                n.z = max.z;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, p) === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, n) === PlaneIntersectionType.Back) {
                result = ContainmentType.Intersects;
            }
        }
        return result;
    };
    /**
   * Get the containment type between a frustum and a sphere.
   * @param frustum - The frustum
   * @param sphere - The sphere
   * @returns The containment type
   */ CollisionUtil.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);
            if (intersectionType === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            } else if (intersectionType === PlaneIntersectionType.Intersecting) {
                result = ContainmentType.Intersects;
                break;
            }
        }
        return result;
    };
    return CollisionUtil;
}();
(function() {
    CollisionUtil._tempVec30 = new Vector3();
})();
(function() {
    CollisionUtil._tempVec31 = new Vector3();
})();
(function() {
    CollisionUtil._tempVec32 = new Vector3();
})();

/**
 * Represents a plane in three-dimensional space.
 */ var Plane = /*#__PURE__*/ function() {
    function Plane(normal, distance) {
        if (normal === void 0) normal = null;
        if (distance === void 0) distance = 0;
        /** The normal of the plane. */ this.normal = new Vector3();
        /** The distance of the plane along its normal to the origin. */ this.distance = 0;
        normal && this.normal.copyFrom(normal);
        this.distance = distance;
    }
    var _proto = Plane.prototype;
    /**
   * Normalize the normal vector of this plane.
   * @returns The plane after normalize
   */ _proto.normalize = function normalize() {
        Plane.normalize(this, this);
        return this;
    };
    /**
   * Creates a clone of this plane.
   * @returns A clone of this plane
   */ _proto.clone = function clone() {
        var out = new Plane();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this plane from the specified plane.
   * @param source - The specified plane
   * @returns This plane
   */ _proto.copyFrom = function copyFrom(source) {
        this.normal.copyFrom(source.normal);
        this.distance = source.distance;
        return this;
    };
    /**
   * Normalize the normal vector of the specified plane.
   * @param p - The specified plane
   * @param out - A normalized version of the specified plane
   */ Plane.normalize = function normalize(p, out) {
        var normal = p.normal;
        var factor = 1.0 / normal.length();
        Vector3.scale(normal, factor, out.normal);
        out.distance = p.distance * factor;
    };
    /**
   * Calculate the plane that contains the three specified points.
   * @param point0 - The first point
   * @param point1 - The second point
   * @param point2 - The third point
   * @param out - The calculated plane
   */ Plane.fromPoints = function fromPoints(point0, point1, point2, out) {
        var x0 = point0.x;
        var y0 = point0.y;
        var z0 = point0.z;
        var x1 = point1.x - x0;
        var y1 = point1.y - y0;
        var z1 = point1.z - z0;
        var x2 = point2.x - x0;
        var y2 = point2.y - y0;
        var z2 = point2.z - z0;
        var yz = y1 * z2 - z1 * y2;
        var xz = z1 * x2 - x1 * z2;
        var xy = x1 * y2 - y1 * x2;
        var invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);
        var x = yz * invPyth;
        var y = xz * invPyth;
        var z = xy * invPyth;
        var normal = out.normal;
        normal.x = x;
        normal.y = y;
        normal.z = z;
        out.distance = -(x * x0 + y * y0 + z * z0);
    };
    return Plane;
}();

/**
 * A bounding frustum.
 */ var BoundingFrustum = /*#__PURE__*/ function() {
    function BoundingFrustum(matrix) {
        if (matrix === void 0) matrix = null;
        this.near = new Plane();
        this.far = new Plane();
        this.left = new Plane();
        this.right = new Plane();
        this.top = new Plane();
        this.bottom = new Plane();
        matrix && this.calculateFromMatrix(matrix);
    }
    var _proto = BoundingFrustum.prototype;
    /**
   * Get the plane by the given frustum face.
   * @param face - The frustum face
   * @returns The plane get
   */ _proto.getPlane = function getPlane(face) {
        switch(face){
            case FrustumFace.Near:
                return this.near;
            case FrustumFace.Far:
                return this.far;
            case FrustumFace.Left:
                return this.left;
            case FrustumFace.Right:
                return this.right;
            case FrustumFace.Bottom:
                return this.bottom;
            case FrustumFace.Top:
                return this.top;
            default:
                return null;
        }
    };
    /**
   * Update all planes from the given matrix.
   * @param matrix - The given view-projection matrix
   */ _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
        var me = matrix.elements;
        var m11 = me[0];
        var m12 = me[1];
        var m13 = me[2];
        var m14 = me[3];
        var m21 = me[4];
        var m22 = me[5];
        var m23 = me[6];
        var m24 = me[7];
        var m31 = me[8];
        var m32 = me[9];
        var m33 = me[10];
        var m34 = me[11];
        var m41 = me[12];
        var m42 = me[13];
        var m43 = me[14];
        var m44 = me[15];
        // near
        var nearNormal = this.near.normal;
        nearNormal.set(m14 + m13, m24 + m23, m34 + m33);
        this.near.distance = m44 + m43;
        this.near.normalize();
        // far
        var farNormal = this.far.normal;
        farNormal.set(m14 - m13, m24 - m23, m34 - m33);
        this.far.distance = m44 - m43;
        this.far.normalize();
        // left
        var leftNormal = this.left.normal;
        leftNormal.set(m14 + m11, m24 + m21, m34 + m31);
        this.left.distance = m44 + m41;
        this.left.normalize();
        // right
        var rightNormal = this.right.normal;
        rightNormal.set(m14 - m11, m24 - m21, m34 - m31);
        this.right.distance = m44 - m41;
        this.right.normalize();
        // bottom
        var bottomNormal = this.bottom.normal;
        bottomNormal.set(m14 + m12, m24 + m22, m34 + m32);
        this.bottom.distance = m44 + m42;
        this.bottom.normalize();
        // top
        var topNormal = this.top.normal;
        topNormal.set(m14 - m12, m24 - m22, m34 - m32);
        this.top.distance = m44 - m42;
        this.top.normalize();
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param box - The box for testing
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ _proto.intersectsBox = function intersectsBox(box) {
        return CollisionUtil.intersectsFrustumAndBox(this, box);
    };
    /**
   * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).
   * @param sphere - The sphere for testing
   * @returns True if bounding sphere intersects with this frustum, false otherwise
   */ _proto.intersectsSphere = function intersectsSphere(sphere) {
        return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
    };
    /**
   * Creates a clone of this frustum.
   * @returns A clone of this frustum
   */ _proto.clone = function clone() {
        var out = new BoundingFrustum();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this frustum from the specified frustum.
   * @param source - The specified frustum
   * @returns This frustum
   */ _proto.copyFrom = function copyFrom(source) {
        this.near.copyFrom(source.near);
        this.far.copyFrom(source.far);
        this.left.copyFrom(source.left);
        this.right.copyFrom(source.right);
        this.bottom.copyFrom(source.bottom);
        this.top.copyFrom(source.top);
        return this;
    };
    return BoundingFrustum;
}();

/**
 * Represents a 3x3 mathematical matrix.
 */ var Matrix3x3 = /*#__PURE__*/ function() {
    function Matrix3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(9);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
    }
    var _proto = Matrix3x3.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11
   * @param m12
   * @param m13
   * @param m21
   * @param m22
   * @param m23
   * @param m31
   * @param m32
   * @param m33
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
        return this;
    };
    /**
   * Determines the sum of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the sum of the two matrices
   */ _proto.add = function add(right) {
        Matrix3x3.add(this, right, this);
        return this;
    };
    /**
   * Determines the difference between this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the difference between the two matrices
   */ _proto.subtract = function subtract(right) {
        Matrix3x3.subtract(this, right, this);
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix3x3.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2];
        var a21 = e[3], a22 = e[4], a23 = e[5];
        var a31 = e[6], a32 = e[7], a33 = e[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        return a11 * b12 + a12 * b22 + a13 * b32;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix3x3.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an angle.
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotate = function rotate(r) {
        Matrix3x3.rotate(this, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix3x3.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param translation - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(translation) {
        Matrix3x3.translate(this, translation, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix3x3.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 12; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
    };
    /**
   * Copy the value of this 3x3 matrix from the specified 4x4 matrix.
   * upper-left principle
   * @param source - The specified 4x4 matrix
   * @returns This 3x3 matrix
   */ _proto.copyFromMatrix = function copyFromMatrix(source) {
        var ae = source.elements;
        var e = this.elements;
        e[0] = ae[0];
        e[1] = ae[1];
        e[2] = ae[2];
        e[3] = ae[4];
        e[4] = ae[5];
        e[5] = ae[6];
        e[6] = ae[8];
        e[7] = ae[9];
        e[8] = ae[10];
        return this;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix3x3.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
    };
    /**
   * Determines the difference between two matrices.
   * @param left - The first matrix to subtract
   * @param right - The second matrix to subtract
   * @param out - The difference between two matrices
   */ Matrix3x3.subtract = function subtract(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] - re[0];
        oe[1] = le[1] - re[1];
        oe[2] = le[2] - re[2];
        oe[3] = le[3] - re[3];
        oe[4] = le[4] - re[4];
        oe[5] = le[5] - re[5];
        oe[6] = le[6] - re[6];
        oe[7] = le[7] - re[7];
        oe[8] = le[8] - re[8];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of two matrices
   */ Matrix3x3.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0], l12 = le[1], l13 = le[2];
        var l21 = le[3], l22 = le[4], l23 = le[5];
        var l31 = le[6], l32 = le[7], l33 = le[8];
        var r11 = re[0], r12 = re[1], r13 = re[2];
        var r21 = re[3], r22 = re[4], r23 = re[5];
        var r31 = re[6], r32 = re[7], r33 = re[8];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
        oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
        oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
        oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
        oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
        oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
        oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix3x3.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil$1.equals(le[0], re[0]) && MathUtil$1.equals(le[1], re[1]) && MathUtil$1.equals(le[2], re[2]) && MathUtil$1.equals(le[3], re[3]) && MathUtil$1.equals(le[4], re[4]) && MathUtil$1.equals(le[5], re[5]) && MathUtil$1.equals(le[6], re[6]) && MathUtil$1.equals(le[7], re[7]) && MathUtil$1.equals(le[8], re[8]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix3x3.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix3x3.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[3] = yx - wz;
        oe[6] = zx + wy;
        oe[1] = yx + wz;
        oe[4] = 1 - xx - zz;
        oe[7] = zy - wx;
        oe[2] = zx - wy;
        oe[5] = zy + wx;
        oe[8] = 1 - xx - yy;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix3x3.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = s._y;
        oe[5] = 0;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix3x3.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 1;
        oe[5] = 0;
        oe[6] = translation._x;
        oe[7] = translation._y;
        oe[8] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix3x3.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        var det = a11 * b12 + a12 * b22 + a13 * b32;
        if (!det) {
            return;
        }
        det = 1.0 / det;
        oe[0] = b12 * det;
        oe[1] = (-a33 * a12 + a13 * a32) * det;
        oe[2] = (a23 * a12 - a13 * a22) * det;
        oe[3] = b22 * det;
        oe[4] = (a33 * a11 - a13 * a31) * det;
        oe[5] = (-a23 * a11 + a13 * a21) * det;
        oe[6] = b32 * det;
        oe[7] = (-a32 * a11 + a12 * a31) * det;
        oe[8] = (a22 * a11 - a12 * a21) * det;
    };
    /**
   * Calculate a 3x3 normal matrix from a 4x4 matrix.
   * @remarks The calculation process is the transpose matrix of the inverse matrix.
   * @param mat4 - The 4x4 matrix
   * @param out - THe 3x3 normal matrix
   */ Matrix3x3.normalMatrix = function normalMatrix(mat4, out) {
        var ae = mat4.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    };
    /**
   * The specified matrix rotates around an angle.
   * @param a - The specified matrix
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix3x3.rotate = function rotate(a, r, out) {
        var ae = a.elements;
        var oe = out.elements;
        var s = Math.sin(r);
        var c = Math.cos(r);
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = c * a11 + s * a21;
        oe[1] = c * a12 + s * a22;
        oe[2] = c * a13 + s * a23;
        oe[3] = c * a21 - s * a11;
        oe[4] = c * a22 - s * a12;
        oe[5] = c * a23 - s * a13;
        oe[6] = a31;
        oe[7] = a32;
        oe[8] = a33;
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix3x3.scale = function scale(m, s, out) {
        var x = s._x, y = s._y;
        var ae = m.elements;
        var oe = out.elements;
        oe[0] = x * ae[0];
        oe[1] = x * ae[1];
        oe[2] = x * ae[2];
        oe[3] = y * ae[3];
        oe[4] = y * ae[4];
        oe[5] = y * ae[5];
        oe[6] = ae[6];
        oe[7] = ae[7];
        oe[8] = ae[8];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param translation - The given vector
   * @param out - The translated matrix
   */ Matrix3x3.translate = function translate(m, translation, out) {
        var x = translation._x, y = translation._y;
        var ae = m.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = a11;
        oe[1] = a12;
        oe[2] = a13;
        oe[3] = a21;
        oe[4] = a22;
        oe[5] = a23;
        oe[6] = x * a11 + y * a21 + a31;
        oe[7] = x * a12 + y * a22 + a32;
        oe[8] = x * a13 + y * a23 + a33;
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix3x3.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a23 = ae[5];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = a12;
            oe[5] = ae[7];
            oe[6] = a13;
            oe[7] = a23;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = ae[1];
            oe[4] = ae[4];
            oe[5] = ae[7];
            oe[6] = ae[2];
            oe[7] = ae[5];
            oe[8] = ae[8];
        }
    };
    return Matrix3x3;
}();

/**
 * Represents a four dimensional mathematical quaternion.
 */ var Quaternion = /*#__PURE__*/ function() {
    function Quaternion(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 1;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Quaternion.prototype;
    /**
   * Set the value of this quaternion, and return this quaternion.
   * @param x - The x component of the quaternion
   * @param y - The y component of the quaternion
   * @param z - The z component of the quaternion
   * @param w - The w component of the quaternion
   * @returns This quaternion
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Transforms this quaternion into its conjugated version.
   * @returns This quaternion
   */ _proto.conjugate = function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Get the rotation axis and rotation angle of the quaternion (unit: radians).
   * @param out - The axis as an output parameter
   * @returns The rotation angle (unit: radians)
   */ _proto.getAxisAngle = function getAxisAngle(out) {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        var length = _x * _x + _y * _y + _z * _z;
        if (length < MathUtil$1.zeroTolerance) {
            out._x = 1;
            out._y = 0;
            out._z = 0;
            return 0;
        } else {
            var inv = 1.0 / length;
            out._x = this._x * inv;
            out._y = this._y * inv;
            out._z = this._z * inv;
            return Math.acos(this._w) * 2.0;
        }
    };
    /**
   * Identity this quaternion.
   * @returns This quaternion after identity
   */ _proto.identity = function identity() {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this quaternion.
   * @returns The length of this quaternion
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculates the squared length of this quaternion.
   * @returns The squared length of this quaternion
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Converts this quaternion into a unit quaternion.
   * @returns This quaternion
   */ _proto.normalize = function normalize() {
        Quaternion.normalize(this, this);
        return this;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->pitch y->yaw z->roll
   */ _proto.toEuler = function toEuler(out) {
        this._toYawPitchRoll(out);
        var t = out._x;
        out._x = out._y;
        out._y = t;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->yaw y->pitch z->roll
   */ _proto.toYawPitchRoll = function toYawPitchRoll(out) {
        this._toYawPitchRoll(out);
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Calculate this quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateX = function rotateX(rad) {
        Quaternion.rotateX(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateY = function rotateY(rad) {
        Quaternion.rotateY(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateZ = function rotateZ(rad) {
        Quaternion.rotateZ(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
        Quaternion.rotationAxisAngle(axis, rad, this);
        return this;
    };
    /**
   * Determines the product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The product of the two quaternions
   */ _proto.multiply = function multiply(quat) {
        Quaternion.multiply(this, quat, this);
        return this;
    };
    /**
   * Invert this quaternion.
   * @returns This quaternion after invert
   */ _proto.invert = function invert() {
        Quaternion.invert(this, this);
        return this;
    };
    /**
   * Determines the dot product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The dot product of two quaternions
   */ _proto.dot = function dot(quat) {
        return Quaternion.dot(this, quat);
    };
    /**
   * Performs a linear blend between this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @param t - The blend amount where 0 returns this and 1 quat
   * @returns - The result of linear blending between two quaternions
   */ _proto.lerp = function lerp(quat, t) {
        Quaternion.lerp(this, quat, t, this);
        return this;
    };
    /**
   * Calculate this quaternion rotation around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
        Quaternion._tempQuat1.rotationAxisAngle(axis, rad);
        this.multiply(Quaternion._tempQuat1);
        return this;
    };
    /**
   * Creates a clone of this quaternion.
   * @returns A clone of this quaternion
   */ _proto.clone = function clone() {
        return new Quaternion(this._x, this._y, this._z, this._w);
    };
    /**
   * Copy this quaternion from the specified quaternion.
   * @param source - The specified quaternion
   * @returns This quaternion
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this quaternion from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This quaternion
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this quaternion to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this quaternion to a JSON representation.
   * @returns A JSON Object representation of this quaternion
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
        // https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
        var _this = this, x = _this._x, y = _this._y, z = _this._z, w = _this._w;
        var xx = x * x;
        var sinP = 2.0 * (x * w - y * z);
        // use 90 degrees if out of range
        out._y = Math.abs(sinP) >= 1 ? Math.sign(sinP) * (Math.PI / 2) : Math.asin(sinP);
        out._x = Math.atan2(2.0 * (z * x + y * w), 1.0 - 2.0 * (y * y + xx));
        out._z = Math.atan2(2.0 * (x * y + z * w), 1.0 - 2.0 * (z * z + xx));
    };
    /**
   * Determines the sum of two quaternions.
   * @param left - The first quaternion to add
   * @param right - The second quaternion to add
   * @param out - The sum of two quaternions
   */ Quaternion.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two quaternions.
   * @param left - The first quaternion to multiply
   * @param right - The second quaternion to multiply
   * @param out - The product of two quaternions
   */ Quaternion.multiply = function multiply(left, right, out) {
        var ax = left._x, ay = left._y, az = left._z, aw = left._w;
        var bx = right._x, by = right._y, bz = right._z, bw = right._w;
        out._x = ax * bw + aw * bx + ay * bz - az * by;
        out._y = ay * bw + aw * by + az * bx - ax * bz;
        out._z = az * bw + aw * bz + ax * by - ay * bx;
        out._w = aw * bw - ax * bx - ay * by - az * bz;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate quaternion that contains conjugated version of the specified quaternion.
   * @param a - The specified quaternion
   * @param out - The conjugate version of the specified quaternion
   */ Quaternion.conjugate = function conjugate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = a._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two quaternions.
   * @param left - The first quaternion to dot
   * @param right - The second quaternion to dot
   * @returns The dot product of two quaternions
   */ Quaternion.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines whether the specified quaternions are equals.
   * @param left - The first quaternion to compare
   * @param right - The second quaternion to compare
   * @returns True if the specified quaternions are equals, false otherwise
   */ Quaternion.equals = function equals(left, right) {
        return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z) && MathUtil$1.equals(left._w, right._w);
    };
    /**
   * Calculate a quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @param out - The quaternion after rotate
   */ Quaternion.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
        var normalAxis = Quaternion._tempVector3;
        Vector3.normalize(axis, normalAxis);
        rad *= 0.5;
        var s = Math.sin(rad);
        out._x = normalAxis._x * s;
        out._y = normalAxis._y * s;
        out._z = normalAxis._z * s;
        out._w = Math.cos(rad);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).
   * @param x - The radian of rotation around X (pitch)
   * @param y - The radian of rotation around Y (yaw)
   * @param z - The radian of rotation around Z (roll)
   * @param out - The calculated quaternion
   */ Quaternion.rotationEuler = function rotationEuler(x, y, z, out) {
        Quaternion.rotationYawPitchRoll(y, x, z, out);
    };
    /**
   * Calculate a quaternion from the specified yaw, pitch and roll angles.
   * @param yaw - Yaw around the y axis in radians
   * @param pitch - Pitch around the x axis in radians
   * @param roll - Roll around the z axis in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        var cosYawPitch = cosYaw * cosPitch;
        var sinYawPitch = sinYaw * sinPitch;
        out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
        out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion from the specified 3x3 matrix.
   * @param m - The specified 3x3 matrix
   * @param out - The calculated quaternion
   */ Quaternion.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
        var me = m.elements;
        var m11 = me[0], m12 = me[1], m13 = me[2];
        var m21 = me[3], m22 = me[4], m23 = me[5];
        var m31 = me[6], m32 = me[7], m33 = me[8];
        var scale = m11 + m22 + m33;
        var sqrt, half;
        if (scale > 0) {
            sqrt = Math.sqrt(scale + 1.0);
            out._w = sqrt * 0.5;
            sqrt = 0.5 / sqrt;
            out._x = (m23 - m32) * sqrt;
            out._y = (m31 - m13) * sqrt;
            out._z = (m12 - m21) * sqrt;
        } else if (m11 >= m22 && m11 >= m33) {
            sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
            half = 0.5 / sqrt;
            out._x = 0.5 * sqrt;
            out._y = (m12 + m21) * half;
            out._z = (m13 + m31) * half;
            out._w = (m23 - m32) * half;
        } else if (m22 > m33) {
            sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
            half = 0.5 / sqrt;
            out._x = (m21 + m12) * half;
            out._y = 0.5 * sqrt;
            out._z = (m32 + m23) * half;
            out._w = (m31 - m13) * half;
        } else {
            sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
            half = 0.5 / sqrt;
            out._x = (m13 + m31) * half;
            out._y = (m23 + m32) * half;
            out._z = 0.5 * sqrt;
            out._w = (m12 - m21) * half;
        }
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate the inverse of the specified quaternion.
   * @param a - The quaternion whose inverse is to be calculated
   * @param out - The inverse of the specified quaternion
   */ Quaternion.invert = function invert(a, out) {
        var x = a._x, y = a._y, z = a._z, w = a._w;
        var dot = x * x + y * y + z * z + w * w;
        if (dot > MathUtil$1.zeroTolerance) {
            var invDot = 1.0 / dot;
            out._x = -x * invDot;
            out._y = -y * invDot;
            out._z = -z * invDot;
            out._w = w * invDot;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Performs a linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two quaternions
   */ Quaternion.lerp = function lerp(start, end, t, out) {
        var inv = 1.0 - t;
        if (Quaternion.dot(start, end) >= 0) {
            out._x = start._x * inv + end._x * t;
            out._y = start._y * inv + end._y * t;
            out._z = start._z * inv + end._z * t;
            out._w = start._w * inv + end._w * t;
        } else {
            out._x = start._x * inv - end._x * t;
            out._y = start._y * inv - end._y * t;
            out._z = start._z * inv - end._z * t;
            out._w = start._w * inv - end._w * t;
        }
        out.normalize();
    };
    /**
   * Performs a spherical linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param amount - The blend amount where 0 returns start and 1 end
   * @param out - The result of spherical linear blending between two quaternions
   */ Quaternion.slerp = function slerp(start, end, amount, out) {
        var opposite;
        var inverse;
        var dot = Quaternion.dot(start, end);
        if (Math.abs(dot) > 1.0 - MathUtil$1.zeroTolerance) {
            inverse = 1.0 - amount;
            opposite = amount * Math.sign(dot);
        } else {
            var acos = Math.acos(Math.abs(dot));
            var invSin = 1.0 / Math.sin(acos);
            inverse = Math.sin((1.0 - amount) * acos) * invSin;
            opposite = Math.sin(amount * acos) * invSin * Math.sign(dot);
        }
        out.x = inverse * start.x + opposite * end.x;
        out.y = inverse * start.y + opposite * end.y;
        out.z = inverse * start.z + opposite * end.z;
        out.w = inverse * start.w + opposite * end.w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scales the specified quaternion magnitude to unit length.
   * @param a - The specified quaternion
   * @param out - The normalized quaternion
   */ Quaternion.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil$1.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Calculate a quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationX = function rotationX(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = s;
        out._y = 0;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationY = function rotationY(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = s;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationZ = function rotationZ(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = 0;
        out._z = s;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around X axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateX = function rotateX(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _w * bx;
        out._y = _y * bw + _z * bx;
        out._z = _z * bw - _y * bx;
        out._w = _w * bw - _x * bx;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Y axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateY = function rotateY(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw - _z * by;
        out._y = _y * bw + _w * by;
        out._z = _z * bw + _x * by;
        out._w = _w * bw - _y * by;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Z axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateZ = function rotateZ(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _y * bz;
        out._y = _y * bw - _x * bz;
        out._z = _z * bw + _w * bz;
        out._w = _w * bw - _z * bz;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scale a quaternion by a given number.
   * @param a - The quaternion
   * @param s - The given number
   * @param out - The scaled quaternion
   */ Quaternion.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class$4(Quaternion, [
        {
            key: "x",
            get: /**
   * The x component of the quaternion.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the quaternion.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the quaternion.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "normalized",
            get: /**
   * Indicting whether this instance is normalized.
   */ function get() {
                return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil$1.zeroTolerance;
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the quaternion.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Quaternion;
}();
(function() {
    /** @internal */ Quaternion._tempVector3 = new Vector3();
})();
(function() {
    /** @internal */ Quaternion._tempQuat1 = new Quaternion();
})();

/**
 * Represents a 4x4 mathematical matrix.
 */ var Matrix = /*#__PURE__*/ function() {
    function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m14 === void 0) m14 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m24 === void 0) m24 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        if (m34 === void 0) m34 = 0;
        if (m41 === void 0) m41 = 0;
        if (m42 === void 0) m42 = 0;
        if (m43 === void 0) m43 = 0;
        if (m44 === void 0) m44 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] first column and fourth row value m14
   * elements[4] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(16);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
    }
    var _proto = Matrix.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11 - column 1, row 1
   * @param m12 - column 1, row 2
   * @param m13 - column 1, row 3
   * @param m14 - column 1, row 4
   * @param m21 - column 2, row 1
   * @param m22 - column 2, row 2
   * @param m23 - column 2, row 3
   * @param m24 - column 2, row 4
   * @param m31 - column 3, row 1
   * @param m32 - column 3, row 2
   * @param m33 - column 3, row 3
   * @param m34 - column 3, row 4
   * @param m41 - column 4, row 1
   * @param m42 - column 4, row 2
   * @param m43 - column 4, row 3
   * @param m44 - column 4, row 4
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
        var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
        var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
        var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        // Calculate the determinant
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    };
    /**
   * Decompose this matrix to translation, rotation and scale elements.
   * @param translation - Translation vector as an output parameter
   * @param rotation - Rotation quaternion as an output parameter
   * @param scale - Scale vector as an output parameter
   * @returns True if this matrix can be decomposed, false otherwise
   */ _proto.decompose = function decompose(translation, rotation, scale) {
        var rm = Matrix._tempMat30;
        var e = this.elements;
        var rme = rm.elements;
        var m11 = e[0];
        var m12 = e[1];
        var m13 = e[2];
        var m14 = e[3];
        var m21 = e[4];
        var m22 = e[5];
        var m23 = e[6];
        var m24 = e[7];
        var m31 = e[8];
        var m32 = e[9];
        var m33 = e[10];
        var m34 = e[11];
        translation.set(e[12], e[13], e[14]);
        var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
        var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
        var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
        var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        scale.set(sx, sy, sz);
        if (Math.abs(sx) < MathUtil$1.zeroTolerance || Math.abs(sy) < MathUtil$1.zeroTolerance || Math.abs(sz) < MathUtil$1.zeroTolerance) {
            rotation.identity();
            return false;
        } else {
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            rme[0] = m11 * invSX;
            rme[1] = m12 * invSX;
            rme[2] = m13 * invSX;
            rme[3] = m21 * invSY;
            rme[4] = m22 * invSY;
            rme[5] = m23 * invSY;
            rme[6] = m31 * invSZ;
            rme[7] = m32 * invSZ;
            rme[8] = m33 * invSZ;
            Quaternion.rotationMatrix3x3(rm, rotation);
            return true;
        }
    };
    /**
   * Get rotation from this matrix.
   * @param out - Rotation quaternion as an output parameter
   * @returns The out
   */ _proto.getRotation = function getRotation(out) {
        var e = this.elements;
        var trace = e[0] + e[5] + e[10];
        if (trace > MathUtil$1.zeroTolerance) {
            var s = Math.sqrt(trace + 1.0) * 2;
            out._w = 0.25 * s;
            out._x = (e[6] - e[9]) / s;
            out._y = (e[8] - e[2]) / s;
            out._z = (e[1] - e[4]) / s;
        } else if (e[0] > e[5] && e[0] > e[10]) {
            var s1 = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;
            out._w = (e[6] - e[9]) / s1;
            out._x = 0.25 * s1;
            out._y = (e[1] + e[4]) / s1;
            out._z = (e[8] + e[2]) / s1;
        } else if (e[5] > e[10]) {
            var s2 = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;
            out._w = (e[8] - e[2]) / s2;
            out._x = (e[1] + e[4]) / s2;
            out._y = 0.25 * s2;
            out._z = (e[6] + e[9]) / s2;
        } else {
            var s3 = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;
            out._w = (e[1] - e[4]) / s3;
            out._x = (e[8] + e[2]) / s3;
            out._y = (e[6] + e[9]) / s3;
            out._z = 0.25 * s3;
        }
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Get scale from this matrix.
   * @param out - Scale vector as an output parameter
   * @returns The out
   */ _proto.getScaling = function getScaling(out) {
        //getScale()
        var e = this.elements;
        var m11 = e[0], m12 = e[1], m13 = e[2];
        var m21 = e[4], m22 = e[5], m23 = e[6];
        var m31 = e[8], m32 = e[9], m33 = e[10];
        out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
        return out;
    };
    /**
   * Get translation from this matrix.
   * @param out - Translation vector as an output parameter
   * @returns The out
   */ _proto.getTranslation = function getTranslation(out) {
        var e = this.elements;
        out.set(e[12], e[13], e[14]);
        return out;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 1;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = 1;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
        Matrix.rotateAxisAngle(this, axis, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param v - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(v) {
        Matrix.translate(this, v, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        e[9] = se[9];
        e[10] = se[10];
        e[11] = se[11];
        e[12] = se[12];
        e[13] = se[13];
        e[14] = se[14];
        e[15] = se[15];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 16; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
        out[outOffset + 9] = e[9];
        out[outOffset + 10] = e[10];
        out[outOffset + 11] = e[11];
        out[outOffset + 12] = e[12];
        out[outOffset + 13] = e[13];
        out[outOffset + 14] = e[14];
        out[outOffset + 15] = e[15];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of the two matrices
   */ Matrix.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        // prettier-ignore
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3], l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7], l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11], l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        // prettier-ignore
        var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3], r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7], r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11], r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil$1.equals(le[0], re[0]) && MathUtil$1.equals(le[1], re[1]) && MathUtil$1.equals(le[2], re[2]) && MathUtil$1.equals(le[3], re[3]) && MathUtil$1.equals(le[4], re[4]) && MathUtil$1.equals(le[5], re[5]) && MathUtil$1.equals(le[6], re[6]) && MathUtil$1.equals(le[7], re[7]) && MathUtil$1.equals(le[8], re[8]) && MathUtil$1.equals(le[9], re[9]) && MathUtil$1.equals(le[10], re[10]) && MathUtil$1.equals(le[11], re[11]) && MathUtil$1.equals(le[12], re[12]) && MathUtil$1.equals(le[13], re[13]) && MathUtil$1.equals(le[14], re[14]) && MathUtil$1.equals(le[15], re[15]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
        oe[9] = se[9] * inv + ee[9] * t;
        oe[10] = se[10] * inv + ee[10] * t;
        oe[11] = se[11] * inv + ee[11] * t;
        oe[12] = se[12] * inv + ee[12] * t;
        oe[13] = se[13] * inv + ee[13] * t;
        oe[14] = se[14] * inv + ee[14] * t;
        oe[15] = se[15] * inv + ee[15] * t;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
        oe[9] = le[9] + re[9];
        oe[10] = le[10] + re[10];
        oe[11] = le[11] + re[11];
        oe[12] = le[12] + re[12];
        oe[13] = le[13] + re[13];
        oe[14] = le[14] + re[14];
        oe[15] = le[15] + re[15];
    };
    /**
   * Multiplies a matrix by a scalar.
   * @param source - The matrix to multiply
   * @param scalar - The scalar to multiply
   * @param out - The result of multiplying a matrix by a scalar
   */ Matrix.multiplyScalar = function multiplyScalar(source, scalar, out) {
        var se = source.elements;
        var oe = out.elements;
        oe[0] = se[0] * scalar;
        oe[1] = se[1] * scalar;
        oe[2] = se[2] * scalar;
        oe[3] = se[3] * scalar;
        oe[4] = se[4] * scalar;
        oe[5] = se[5] * scalar;
        oe[6] = se[6] * scalar;
        oe[7] = se[7] * scalar;
        oe[8] = se[8] * scalar;
        oe[9] = se[9] * scalar;
        oe[10] = se[10] * scalar;
        oe[11] = se[11] * scalar;
        oe[12] = se[12] * scalar;
        oe[13] = se[13] * scalar;
        oe[14] = se[14] * scalar;
        oe[15] = se[15] * scalar;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[1] = yx + wz;
        oe[2] = zx - wy;
        oe[3] = 0;
        oe[4] = yx - wz;
        oe[5] = 1 - xx - zz;
        oe[6] = zy + wx;
        oe[7] = 0;
        oe[8] = zx + wy;
        oe[9] = zy - wx;
        oe[10] = 1 - xx - yy;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The matrix after rotate
   */ Matrix.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
        var oe = out.elements;
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s, c, t;
        if (Math.abs(len) < MathUtil$1.zeroTolerance) {
            return;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        // Perform rotation-specific matrix multiplication
        oe[0] = x * x * t + c;
        oe[1] = y * x * t + z * s;
        oe[2] = z * x * t - y * s;
        oe[3] = 0;
        oe[4] = x * y * t - z * s;
        oe[5] = y * y * t + c;
        oe[6] = z * y * t + x * s;
        oe[7] = 0;
        oe[8] = x * z * t + y * s;
        oe[9] = y * z * t - x * s;
        oe[10] = z * z * t + c;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from a quaternion and a translation.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param translation - The translation used to calculate the matrix
   * @param out - The calculated matrix
   */ Matrix.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
        Matrix.rotationQuaternion(quaternion, out);
        var oe = out.elements;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
    };
    /**
   * Calculate an affine matrix.
   * @param scale - The scale used to calculate matrix
   * @param rotation - The rotation used to calculate matrix
   * @param translation - The translation used to calculate matrix
   * @param out - The calculated matrix
   */ Matrix.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
        var oe = out.elements;
        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale._x;
        var sy = scale._y;
        var sz = scale._z;
        oe[0] = (1 - (yy + zz)) * sx;
        oe[1] = (xy + wz) * sx;
        oe[2] = (xz - wy) * sx;
        oe[3] = 0;
        oe[4] = (xy - wz) * sy;
        oe[5] = (1 - (xx + zz)) * sy;
        oe[6] = (yz + wx) * sy;
        oe[7] = 0;
        oe[8] = (xz + wy) * sz;
        oe[9] = (yz - wx) * sz;
        oe[10] = (1 - (xx + yy)) * sz;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = s._y;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = s._z;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = 1;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 1;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
        oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
        oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
        oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
        oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
        oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
        oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
        oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    };
    /**
   * Calculate a right-handed look-at matrix.
   * @param eye - The position of the viewer's eye
   * @param target - The camera look-at target
   * @param up - The camera's up vector
   * @param out - The calculated look-at matrix
   */ Matrix.lookAt = function lookAt(eye, target, up, out) {
        var oe = out.elements;
        var xAxis = Matrix._tempVec30;
        var yAxis = Matrix._tempVec31;
        var zAxis = Matrix._tempVec32;
        Vector3.subtract(eye, target, zAxis);
        zAxis.normalize();
        Vector3.cross(up, zAxis, xAxis);
        xAxis.normalize();
        Vector3.cross(zAxis, xAxis, yAxis);
        oe[0] = xAxis._x;
        oe[1] = yAxis._x;
        oe[2] = zAxis._x;
        oe[3] = 0;
        oe[4] = xAxis._y;
        oe[5] = yAxis._y;
        oe[6] = zAxis._y;
        oe[7] = 0;
        oe[8] = xAxis._z;
        oe[9] = yAxis._z;
        oe[10] = zAxis._z;
        oe[11] = 0;
        oe[12] = -Vector3.dot(xAxis, eye);
        oe[13] = -Vector3.dot(yAxis, eye);
        oe[14] = -Vector3.dot(zAxis, eye);
        oe[15] = 1;
    };
    /**
   * Calculate an orthographic projection matrix.
   * @param left - The left edge of the viewing
   * @param right - The right edge of the viewing
   * @param bottom - The bottom edge of the viewing
   * @param top - The top edge of the viewing
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated orthographic projection matrix
   */ Matrix.ortho = function ortho(left, right, bottom, top, near, far, out) {
        var oe = out.elements;
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        oe[0] = -2 * lr;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = -2 * bt;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 2 * nf;
        oe[11] = 0;
        oe[12] = (left + right) * lr;
        oe[13] = (top + bottom) * bt;
        oe[14] = (far + near) * nf;
        oe[15] = 1;
    };
    /**
   * Calculate a perspective projection matrix.
   * @param fovY - Field of view in the y direction, in radians
   * @param aspect - Aspect ratio, defined as view space width divided by height
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated perspective projection matrix
   */ Matrix.perspective = function perspective(fovY, aspect, near, far, out) {
        var oe = out.elements;
        var f = 1.0 / Math.tan(fovY / 2);
        var nf = 1 / (near - far);
        oe[0] = f / aspect;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = f;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = (far + near) * nf;
        oe[11] = -1;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 2 * far * near * nf;
        oe[15] = 0;
    };
    /**
   * The specified matrix rotates around an arbitrary axis.
   * @param m - The specified matrix
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < MathUtil$1.zeroTolerance) {
            return;
        }
        var me = m.elements;
        var oe = out.elements;
        var s, c, t;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
        var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
        var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
        // Construct the elements of the rotation matrix
        var b11 = x * x * t + c;
        var b12 = y * x * t + z * s;
        var b13 = z * x * t - y * s;
        var b21 = x * y * t - z * s;
        var b22 = y * y * t + c;
        var b23 = z * y * t + x * s;
        var b31 = x * z * t + y * s;
        var b32 = y * z * t - x * s;
        var b33 = z * z * t + c;
        // Perform rotation-specific matrix multiplication
        oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
        oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
        oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
        oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
        oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
        oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
        oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
        oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
        oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
        oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
        oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
        oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
        if (m !== out) {
            // If the source and destination differ, copy the unchanged last row
            oe[12] = me[12];
            oe[13] = me[13];
            oe[14] = me[14];
            oe[15] = me[15];
        }
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix.scale = function scale(m, s, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = s._x, y = s._y, z = s._z;
        oe[0] = me[0] * x;
        oe[1] = me[1] * x;
        oe[2] = me[2] * x;
        oe[3] = me[3] * x;
        oe[4] = me[4] * y;
        oe[5] = me[5] * y;
        oe[6] = me[6] * y;
        oe[7] = me[7] * y;
        oe[8] = me[8] * z;
        oe[9] = me[9] * z;
        oe[10] = me[10] * z;
        oe[11] = me[11] * z;
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param v - The given vector
   * @param out - The translated matrix
   */ Matrix.translate = function translate(m, v, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = v._x, y = v._y, z = v._z;
        if (m === out) {
            oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
            oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
            oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
            oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
        } else {
            var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
            var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
            var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
            oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
            oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
            oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
            oe[12] = a11 * x + a21 * y + a31 * z + me[12];
            oe[13] = a12 * x + a22 * y + a32 * z + me[13];
            oe[14] = a13 * x + a23 * y + a33 * z + me[14];
            oe[15] = a14 * x + a24 * y + a34 * z + me[15];
        }
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a14 = ae[3];
            var a23 = ae[6];
            var a24 = ae[7];
            var a34 = ae[11];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = a12;
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = a13;
            oe[9] = a23;
            oe[11] = ae[14];
            oe[12] = a14;
            oe[13] = a24;
            oe[14] = a34;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = ae[1];
            oe[5] = ae[5];
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = ae[2];
            oe[9] = ae[6];
            oe[10] = ae[10];
            oe[11] = ae[14];
            oe[12] = ae[3];
            oe[13] = ae[7];
            oe[14] = ae[11];
            oe[15] = ae[15];
        }
    };
    return Matrix;
}();
(function() {
    Matrix._tempVec30 = new Vector3();
})();
(function() {
    Matrix._tempVec31 = new Vector3();
})();
(function() {
    Matrix._tempVec32 = new Vector3();
})();
(function() {
    Matrix._tempMat30 = new Matrix3x3();
})();
(function() {
    /** @internal Identity matrix. */ Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
})();

/**
 * Represents a ray with an origin and a direction in 3D space.
 */ var Ray = /*#__PURE__*/ function() {
    function Ray(origin, direction) {
        if (origin === void 0) origin = null;
        if (direction === void 0) direction = null;
        /** The origin of the ray. */ this.origin = new Vector3();
        /** The normalized direction of the ray. */ this.direction = new Vector3();
        origin && this.origin.copyFrom(origin);
        direction && this.direction.copyFrom(direction);
    }
    var _proto = Ray.prototype;
    /**
   * Check if this ray intersects the specified plane.
   * @param plane - The specified plane
   * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise
   */ _proto.intersectPlane = function intersectPlane(plane) {
        return CollisionUtil.intersectsRayAndPlane(this, plane);
    };
    /**
   * Check if this ray intersects the specified sphere.
   * @param sphere - The specified sphere
   * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise
   */ _proto.intersectSphere = function intersectSphere(sphere) {
        return CollisionUtil.intersectsRayAndSphere(this, sphere);
    };
    /**
   * Check if this ray intersects the specified box (AABB).
   * @param box - The specified box
   * @returns The distance from this ray to the specified box if intersecting, -1 otherwise
   */ _proto.intersectBox = function intersectBox(box) {
        return CollisionUtil.intersectsRayAndBox(this, box);
    };
    /**
   * The coordinates of the specified distance from the origin in the ray direction.
   * @param distance - The specified distance
   * @param out - The coordinates as an output parameter
   * @returns The out
   */ _proto.getPoint = function getPoint(distance, out) {
        Vector3.scale(this.direction, distance, out);
        return out.add(this.origin);
    };
    return Ray;
}();

/**
 * Describes a 2D-vector.
 */ var Vector2 = /*#__PURE__*/ function() {
    function Vector2(x, y) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
    }
    var _proto = Vector2.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y) {
        this._x = x;
        this._y = y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y;
        return Math.sqrt(_x * _x + _y * _y);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y;
        return _x * _x + _y * _y;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector2.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector2(this._x, this._y);
    };
    /**
   * Copy from vector2 like object.
   * @param source - Vector2 like object
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector2.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector2.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector2.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector2.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector2.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y;
    };
    /**
   * Determines the distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The distance of two vectors
   */ Vector2.distance = function distance(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return Math.sqrt(x * x + y * y);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The squared distance of two vectors
   */ Vector2.distanceSquared = function distanceSquared(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return x * x + y * y;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector2.equals = function equals(left, right) {
        return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param t - The blend amount where 0 returns left and 1 right
   * @param out - The result of linear blending between two vectors
   */ Vector2.lerp = function lerp(left, right, t, out) {
        var _x = left._x, _y = left._y;
        out._x = _x + (right._x - _x) * t;
        out._y = _y + (right._y - _y) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector2.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector2.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param left - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector2.negate = function negate(left, out) {
        out._x = -left._x;
        out._y = -left._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param left - The vector to normalize
   * @param out - The normalized vector
   */ Vector2.normalize = function normalize(left, out) {
        var _x = left._x, _y = left._y;
        var len = Math.sqrt(_x * _x + _y * _y);
        if (len > MathUtil$1.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Scale a vector by the given value.
   * @param left - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector2.scale = function scale(left, s, out) {
        out._x = left._x * s;
        out._y = left._y * s;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class$4(Vector2, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector2;
}();
(function() {
    /** @internal */ Vector2._zero = new Vector2(0.0, 0.0);
})();
(function() {
    /** @internal */ Vector2._one = new Vector2(1.0, 1.0);
})();

/**
 * Describes a 4D-vector.
 */ var Vector4 = /*#__PURE__*/ function() {
    function Vector4(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Vector4.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @param w - The w component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._w += right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._w -= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._w *= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._w /= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._w = -this._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector4.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._w *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        var ret = new Vector4(this._x, this._y, this._z, this._w);
        return ret;
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector by an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector4.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector4.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._w = left._w - right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector4.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._w = left._w * right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector4.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._w = left._w / right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector4.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector4.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector4.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return x * x + y * y + z * z + w * w;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector4.equals = function equals(left, right) {
        return MathUtil$1.equals(left._x, right._x) && MathUtil$1.equals(left._y, right._y) && MathUtil$1.equals(left._z, right._z) && MathUtil$1.equals(left._w, right._w);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector4.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z, _w = start._w;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._w = _w + (end._w - _w) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector4.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._w = Math.max(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector4.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._w = Math.min(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector4.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = -a._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector4.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil$1.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector4.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector4.transform = function transform(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z, _w = v._w;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param q - The transform quaternion
   * @param out - The transformed vector
   */ Vector4.transformByQuat = function transformByQuat(v, q, out) {
        var x = v._x, y = v._y, z = v._z, w = v._w;
        var qx = q._x;
        var qy = q._y;
        var qz = q._z;
        var qw = q._w;
        // calculate quat * vec
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._w = w;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class$4(Vector4, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the vector.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector4;
}();
(function() {
    /** @internal */ Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
})();
(function() {
    /** @internal */ Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);
})();

/**
 * Describes a color in the from of RGBA (in order: R, G, B, A).
 */ var Color$1 = /*#__PURE__*/ function() {
    function Color(r, g, b, a) {
        if (r === void 0) r = 1;
        if (g === void 0) g = 1;
        if (b === void 0) b = 1;
        if (a === void 0) a = 1;
        /** @internal */ this._onValueChanged = null;
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
    }
    var _proto = Color.prototype;
    /**
   * Set the value of this color.
   * @param r - The red component of the color
   * @param g - The green component of the color
   * @param b - The blue component of the color
   * @param a - The alpha component of the color
   * @returns This color.
   */ _proto.set = function set(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this color and the specified color.
   * @param color - The specified color
   * @returns The added color
   */ _proto.add = function add(color) {
        this._r += color._r;
        this._g += color._g;
        this._b += color._b;
        this._a += color._a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Scale this color by the given value.
   * @param s - The amount by which to scale the color
   * @returns The scaled color
   */ _proto.scale = function scale(s) {
        this._r *= s;
        this._g *= s;
        this._b *= s;
        this._a *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this color.
   * @returns A clone of this color
   */ _proto.clone = function clone() {
        var ret = new Color(this._r, this._g, this._b, this._a);
        return ret;
    };
    /**
   * Copy from color like object.
   * @param source - Color like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._r = source.r;
        this._g = source.g;
        this._b = source.b;
        this._a = source.a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Modify components (r, g, b) of this color from gamma space to linear space.
   * @param out - The color in linear space
   * @returns The color in linear space
   */ _proto.toLinear = function toLinear(out) {
        out._r = Color.gammaToLinearSpace(this._r);
        out._g = Color.gammaToLinearSpace(this._g);
        out._b = Color.gammaToLinearSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Modify components (r, g, b) of this color from linear space to gamma space.
   * @param out - The color in gamma space
   * @returns The color in gamma space
   */ _proto.toGamma = function toGamma(out) {
        out._r = Color.linearToGammaSpace(this._r);
        out._g = Color.linearToGammaSpace(this._g);
        out._b = Color.linearToGammaSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Gets the brightness.
   * @returns The Hue-Saturation-Brightness (HSB) saturation for this
   */ _proto.getBrightness = function getBrightness() {
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var max = r;
        var min = r;
        if (g > max) max = g;
        if (b > max) max = b;
        if (g < min) min = g;
        if (b < min) min = b;
        return (max + min) / 2;
    };
    /**
   * Serialize this color to a JSON representation.
   * @return A JSON representation of this color
   */ _proto.toJSON = function toJSON() {
        return {
            r: this._r,
            g: this._g,
            b: this._b,
            a: this._a
        };
    };
    /**
   * Modify a value from the gamma space to the linear space.
   * @param value - The value in gamma space
   * @returns The value in linear space
   */ Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value <= 0.04045) return value / 12.92;
        else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);
        else return Math.pow(value, 2.4);
    };
    /**
   * Modify a value from the linear space to the gamma space.
   * @param value - The value in linear space
   * @returns The value in gamma space
   */ Color.linearToGammaSpace = function linearToGammaSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value < 0.0031308) return 12.92 * value;
        else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;
        else return Math.pow(value, 0.41666);
    };
    /**
   * Determines whether the specified colors are equals.
   * @param left - The first color to compare
   * @param right - The second color to compare
   * @returns True if the specified colors are equals, false otherwise
   */ Color.equals = function equals(left, right) {
        return MathUtil$1.equals(left._r, right._r) && MathUtil$1.equals(left._g, right._g) && MathUtil$1.equals(left._b, right._b) && MathUtil$1.equals(left._a, right._a);
    };
    /**
   * Determines the sum of two colors.
   * @param left - The first color to add
   * @param right - The second color to add
   * @param out - The sum of two colors
   * @returns The added color
   */ Color.add = function add(left, right, out) {
        out._r = left._r + right._r;
        out._g = left._g + right._g;
        out._b = left._b + right._b;
        out._a = left._a + right._a;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Determines the difference between two colors.
   * @param left - The first color to subtract
   * @param right - The second color to subtract
   * @param out - The difference between two colors
   */ Color.subtract = function subtract(left, right, out) {
        out._r = left._r - right._r;
        out._g = left._g - right._g;
        out._b = left._b - right._b;
        out._a = left._a - right._a;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scale a color by the given value.
   * @param left - The color to scale
   * @param s - The amount by which to scale the color
   * @param out - The scaled color
   * @returns The scaled color
   */ Color.scale = function scale(left, s, out) {
        out._r = left._r * s;
        out._g = left._g * s;
        out._b = left._b * s;
        out._a = left._a * s;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Performs a linear interpolation between two color.
   * @param start - The first color
   * @param end - The second color
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two color
   */ Color.lerp = function lerp(start, end, t, out) {
        var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
        out._r = _r + (end._r - _r) * t;
        out._g = _g + (end._g - _g) * t;
        out._b = _b + (end._b - _b) * t;
        out._a = _a + (end._a - _a) * t;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    _create_class$4(Color, [
        {
            key: "r",
            get: /**
   * The red component of the color, 0~1.
   */ function get() {
                return this._r;
            },
            set: function set(value) {
                this._r = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "g",
            get: /**
   * The green component of the color, 0~1.
   */ function get() {
                return this._g;
            },
            set: function set(value) {
                this._g = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "b",
            get: /**
   * The blue component of the color, 0~1.
   */ function get() {
                return this._b;
            },
            set: function set(value) {
                this._b = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "a",
            get: /**
   * The alpha component of the color, 0~1.
   */ function get() {
                return this._a;
            },
            set: function set(value) {
                this._a = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Color;
}();

// A 2d rectangle defined by x and y position, width and height.
var Rect = /*#__PURE__*/ function() {
    function Rect(x, y, width, height) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (width === void 0) width = 0;
        if (height === void 0) height = 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    var _proto = Rect.prototype;
    /**
   * Set the value of this rectangle.
   * @param x - The x coordinate of the rectangle
   * @param y - The y coordinate of the rectangle
   * @param width - The width of the rectangle, measured from the x position
   * @param height - The height of the rectangle, measured from the y position
   * @returns This rectangle
   */ _proto.set = function set(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
    };
    /**
   * Creates a clone of this rect.
   * @returns A clone of this rect
   */ _proto.clone = function clone() {
        return new Rect(this.x, this.y, this.width, this.height);
    };
    /**
   * Copy this rect from the specified rect.
   * @param source - The specified rect
   * @returns This rect
   */ _proto.copyFrom = function copyFrom(source) {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
        return this;
    };
    return Rect;
}();

/**
 * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
 * @remarks
 * https://graphics.stanford.edu/papers/envmap/envmap.pdf
 * http://www.ppsloan.org/publications/StupidSH36.pdf
 * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
 */ var SphericalHarmonics3 = /*#__PURE__*/ function() {
    function SphericalHarmonics3() {
        /** The coefficients of SphericalHarmonics3. */ this.coefficients = new Float32Array(27);
    }
    var _proto = SphericalHarmonics3.prototype;
    /**
   * Add light to SphericalHarmonics3.
   * @param direction - Light direction
   * @param color - Light color
   * @param deltaSolidAngle - The delta solid angle of the light
   */ _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
        /**
     * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI))
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI))
     * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 8: Math.sqrt(15 / (16 * Math.PI))
     */ color.scale(deltaSolidAngle);
        var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var r = color.r, g = color.g, b = color.b;
        var bv0 = 0.282095; // basis0 = 0.886227
        var bv1 = -0.488603 * y; // basis1 = -0.488603
        var bv2 = 0.488603 * z; // basis2 = 0.488603
        var bv3 = -0.488603 * x; // basis3 = -0.488603
        var bv4 = 1.092548 * (x * y); // basis4 = 1.092548
        var bv5 = -1.092548 * (y * z); // basis5 = -1.092548
        var bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392
        var bv7 = -1.092548 * (x * z); // basis7 = -1.092548
        var bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274
        coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
        coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
        coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
        coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
        coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
        coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
        coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
        coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
        coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
    };
    /**
   * Evaluates the color for the specified direction.
   * @param direction - Specified direction
   * @param out - Out color
   */ _proto.evaluate = function evaluate(direction, out) {
        /**
     * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf
     *
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI)ï¼‰
     * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 8: Math.sqrt(15 / (16 * Math.PI)ï¼‰
     *
     *
     * Convolution kernel
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */ var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var bv0 = 0.886227; // kernel0 * basis0 = 0.886227
        var bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327
        var bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327
        var bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327
        var bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086
        var bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086
        var bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708
        var bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086
        var bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042
        // l0
        var r = coe[0] * bv0;
        var g = coe[1] * bv0;
        var b = coe[2] * bv0;
        // l1
        r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
        g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
        b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
        // l2
        r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
        g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
        b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
        out.set(r, g, b, 1.0);
        return out;
    };
    /**
   * Scale the coefficients.
   * @param s - The amount by which to scale the SphericalHarmonics3
   */ _proto.scale = function scale(s) {
        var src = this.coefficients;
        src[0] *= s, src[1] *= s, src[2] *= s;
        src[3] *= s, src[4] *= s, src[5] *= s;
        src[6] *= s, src[7] *= s, src[8] *= s;
        src[9] *= s, src[10] *= s, src[11] *= s;
        src[12] *= s, src[13] *= s, src[14] *= s;
        src[15] *= s, src[16] *= s, src[17] *= s;
        src[18] *= s, src[19] *= s, src[20] *= s;
        src[21] *= s, src[22] *= s, src[23] *= s;
        src[24] *= s, src[25] *= s, src[26] *= s;
    };
    /**
   * Creates a clone of this SphericalHarmonics3.
   * @returns A clone of this SphericalHarmonics3
   */ _proto.clone = function clone() {
        var sh = new SphericalHarmonics3();
        sh.copyFrom(this);
        return sh;
    };
    /**
   * Copy this SphericalHarmonics3 from the specified SphericalHarmonics3.
   * @param source - The specified SphericalHarmonics3
   * @returns This SphericalHarmonics3
   */ _proto.copyFrom = function copyFrom(source) {
        source.copyToArray(this.coefficients);
        return this;
    };
    /**
   * Copy the value of this spherical harmonics from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var s = this.coefficients;
        s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
        s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
        s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
        s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
        s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
        s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
        s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
        s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
        s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
    };
    /**
   * Copy the value of this spherical harmonics to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var s = this.coefficients;
        out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
        out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
        out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
        out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
        out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
        out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
        out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
        out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
        out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
    };
    return SphericalHarmonics3;
}();

/**
 * The platform (including operating system and hardware) is running on.
 */ var Platform;
(function(Platform) {
    Platform[Platform[/** Android platform. */ "Android"] = 0] = "Android";
    Platform[Platform[/** IPhone platform. */ "IPhone"] = 1] = "IPhone";
    Platform[Platform[/** IPad platform. */ "IPad"] = 2] = "IPad";
    Platform[Platform[/** Mac platform. */ "Mac"] = 3] = "Mac";
    Platform[Platform[/** Unknown platform. */ "Unknown"] = 4] = "Unknown";
})(Platform || (Platform = {}));

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

function _defineProperties$3(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$3(Constructor, staticProps);

    return Constructor;
}

function _set_prototype_of$2(o, p) {
    _set_prototype_of$2 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$2(o, p);
}

function _inherits$2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$2(subClass, superClass);
}

/**
 * Common utility methods for math operations.
 */ var MathUtil = /*#__PURE__*/ function() {
    function MathUtil() {}
    /**
   * Clamps the specified value.
   * @param v - The specified value
   * @param min - The min value
   * @param max - The max value
   * @returns The result of clamping a value between min and max
   */ MathUtil.clamp = function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    };
    /**
   * Checks if a and b are almost equals.
   * The absolute value of the difference between a and b is close to zero.
   * @param a - The left value to compare
   * @param b - The right value to compare
   * @returns True if a almost equal to b, false otherwise
   */ MathUtil.equals = function equals(a, b) {
        return Math.abs(a - b) <= MathUtil.zeroTolerance;
    };
    /**
   * Determines whether the specified v is pow2.
   * @param v - The specified v
   * @returns True if the specified v is pow2, false otherwise
   */ MathUtil.isPowerOf2 = function isPowerOf2(v) {
        return (v & v - 1) === 0;
    };
    /**
   * Modify the specified r from radian to degree.
   * @param r - The specified r
   * @returns The degree value
   */ MathUtil.radianToDegree = function radianToDegree(r) {
        return r * MathUtil.radToDegreeFactor;
    };
    /**
   * Modify the specified d from degree to radian.
   * @param d - The specified d
   * @returns The radian value
   */ MathUtil.degreeToRadian = function degreeToRadian(d) {
        return d * MathUtil.degreeToRadFactor;
    };
    return MathUtil;
}();
(function() {
    /** The value for which all absolute numbers smaller than are considered equal to zero. */ MathUtil.zeroTolerance = 1e-6;
})();
(function() {
    /** The conversion factor that radian to degree. */ MathUtil.radToDegreeFactor = 180 / Math.PI;
})();
(function() {
    /** The conversion factor that degree to radian. */ MathUtil.degreeToRadFactor = Math.PI / 180;
})();

/**
 * Describes a color in the from of RGBA (in order: R, G, B, A).
 */ var Color = /*#__PURE__*/ function() {
    function Color(r, g, b, a) {
        if (r === void 0) r = 1;
        if (g === void 0) g = 1;
        if (b === void 0) b = 1;
        if (a === void 0) a = 1;
        /** @internal */ this._onValueChanged = null;
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
    }
    var _proto = Color.prototype;
    /**
   * Set the value of this color.
   * @param r - The red component of the color
   * @param g - The green component of the color
   * @param b - The blue component of the color
   * @param a - The alpha component of the color
   * @returns This color.
   */ _proto.set = function set(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this color and the specified color.
   * @param color - The specified color
   * @returns The added color
   */ _proto.add = function add(color) {
        this._r += color._r;
        this._g += color._g;
        this._b += color._b;
        this._a += color._a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Scale this color by the given value.
   * @param s - The amount by which to scale the color
   * @returns The scaled color
   */ _proto.scale = function scale(s) {
        this._r *= s;
        this._g *= s;
        this._b *= s;
        this._a *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this color.
   * @returns A clone of this color
   */ _proto.clone = function clone() {
        var ret = new Color(this._r, this._g, this._b, this._a);
        return ret;
    };
    /**
   * Copy from color like object.
   * @param source - Color like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._r = source.r;
        this._g = source.g;
        this._b = source.b;
        this._a = source.a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Modify components (r, g, b) of this color from gamma space to linear space.
   * @param out - The color in linear space
   * @returns The color in linear space
   */ _proto.toLinear = function toLinear(out) {
        out._r = Color.gammaToLinearSpace(this._r);
        out._g = Color.gammaToLinearSpace(this._g);
        out._b = Color.gammaToLinearSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Modify components (r, g, b) of this color from linear space to gamma space.
   * @param out - The color in gamma space
   * @returns The color in gamma space
   */ _proto.toGamma = function toGamma(out) {
        out._r = Color.linearToGammaSpace(this._r);
        out._g = Color.linearToGammaSpace(this._g);
        out._b = Color.linearToGammaSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Gets the brightness.
   * @returns The Hue-Saturation-Brightness (HSB) saturation for this
   */ _proto.getBrightness = function getBrightness() {
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var max = r;
        var min = r;
        if (g > max) max = g;
        if (b > max) max = b;
        if (g < min) min = g;
        if (b < min) min = b;
        return (max + min) / 2;
    };
    /**
   * Serialize this color to a JSON representation.
   * @return A JSON representation of this color
   */ _proto.toJSON = function toJSON() {
        return {
            r: this._r,
            g: this._g,
            b: this._b,
            a: this._a
        };
    };
    /**
   * Modify a value from the gamma space to the linear space.
   * @param value - The value in gamma space
   * @returns The value in linear space
   */ Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value <= 0.04045) return value / 12.92;
        else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);
        else return Math.pow(value, 2.4);
    };
    /**
   * Modify a value from the linear space to the gamma space.
   * @param value - The value in linear space
   * @returns The value in gamma space
   */ Color.linearToGammaSpace = function linearToGammaSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value < 0.0031308) return 12.92 * value;
        else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;
        else return Math.pow(value, 0.41666);
    };
    /**
   * Determines whether the specified colors are equals.
   * @param left - The first color to compare
   * @param right - The second color to compare
   * @returns True if the specified colors are equals, false otherwise
   */ Color.equals = function equals(left, right) {
        return MathUtil.equals(left._r, right._r) && MathUtil.equals(left._g, right._g) && MathUtil.equals(left._b, right._b) && MathUtil.equals(left._a, right._a);
    };
    /**
   * Determines the sum of two colors.
   * @param left - The first color to add
   * @param right - The second color to add
   * @param out - The sum of two colors
   * @returns The added color
   */ Color.add = function add(left, right, out) {
        out._r = left._r + right._r;
        out._g = left._g + right._g;
        out._b = left._b + right._b;
        out._a = left._a + right._a;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Determines the difference between two colors.
   * @param left - The first color to subtract
   * @param right - The second color to subtract
   * @param out - The difference between two colors
   */ Color.subtract = function subtract(left, right, out) {
        out._r = left._r - right._r;
        out._g = left._g - right._g;
        out._b = left._b - right._b;
        out._a = left._a - right._a;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scale a color by the given value.
   * @param left - The color to scale
   * @param s - The amount by which to scale the color
   * @param out - The scaled color
   * @returns The scaled color
   */ Color.scale = function scale(left, s, out) {
        out._r = left._r * s;
        out._g = left._g * s;
        out._b = left._b * s;
        out._a = left._a * s;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Performs a linear interpolation between two color.
   * @param start - The first color
   * @param end - The second color
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two color
   */ Color.lerp = function lerp(start, end, t, out) {
        var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
        out._r = _r + (end._r - _r) * t;
        out._g = _g + (end._g - _g) * t;
        out._b = _b + (end._b - _b) * t;
        out._a = _a + (end._a - _a) * t;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    _create_class$3(Color, [
        {
            key: "r",
            get: /**
   * The red component of the color, 0~1.
   */ function get() {
                return this._r;
            },
            set: function set(value) {
                this._r = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "g",
            get: /**
   * The green component of the color, 0~1.
   */ function get() {
                return this._g;
            },
            set: function set(value) {
                this._g = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "b",
            get: /**
   * The blue component of the color, 0~1.
   */ function get() {
                return this._b;
            },
            set: function set(value) {
                this._b = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "a",
            get: /**
   * The alpha component of the color, 0~1.
   */ function get() {
                return this._a;
            },
            set: function set(value) {
                this._a = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Color;
}();

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate$1(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function _instanceof$2(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * Clone mode.
 */ var CloneMode;
(function(CloneMode) {
    CloneMode[CloneMode[/** Ignore clone. */ "Ignore"] = 0] = "Ignore";
    CloneMode[CloneMode[/** Assignment clone. */ "Assignment"] = 1] = "Assignment";
    CloneMode[CloneMode[/** Shallow clone. */ "Shallow"] = 2] = "Shallow";
    CloneMode[CloneMode[/** Deep clone. */ "Deep"] = 3] = "Deep";
})(CloneMode || (CloneMode = {}));

/**
 * Property decorator, ignore the property when cloning.
 */ function ignoreClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Ignore);
}
/**
 * Property decorator, assign value to the property when cloning.
 *
 * @remarks
 * If it's a primitive type, the value will be copied.
 * If it's a class type, the reference will be copied.
 */ function assignmentClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Assignment);
}
/**
 * Property decorator, shallow clone the property when cloning.
 * After cloning, it will keep its own reference independent, and use the method of assignment to clone all its internal properties.
 * if the internal property is a primitive type, the value will be copied, if the internal property is a reference type, its reference address will be copied.ã€‚
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 */ function shallowClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Shallow);
}
/**
 * Property decorator, deep clone the property when cloning.
 * After cloning, it will maintain its own reference independence, and all its internal deep properties will remain completely independent.
 *
 * @remarks
 * Applicable to Object, Array, TypedArray and Class types.
 * If Class is encountered during the deep cloning process, the custom cloning function of the object will be called first.
 * Custom cloning requires the object to implement the IClone interface.
 */ function deepClone(target, propertyKey) {
    CloneManager.registerCloneMode(target, propertyKey, CloneMode.Deep);
}
/**
 * @internal
 * Clone manager.
 */ var CloneManager = /*#__PURE__*/ function() {
    function CloneManager() {}
    /**
   * Register clone mode.
   * @param target - Clone target
   * @param propertyKey - Clone property name
   * @param mode - Clone mode
   */ CloneManager.registerCloneMode = function registerCloneMode(target, propertyKey, mode) {
        var targetMap = CloneManager._subCloneModeMap.get(target.constructor);
        if (!targetMap) {
            targetMap = Object.create(null);
            CloneManager._subCloneModeMap.set(target.constructor, targetMap);
        }
        targetMap[propertyKey] = mode;
    };
    /**
   * Get the clone mode according to the prototype chain.
   */ CloneManager.getCloneMode = function getCloneMode(type) {
        var cloneModes = CloneManager._cloneModeMap.get(type);
        if (!cloneModes) {
            cloneModes = Object.create(null);
            CloneManager._cloneModeMap.set(type, cloneModes);
            var objectType = CloneManager._objectType;
            var cloneModeMap = CloneManager._subCloneModeMap;
            while(type !== objectType){
                var subCloneModes = cloneModeMap.get(type);
                if (subCloneModes) {
                    Object.assign(cloneModes, subCloneModes);
                }
                type = Object.getPrototypeOf(type);
            }
        }
        return cloneModes;
    };
    /**
   * Deep clone the object.
   * @param source - Clone source
   * @param target - Clone target
   */ CloneManager.deepCloneObject = function deepCloneObject(source, target) {
        var type = source.constructor;
        switch(type){
            case Uint8Array:
            case Uint16Array:
            case Uint32Array:
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case Float32Array:
            case Float64Array:
                // Type array clone.
                target.set(source);
                break;
            case Array:
                // Array clone.
                for(var i = 0, n = source.length; i < n; i++){
                    CloneManager._deepCloneObjectItem(source, target, i);
                }
                break;
            default:
                var customSource = source;
                if (customSource.clone && customSource.cloneTo) {
                    // Custom clone.
                    customSource.cloneTo(target);
                } else {
                    // Object or other class not implements custom clone.
                    var keys = Object.keys(source);
                    for(var i1 = 0, n1 = keys.length; i1 < n1; i1++){
                        CloneManager._deepCloneObjectItem(source, target, keys[i1]);
                    }
                }
        }
    };
    CloneManager._deepCloneObjectItem = function _deepCloneObjectItem(source, target, k) {
        var sourceItem = source[k];
        if (_instanceof$2(sourceItem, Object)) {
            var itemType = sourceItem.constructor;
            switch(itemType){
                case Uint8Array:
                case Uint16Array:
                case Uint32Array:
                case Int8Array:
                case Int16Array:
                case Int32Array:
                case Float32Array:
                case Float64Array:
                    // Type array clone.
                    var sourceTypeArrayItem = sourceItem;
                    var targetTypeArrayItem = target[k];
                    if (targetTypeArrayItem == null) {
                        target[k] = sourceTypeArrayItem.slice();
                    } else {
                        targetTypeArrayItem.set(sourceTypeArrayItem);
                    }
                    break;
                case Array:
                    // Array clone.
                    var sourceArrayItem = sourceItem;
                    var targetArrayItem = target[k];
                    if (targetArrayItem == null) {
                        target[k] = new Array(sourceArrayItem.length);
                    } else {
                        targetArrayItem.length = sourceArrayItem.length;
                    }
                    CloneManager.deepCloneObject(sourceArrayItem, targetArrayItem);
                    break;
                default:
                    if (sourceItem.clone && sourceItem.cloneTo) {
                        // Custom clone.
                        var sourceCustomItem = sourceItem;
                        var targetCustomItem = target[k];
                        if (targetCustomItem) {
                            sourceCustomItem.cloneTo(targetCustomItem);
                        } else {
                            target[k] = sourceCustomItem.clone();
                        }
                    } else {
                        // Object or other class not implements custom clone.
                        var targetItem = target[k];
                        targetItem == null && (target[k] = targetItem = new sourceItem.constructor());
                        CloneManager.deepCloneObject(sourceItem, targetItem);
                        break;
                    }
            }
        } else {
            // Null or undefined and primitive type.
            target[k] = sourceItem;
        }
    };
    return CloneManager;
}();
(function() {
    /** @internal */ CloneManager._subCloneModeMap = new Map();
})();
(function() {
    /** @internal */ CloneManager._cloneModeMap = new Map();
})();
(function() {
    CloneManager._objectType = Object.getPrototypeOf(Object);
})();

/**
 * EngineObject.
 */ var EngineObject = /*#__PURE__*/ function() {
    function EngineObject(engine) {
        /** Engine unique id. */ this.instanceId = ++EngineObject._instanceIdCounter;
        this._destroyed = false;
        this._engine = engine;
    }
    var _proto = EngineObject.prototype;
    /**
   * Destroy self.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) return;
        this._onDestroy();
        this._destroyed = true;
    };
    _proto._onDestroy = function _onDestroy() {
        var resourceManager = this._engine.resourceManager;
        resourceManager._deleteAsset(this);
        resourceManager._deleteContentRestorer(this);
    };
    _create_class$3(EngineObject, [
        {
            key: "engine",
            get: /**
   * Get the engine which the object belongs.
   */ function get() {
                return this._engine;
            }
        },
        {
            key: "destroyed",
            get: /**
   * Whether it has been destroyed.
   */ function get() {
                return this._destroyed;
            }
        }
    ]);
    return EngineObject;
}();
(function() {
    EngineObject._instanceIdCounter = 0;
})();
__decorate$1([
    ignoreClone
], EngineObject.prototype, "instanceId", void 0);
__decorate$1([
    ignoreClone
], EngineObject.prototype, "_engine", void 0);

/**
 * The base class of assets, with reference counting capability.
 */ var ReferResource = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(ReferResource, EngineObject);
    function ReferResource(engine) {
        var _this;
        _this = EngineObject.call(this, engine) || this;
        /** Whether to ignore the garbage collection check, if it is true, it will not be affected by ResourceManager.gc(). */ _this.isGCIgnored = false;
        _this._refCount = 0;
        engine.resourceManager._addReferResource(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = ReferResource.prototype;
    /**
   * Destroy self.
   * @param force - Whether to force the destruction, if it is false, refCount = 0 can be released successfully.
   * @returns Whether the release was successful.
   */ _proto.destroy = function destroy(force) {
        if (force === void 0) force = false;
        if (!force && this._refCount !== 0) {
            return false;
        }
        EngineObject.prototype.destroy.call(this);
        return true;
    };
    /**
   * @internal
   */ _proto._getReferCount = function _getReferCount() {
        return this._refCount;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        this._refCount += value;
    };
    /**
   * @internal
   */ _proto._addToResourceManager = function _addToResourceManager(path) {
        this._engine.resourceManager._addAsset(path, this);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        this._engine.resourceManager._deleteReferResource(this);
        var refCount = this._getReferCount();
        if (refCount > 0) {
            this._addReferCount(-refCount);
        }
    };
    _create_class$3(ReferResource, [
        {
            key: "refCount",
            get: /**
   * Counted by valid references.
   */ function get() {
                return this._refCount;
            }
        }
    ]);
    return ReferResource;
}(EngineObject);

/**
 * ContentRestorer is a base class for all content restore info classes.
 */ var ContentRestorer = function ContentRestorer(resource) {
    this.resource = resource;
};

/**
 * Render buffer depth format enumeration.
 */ var RenderBufferDepthFormat;
(function(RenderBufferDepthFormat) {
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Render to depth buffer,engine will automatically select the supported precision. */ "Depth"] = 0] = "Depth";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Render to depth stencil buffer, engine will automatically select the supported precision. */ "DepthStencil"] = 1] = "DepthStencil";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Render to stencil buffer. */ "Stencil"] = 2] = "Stencil";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Force 16-bit depth buffer. */ "Depth16"] = 3] = "Depth16";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Force 24-bit depth buffer. */ "Depth24"] = 4] = "Depth24";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Force 32-bit depth buffer. */ "Depth32"] = 5] = "Depth32";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Force 16-bit depth + 8-bit stencil buffer. */ "Depth24Stencil8"] = 6] = "Depth24Stencil8";
    RenderBufferDepthFormat[RenderBufferDepthFormat[/** Force 32-bit depth + 8-bit stencil buffer. */ "Depth32Stencil8"] = 7] = "Depth32Stencil8";
})(RenderBufferDepthFormat || (RenderBufferDepthFormat = {}));

/**
 * Define the face of the cube texture.
 */ var TextureCubeFace;
(function(TextureCubeFace) {
    TextureCubeFace[TextureCubeFace[/** Positive X face for a cube-mapped texture. */ "PositiveX"] = 0] = "PositiveX";
    TextureCubeFace[TextureCubeFace[/** Negative X face for a cube-mapped texture. */ "NegativeX"] = 1] = "NegativeX";
    TextureCubeFace[TextureCubeFace[/** Positive Y face for a cube-mapped texture. */ "PositiveY"] = 2] = "PositiveY";
    TextureCubeFace[TextureCubeFace[/** Negative Y face for a cube-mapped texture. */ "NegativeY"] = 3] = "NegativeY";
    TextureCubeFace[TextureCubeFace[/** Positive Z face for a cube-mapped texture. */ "PositiveZ"] = 4] = "PositiveZ";
    TextureCubeFace[TextureCubeFace[/** Negative Z face for a cube-mapped texture. */ "NegativeZ"] = 5] = "NegativeZ";
})(TextureCubeFace || (TextureCubeFace = {}));

/**
 * Define the compare mode of depth texture.
 */ var TextureDepthCompareFunction;
(function(TextureDepthCompareFunction) {
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** never pass. */ "Never"] = 0] = "Never";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value is less than the sample value. */ "Less"] = 1] = "Less";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value equals the sample value. */ "Equal"] = 2] = "Equal";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value is less than or equal to the sample value. */ "LessEqual"] = 3] = "LessEqual";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value is greater than the sample value. */ "Greater"] = 4] = "Greater";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value is not equal to the sample value. */ "NotEqual"] = 5] = "NotEqual";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** pass if the compare value is greater than or equal to the sample value. */ "GreaterEqual"] = 6] = "GreaterEqual";
    TextureDepthCompareFunction[TextureDepthCompareFunction[/** always pass. */ "Always"] = 7] = "Always";
})(TextureDepthCompareFunction || (TextureDepthCompareFunction = {}));

/**
 * The filter mode of the texture.
 */ var TextureFilterMode;
(function(TextureFilterMode) {
    TextureFilterMode[TextureFilterMode[/** Point filtering. */ "Point"] = 0] = "Point";
    TextureFilterMode[TextureFilterMode[/** Bilinear filtering. */ "Bilinear"] = 1] = "Bilinear";
    TextureFilterMode[TextureFilterMode[/** Trilinear filtering. */ "Trilinear"] = 2] = "Trilinear";
})(TextureFilterMode || (TextureFilterMode = {}));

/**
 * Texture format enumeration.
 */ var TextureFormat;
(function(TextureFormat) {
    TextureFormat[TextureFormat[/** RGB format,8 bits per channel. */ "R8G8B8"] = 0] = "R8G8B8";
    TextureFormat[TextureFormat[/** RGBA format,8 bits per channel. */ "R8G8B8A8"] = 1] = "R8G8B8A8";
    TextureFormat[TextureFormat[/** RGBA format,4 bits per channel. */ "R4G4B4A4"] = 2] = "R4G4B4A4";
    TextureFormat[TextureFormat[/** RGBA format,5 bits in R channel,5 bits in G channel,5 bits in B channel, 1 bit in A channel. */ "R5G5B5A1"] = 3] = "R5G5B5A1";
    TextureFormat[TextureFormat[/** RGB format,5 bits in R channel,6 bits in G channel,5 bits in B channel. */ "R5G6B5"] = 4] = "R5G6B5";
    TextureFormat[TextureFormat[/** Transparent format,8 bits. */ "Alpha8"] = 5] = "Alpha8";
    TextureFormat[TextureFormat[/** Luminance/alpha in RGB channel, alpha in A channel. */ "LuminanceAlpha"] = 6] = "LuminanceAlpha";
    TextureFormat[TextureFormat[/** RGBA format,16 bits per channel. */ "R16G16B16A16"] = 7] = "R16G16B16A16";
    TextureFormat[TextureFormat[/** RGBA format,32 bits per channel. */ "R32G32B32A32"] = 8] = "R32G32B32A32";
    TextureFormat[TextureFormat[/** RGB compressed formatã€‚*/ "DXT1"] = 9] = "DXT1";
    TextureFormat[TextureFormat[/** RGBA compressed formatã€‚*/ "DXT5"] = 10] = "DXT5";
    TextureFormat[TextureFormat[/** RGB compressed format,4 bits per pixelã€‚*/ "ETC1_RGB"] = 11] = "ETC1_RGB";
    TextureFormat[TextureFormat[/** RGB compressed format,4 bits per pixelã€‚*/ "ETC2_RGB"] = 12] = "ETC2_RGB";
    TextureFormat[TextureFormat[/** RGBA compressed format,5 bits per pixel,4 bit in RGB, 1 bit in A. */ "ETC2_RGBA5"] = 13] = "ETC2_RGBA5";
    TextureFormat[TextureFormat[/** RGB compressed format,8 bits per pixel. */ "ETC2_RGBA8"] = 14] = "ETC2_RGBA8";
    TextureFormat[TextureFormat[/** RGB compressed format,2 bits per pixel. */ "PVRTC_RGB2"] = 15] = "PVRTC_RGB2";
    TextureFormat[TextureFormat[/** RGBA compressed format,2 bits per pixel. */ "PVRTC_RGBA2"] = 16] = "PVRTC_RGBA2";
    TextureFormat[TextureFormat[/** RGB compressed format,4 bits per pixel. */ "PVRTC_RGB4"] = 17] = "PVRTC_RGB4";
    TextureFormat[TextureFormat[/** RGBA compressed format,4 bits per pixel. */ "PVRTC_RGBA4"] = 18] = "PVRTC_RGBA4";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 4x4 pixel block. */ "ASTC_4x4"] = 19] = "ASTC_4x4";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 5x5 pixel block. */ "ASTC_5x5"] = 20] = "ASTC_5x5";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 6x6 pixel block. */ "ASTC_6x6"] = 21] = "ASTC_6x6";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 8x8 pixel block. */ "ASTC_8x8"] = 22] = "ASTC_8x8";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 10x10 pixel block. */ "ASTC_10x10"] = 23] = "ASTC_10x10";
    TextureFormat[TextureFormat[/** RGB(A) compressed format,128 bits per 12x12 pixel block. */ "ASTC_12x12"] = 24] = "ASTC_12x12";
    TextureFormat[TextureFormat[/** Automatic depth format,engine will automatically select the supported precision. */ "Depth"] = 25] = "Depth";
    TextureFormat[TextureFormat[/** Automatic depth setncil format, engine will automatically select the supported precision. */ "DepthStencil"] = 26] = "DepthStencil";
    TextureFormat[TextureFormat[/** 16-bit depth format. */ "Depth16"] = 27] = "Depth16";
    TextureFormat[TextureFormat[/** 24-bit depth format. */ "Depth24"] = 28] = "Depth24";
    TextureFormat[TextureFormat[/** 32-bit depth format. */ "Depth32"] = 29] = "Depth32";
    TextureFormat[TextureFormat[/** 16-bit depth + 8-bit stencil format. */ "Depth24Stencil8"] = 30] = "Depth24Stencil8";
    TextureFormat[TextureFormat[/** 32-bit depth + 8-bit stencil format. */ "Depth32Stencil8"] = 31] = "Depth32Stencil8";
})(TextureFormat || (TextureFormat = {}));

/**
 * Texture usage.
 */ var TextureUsage;
(function(TextureUsage) {
    TextureUsage[TextureUsage[/** The content of the texture is intended to be specified once.  */ "Static"] = 0] = "Static";
    TextureUsage[TextureUsage[/** The content of the texture is intended to be updated frequently, with better performance. */ "Dynamic"] = 1] = "Dynamic";
})(TextureUsage || (TextureUsage = {}));

/**
 * Wrapping mode of the texture.
 */ var TextureWrapMode$1;
(function(TextureWrapMode) {
    TextureWrapMode[TextureWrapMode[/** Clamping mode. use the color of edge pixels beyond the texture boundary. */ "Clamp"] = 0] = "Clamp";
    TextureWrapMode[TextureWrapMode[/** Repeating mode. tiling will be repeated if it exceeds the texture boundary. */ "Repeat"] = 1] = "Repeat";
    TextureWrapMode[TextureWrapMode[/** Mirror repeat mode. tiling will be mirrored and repeated if it exceeds the texture boundary. */ "Mirror"] = 2] = "Mirror";
})(TextureWrapMode$1 || (TextureWrapMode$1 = {}));

var GraphicsResource = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(GraphicsResource, ReferResource);
    function GraphicsResource(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        engine.resourceManager._addGraphicResource(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = GraphicsResource.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this.engine.resourceManager._deleteGraphicResource(this);
    };
    return GraphicsResource;
}(ReferResource);

/**
 * @class
 * @private
 */ /* tslint:disable */ var noop = function(message) {
    for(var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        optionalParams[_key - 1] = arguments[_key];
    }
};
var debug = console.log.bind(console);
var info = console.info.bind(console);
var warn = console.warn.bind(console);
var error = console.error.bind(console);
var Logger = {
    debug: noop,
    info: noop,
    warn: noop,
    error: noop,
    isEnabled: false,
    /** Turn on log */ enable: function enable() {
        this.debug = debug;
        this.info = info;
        this.warn = warn;
        this.error = error;
        this.isEnabled = true;
    },
    /** Turn off log */ disable: function disable() {
        this.debug = noop;
        this.info = noop;
        this.warn = noop;
        this.error = noop;
        this.isEnabled = false;
    }
};

/**
 * The base class of texture, contains some common functions of texture-related classes.
 */ var Texture = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Texture, GraphicsResource);
    function Texture() {
        var _this;
        _this = GraphicsResource.apply(this, arguments) || this;
        /** @internal */ _this._isDepthTexture = false;
        _this._anisoLevel = 1;
        _this._useDepthCompareMode = false;
        return _this;
    }
    var _proto = Texture.prototype;
    /**
   * Generate multi-level textures based on the 0th level data.
   */ _proto.generateMipmaps = function generateMipmaps() {
        if (!this._mipmap) return;
        this._platformTexture.generateMipmaps();
    };
    /**
   * @internal
   */ _proto._setUseDepthCompareMode = function _setUseDepthCompareMode(value) {
        if (this._useDepthCompareMode !== value) {
            this._platformTexture.setUseDepthCompareMode(value);
            this._useDepthCompareMode = value;
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        var platformTexture = this._platformTexture;
        platformTexture.wrapModeU = this._wrapModeU;
        platformTexture.wrapModeV = this._wrapModeV;
        platformTexture.filterMode = this._filterMode;
        platformTexture.anisoLevel = this._anisoLevel;
        platformTexture.depthCompareFunction = this._depthCompareFunction;
        platformTexture.setUseDepthCompareMode(this._useDepthCompareMode);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformTexture.destroy();
        this._platformTexture = null;
    };
    /**
   * Get the maximum mip level of the corresponding size:rounding down.
   * @remarks http://download.nvidia.com/developer/Papers/2005/NP2_Mipmapping/NP2_Mipmap_Creation.pdf
   */ _proto._getMaxMiplevel = function _getMaxMiplevel(size) {
        return Math.floor(Math.log2(size));
    };
    _proto._getMipmapCount = function _getMipmapCount() {
        return this._mipmap ? Math.floor(Math.log2(Math.max(this._width, this._height))) + 1 : 1;
    };
    _create_class$3(Texture, [
        {
            key: "format",
            get: /**
   * Texture format.
   */ function get() {
                return this._format;
            }
        },
        {
            key: "width",
            get: /**
   * The width of the texture.
   */ function get() {
                return this._width;
            }
        },
        {
            key: "height",
            get: /**
   * The height of the texture.
   */ function get() {
                return this._height;
            }
        },
        {
            key: "usage",
            get: /**
   * The usage of the texture.
   */ function get() {
                return this._usage;
            }
        },
        {
            key: "wrapModeU",
            get: /**
   * Wrapping mode for texture coordinate S.
   */ function get() {
                return this._wrapModeU;
            },
            set: function set(value) {
                if (value === this._wrapModeU) return;
                this._wrapModeU = value;
                this._platformTexture.wrapModeU = value;
            }
        },
        {
            key: "wrapModeV",
            get: /**
   * Wrapping mode for texture coordinate T.
   */ function get() {
                return this._wrapModeV;
            },
            set: function set(value) {
                if (value === this._wrapModeV) return;
                this._wrapModeV = value;
                this._platformTexture.wrapModeV = value;
            }
        },
        {
            key: "mipmapCount",
            get: /**
   * Texture mipmapping count.
   */ function get() {
                return this._mipmapCount;
            }
        },
        {
            key: "filterMode",
            get: /**
   * Filter mode for texture.
   */ function get() {
                return this._filterMode;
            },
            set: function set(value) {
                if (value === this._filterMode) return;
                this._filterMode = value;
                this._platformTexture.filterMode = value;
            }
        },
        {
            key: "anisoLevel",
            get: /**
   * Anisotropic level for texture.
   */ function get() {
                return this._anisoLevel;
            },
            set: function set(value) {
                var max = this._engine._hardwareRenderer.capability.maxAnisoLevel;
                if (value > max) {
                    Logger.warn("anisoLevel:" + value + ", exceeds the limit and is automatically downgraded to:" + max);
                    value = max;
                }
                if (value < 1) {
                    Logger.warn("anisoLevel:" + value + ", must be greater than 0, and is automatically downgraded to 1");
                    value = 1;
                }
                if (value === this._anisoLevel) return;
                this._anisoLevel = value;
                this._platformTexture.anisoLevel = value;
            }
        },
        {
            key: "depthCompareFunction",
            get: /**
   * Filter mode when texture as depth Texture.
   * @remarks Only depth-related formats take effect.
   */ function get() {
                return this._depthCompareFunction;
            },
            set: function set(value) {
                if (!this._engine._hardwareRenderer._isWebGL2) {
                    console.warn("depthCompareFunction only support WebGL2");
                    return;
                }
                if (value !== this._depthCompareFunction) {
                    this._depthCompareFunction = value;
                    this._platformTexture.depthCompareFunction = value;
                }
            }
        }
    ]);
    return Texture;
}(GraphicsResource);

/**
 * The render target used for off-screen rendering.
 */ var RenderTarget = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(RenderTarget, GraphicsResource);
    function RenderTarget(engine, width, height, renderTexture, depth, antiAliasing) {
        if (depth === void 0) depth = RenderBufferDepthFormat.Depth;
        if (antiAliasing === void 0) antiAliasing = 1;
        var _this;
        _this = GraphicsResource.call(this, engine) || this;
        _this._autoGenerateMipmaps = true;
        _this._width = width;
        _this._height = height;
        _this._antiAliasing = antiAliasing;
        _this._depth = depth;
        if (renderTexture) {
            var colorTextures = _instanceof$2(renderTexture, Array) ? renderTexture.slice() : [
                renderTexture
            ];
            for(var i = 0, n = colorTextures.length; i < n; i++){
                var colorTexture = colorTextures[i];
                if (colorTexture._isDepthTexture) {
                    throw "Render texture can't use depth format.";
                }
                colorTexture._addReferCount(1);
            }
            _this._colorTextures = colorTextures;
        } else {
            _this._colorTextures = [];
        }
        if (_instanceof$2(depth, Texture)) {
            if (!depth._isDepthTexture) {
                throw "Depth texture must use depth format.";
            }
            _this._depthTexture = depth;
            _this._depthTexture._addReferCount(1);
        }
        _this._platformRenderTarget = engine._hardwareRenderer.createPlatformRenderTarget(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = RenderTarget.prototype;
    /**
   *
   * Get the render color texture by index.
   * @param index
   */ _proto.getColorTexture = function getColorTexture(index) {
        if (index === void 0) index = 0;
        return this._colorTextures[index];
    };
    /**
   * Generate the mipmap of each attachment texture of the renderTarget according to the configuration.
   */ _proto.generateMipmaps = function generateMipmaps() {
        if (this._autoGenerateMipmaps) {
            var colorTextures = this._colorTextures;
            for(var i = 0, n = colorTextures.length; i < n; i++){
                var colorTexture = colorTextures[i];
                colorTexture.generateMipmaps();
            }
            this._depthTexture && this._depthTexture.generateMipmaps();
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        var _this__depthTexture;
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformRenderTarget.destroy();
        var _this = this, colorTextures = _this._colorTextures;
        for(var i = 0, n = colorTextures.length; i < n; i++){
            colorTextures[i]._addReferCount(-1);
        }
        colorTextures.length = 0;
        (_this__depthTexture = this._depthTexture) == null ? void 0 : _this__depthTexture._addReferCount(-1);
        this._depthTexture = null;
        this._depth = null;
    };
    /**
   * @internal
   */ _proto._setRenderTargetInfo = function _setRenderTargetInfo(faceIndex, mipLevel) {
        this._platformRenderTarget.setRenderTargetInfo(faceIndex, mipLevel);
    };
    /**
   * @internal
   */ _proto._blitRenderTarget = function _blitRenderTarget() {
        this._platformRenderTarget.blitRenderTarget();
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformRenderTarget = this._engine._hardwareRenderer.createPlatformRenderTarget(this);
    };
    _create_class$3(RenderTarget, [
        {
            key: "autoGenerateMipmaps",
            get: /**
   * Whether to automatically generate multi-level textures.
   */ function get() {
                return this._autoGenerateMipmaps;
            },
            set: function set(value) {
                this._autoGenerateMipmaps = value;
            }
        },
        {
            key: "width",
            get: /**
   * Render target width.
   */ function get() {
                return this._width;
            }
        },
        {
            key: "height",
            get: /**
   * Render target height.
   */ function get() {
                return this._height;
            }
        },
        {
            key: "colorTextureCount",
            get: /**
   * Render color texture count.
   */ function get() {
                return this._colorTextures.length;
            }
        },
        {
            key: "depthTexture",
            get: /**
   * Depth texture.
   */ function get() {
                return this._depthTexture;
            }
        },
        {
            key: "antiAliasing",
            get: /**
   * Anti-aliasing level.
   * @remarks If the anti-aliasing level set is greater than the maximum level supported by the hardware, the maximum level of the hardware will be used.
   */ function get() {
                return this._antiAliasing;
            }
        }
    ]);
    return RenderTarget;
}(GraphicsResource);

/**
 * Two-dimensional texture.
 */ var Texture2D = /*#__PURE__*/ function(Texture) {
    _inherits$2(Texture2D, Texture);
    function Texture2D(engine, width, height, format, mipmap, usage) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        if (usage === void 0) usage = TextureUsage.Static;
        var _this;
        _this = Texture.call(this, engine) || this;
        _this._mipmap = mipmap;
        _this._width = width;
        _this._height = height;
        _this._usage = usage;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._isDepthTexture = format == TextureFormat.Depth || format == TextureFormat.DepthStencil || format == TextureFormat.Depth16 || format == TextureFormat.Depth24 || format == TextureFormat.Depth32 || format == TextureFormat.Depth24Stencil8 || format == TextureFormat.Depth32Stencil8;
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2D(_assert_this_initialized(_this));
        _this.filterMode = TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
        return _this;
    }
    var _proto = Texture2D.prototype;
    /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */ _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(colorBuffer, mipLevel, x, y, width, height);
    };
    /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
    };
    _proto.getPixelBuffer = function getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
            this._platformTexture.getPixelBuffer(0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
            this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2D(this);
        Texture.prototype._rebuild.call(this);
    };
    return Texture2D;
}(Texture);

/**
 * Two-dimensional texture array.
 */ var Texture2DArray = /*#__PURE__*/ function(Texture) {
    _inherits$2(Texture2DArray, Texture);
    function Texture2DArray(engine, width, height, length, format, mipmap) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        var _this;
        _this = Texture.call(this, engine) || this;
        _this._mipmap = mipmap;
        _this._width = width;
        _this._height = height;
        _this._length = length;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._platformTexture = engine._hardwareRenderer.createPlatformTexture2DArray(_assert_this_initialized(_this));
        _this.filterMode = TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Repeat;
        return _this;
    }
    var _proto = Texture2DArray.prototype;
    /**
   * Setting pixels data through color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks If it is the WebGL1.0 platform and the texture format is compressed, the first upload must be filled with textures.
   * @param offsetIndex - The texture array element offset index
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Data width. if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height. if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   * @param length - Data length. if it's empty, length is the length of Texture2DArray.length
   */ _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length);
    };
    /**
   * Setting pixels data through TexImageSource, designated area and texture mipmapping level.
   * @param elementIndex - The texture array element index
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
    };
    _proto.getPixelBuffer = function getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 1) {
            this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(elementIndex, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 5) {
            this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(elementIndex, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTexture2DArray(this);
        Texture.prototype._rebuild.call(this);
    };
    _create_class$3(Texture2DArray, [
        {
            key: "length",
            get: /**
   * The length of the texture.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return Texture2DArray;
}(Texture);

/**
 * Cube texture.
 */ var TextureCube = /*#__PURE__*/ function(Texture) {
    _inherits$2(TextureCube, Texture);
    function TextureCube(engine, size, format, mipmap) {
        if (format === void 0) format = TextureFormat.R8G8B8A8;
        if (mipmap === void 0) mipmap = true;
        var _this;
        _this = Texture.call(this, engine) || this;
        _this._mipmap = mipmap;
        _this._width = size;
        _this._height = size;
        _this._format = format;
        _this._mipmapCount = _this._getMipmapCount();
        _this._platformTexture = engine._hardwareRenderer.createPlatformTextureCube(_assert_this_initialized(_this));
        _this.filterMode = TextureFilterMode.Bilinear;
        _this.wrapModeU = _this.wrapModeV = TextureWrapMode$1.Clamp;
        return _this;
    }
    var _proto = TextureCube.prototype;
    /**
   * Setting pixels data through cube face,color buffer data, designated area and texture mipmapping level,it's also applicable to compressed formats.
   * @remarks When compressed texture is in WebGL1, the texture must be filled first before writing the sub-region
   * @param face - Cube face
   * @param colorBuffer - Color buffer data
   * @param mipLevel - Texture mipmapping level
   * @param x - X coordinate of area start
   * @param y -  Y coordinate of area start
   * @param width - Data width.if it's empty, width is the width corresponding to mipLevel minus x , width corresponding to mipLevel is Math.max(1, this.width >> mipLevel)
   * @param height - Data height.if it's empty, height is the height corresponding to mipLevel minus y , height corresponding to mipLevel is Math.max(1, this.height >> mipLevel)
   */ _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height);
    };
    /**
   * Setting pixels data through cube face, TexImageSource, designated area and texture mipmapping level.
   * @param face - Cube face
   * @param imageSource - The source of texture
   * @param mipLevel - Texture mipmapping level
   * @param flipY - Whether to flip the Y axis
   * @param premultiplyAlpha - Whether to premultiply the transparent channel
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   */ _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        if (mipLevel === void 0) mipLevel = 0;
        if (flipY === void 0) flipY = false;
        if (premultiplyAlpha === void 0) premultiplyAlpha = false;
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        this._platformTexture.setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y);
    };
    _proto.getPixelBuffer = function getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out) {
        var argsLength = arguments.length;
        if (argsLength === 2) {
            this._platformTexture.getPixelBuffer(face, 0, 0, this._width, this._height, 0, xOrMipLevelOrOut);
        } else if (argsLength === 3) {
            this._platformTexture.getPixelBuffer(face, 0, 0, this._width >> xOrMipLevelOrOut, this._height >> xOrMipLevelOrOut, xOrMipLevelOrOut, yOrMipLevel);
        } else if (argsLength === 6) {
            this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, 0, mipLevelOrOut);
        } else if (argsLength === 7) {
            this._platformTexture.getPixelBuffer(face, xOrMipLevelOrOut, yOrMipLevel, width, height, mipLevelOrOut, out);
        }
    };
    /**
   * @internal
   */ _proto._rebuild = function _rebuild() {
        this._platformTexture = this._engine._hardwareRenderer.createPlatformTextureCube(this);
        Texture.prototype._rebuild.call(this);
    };
    return TextureCube;
}(Texture);

/**
 * @internal
 */ var FontAtlas = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(FontAtlas, ReferResource);
    function FontAtlas(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this._charInfoMap = {};
        _this._space = 1;
        _this._curX = 1;
        _this._curY = 1;
        _this._nextY = 1;
        return _this;
    }
    var _proto = FontAtlas.prototype;
    _proto.uploadCharTexture = function uploadCharTexture(charInfo) {
        var width = charInfo.w, height = charInfo.h, data = charInfo.data;
        var _this = this, space = _this._space, texture = _this.texture;
        var textureSize = texture.width;
        var offsetWidth = width + space;
        var offsetHeight = height + space;
        if (1 + offsetWidth >= textureSize || 1 + offsetHeight >= textureSize) {
            throw Error("The char fontSize is too large.");
        }
        var endX = this._curX + offsetWidth;
        if (endX >= textureSize) {
            this._curX = space;
            this._curY = this._nextY + space;
        }
        var endY = this._curY + offsetHeight;
        if (endY > this._nextY) {
            this._nextY = endY;
        }
        if (endY >= textureSize) {
            return false;
        }
        if (width > 0 && height > 0 && data) {
            charInfo.bufferOffset = new Vector2(this._curX, this._curY);
            texture.setPixelBuffer(data, 0, this._curX, this._curY, width, height);
            texture.generateMipmaps();
        }
        var textureSizeReciprocal = 1.0 / textureSize;
        var x = this._curX;
        var y = this._curY;
        var w = width;
        var h = height;
        var u0 = x * textureSizeReciprocal;
        var u1 = (x + w) * textureSizeReciprocal;
        var v0 = y * textureSizeReciprocal;
        var v1 = (y + h) * textureSizeReciprocal;
        charInfo.x = x;
        charInfo.y = y;
        var uvs = charInfo.uvs;
        uvs[0].set(u0, v0);
        uvs[1].set(u1, v0);
        uvs[2].set(u1, v1);
        uvs[3].set(u0, v1);
        this._curX += offsetWidth + space;
        return true;
    };
    _proto.addCharInfo = function addCharInfo(char, charInfo) {
        this._charInfoMap[char.charCodeAt(0)] = charInfo;
    };
    _proto.getCharInfo = function getCharInfo(char) {
        return this._charInfoMap[char.charCodeAt(0)];
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this.texture.destroy();
        this.texture = null;
        this._charInfoMap = {};
    };
    return FontAtlas;
}(ReferResource);

/**
 * The style of the font.
 */ var FontStyle;
(function(FontStyle) {
    FontStyle[FontStyle[/** Set font without style */ "None"] = 0x0] = "None";
    FontStyle[FontStyle[/** Set font bold */ "Bold"] = 0x1] = "Bold";
    FontStyle[FontStyle[/** Set font italic */ "Italic"] = 0x2] = "Italic";
})(FontStyle || (FontStyle = {}));

/**
 * The way to handle the situation where wrapped text is too tall to fit in the height.
 */ var OverflowMode;
(function(OverflowMode) {
    OverflowMode[OverflowMode[/** Overflow when the text is too tall */ "Overflow"] = 0] = "Overflow";
    OverflowMode[OverflowMode[/** Truncate with height when the text is too tall */ "Truncate"] = 1] = "Truncate";
})(OverflowMode || (OverflowMode = {}));

/**
 * @internal
 * TextUtils includes some helper function for text.
 */ var TextUtils = /*#__PURE__*/ function() {
    function TextUtils() {}
    /**
   * The instance function to get an object includes 2d context and canvas.
   * @returns the TextContext object
   */ TextUtils.textContext = function textContext() {
        var textContext = TextUtils._textContext;
        if (!textContext) {
            var canvas;
            try {
                canvas = new PlatformManager$1.polyfill.OffscreenCanvas(0, 0);
            } catch (e) {
                canvas = PlatformManager$1.polyfill.document.createElement("canvas");
            }
            var context = canvas.getContext("2d", {
                willReadFrequently: true
            });
            textContext = {
                canvas: canvas,
                context: context
            };
            TextUtils._textContext = textContext;
        }
        return textContext;
    };
    /**
   * Measure the font.
   * @param fontString - the string of the font
   * @returns the font size info
   */ TextUtils.measureFont = function measureFont(fontString) {
        var fontSizeInfoCache = TextUtils._fontSizeInfoCache;
        var info = fontSizeInfoCache[fontString];
        if (info) {
            return info;
        }
        info = TextUtils._measureFontOrChar(fontString);
        fontSizeInfoCache[fontString] = info;
        return info;
    };
    /**
   * Get native font string.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font string
   */ TextUtils.getNativeFontString = function getNativeFontString(fontName, fontSize, style) {
        var str = style & FontStyle.Bold ? "bold " : "";
        style & FontStyle.Italic && (str += "italic ");
        // Check if font already contains strings
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
            fontName = '"' + fontName + '"';
        }
        str += fontSize + "px " + fontName;
        return str;
    };
    TextUtils.measureChar = function measureChar(char, fontString) {
        return TextUtils._measureFontOrChar(fontString, char);
    };
    TextUtils.measureTextWithWrap = function measureTextWithWrap(renderer) {
        var subFont = renderer._subFont;
        var fontString = subFont.nativeFontString;
        var fontSizeInfo = TextUtils.measureFont(fontString);
        var subTexts = renderer.text.split(/(?:\r\n|\r|\n)/);
        var lines = new Array();
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var pixelsPerUnit = Engine._pixelsPerUnit;
        var lineHeight = fontSizeInfo.size + renderer.lineSpacing * pixelsPerUnit;
        var wrapWidth = renderer.width * pixelsPerUnit;
        var textWidth = 0;
        subFont.nativeFontString = fontString;
        for(var i = 0, n = subTexts.length; i < n; i++){
            var subText = subTexts[i];
            var word = "";
            var wordWidth = 0;
            var wordMaxAscent = 0;
            var wordMaxDescent = 0;
            var line = "";
            var lineWidth = 0;
            var lineMaxAscent = 0;
            var lineMaxDescent = 0;
            var notFirstLine = false;
            for(var j = 0, m = subText.length; j < m; ++j){
                var char = subText[j];
                var charInfo = TextUtils._getCharInfo(char, fontString, subFont);
                var charCode = char.charCodeAt(0);
                var isSpace = charCode === 32;
                if (isSpace && notFirstLine && line.length === 0 && word.length === 0) {
                    continue;
                }
                // The char code scope of Chinese is [\u4e00-\u9fff]
                var unableFromWord = isSpace || charCode >= 0x4e00 && charCode <= 0x9fff;
                var w = charInfo.w, offsetY = charInfo.offsetY;
                var halfH = charInfo.h * 0.5;
                var ascent = halfH + offsetY;
                var descent = halfH - offsetY;
                if (unableFromWord) {
                    // If it is a word before, need to handle the previous word and line
                    if (word.length > 0) {
                        if (lineWidth + wordWidth > wrapWidth) {
                            this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                            textWidth = Math.max(textWidth, lineWidth);
                            notFirstLine = true;
                            line = word;
                            lineWidth = wordWidth;
                            lineMaxAscent = wordMaxAscent;
                            lineMaxDescent = wordMaxDescent;
                        } else {
                            line += word;
                            lineWidth += wordWidth;
                            lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
                            lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
                        }
                        word = "";
                        wordWidth = wordMaxAscent = wordMaxDescent = 0;
                    }
                    // Handle char
                    // At least one char in a line
                    if (lineWidth + w > wrapWidth && lineWidth > 0) {
                        this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                        textWidth = Math.max(textWidth, lineWidth);
                        notFirstLine = true;
                        if (isSpace) {
                            line = "";
                            lineWidth = lineMaxAscent = lineMaxDescent = 0;
                        } else {
                            line = char;
                            lineWidth = charInfo.xAdvance;
                            lineMaxAscent = ascent;
                            lineMaxDescent = descent;
                        }
                    } else {
                        line += char;
                        lineWidth += charInfo.xAdvance;
                        lineMaxAscent = Math.max(lineMaxAscent, ascent);
                        lineMaxDescent = Math.max(lineMaxDescent, descent);
                    }
                } else {
                    if (wordWidth + charInfo.w > wrapWidth) {
                        if (lineWidth > 0) {
                            this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                            textWidth = Math.max(textWidth, lineWidth);
                            line = "";
                            lineWidth = lineMaxAscent = lineMaxDescent = 0;
                        }
                        this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
                        textWidth = Math.max(textWidth, wordWidth);
                        notFirstLine = true;
                        word = char;
                        wordWidth = charInfo.xAdvance;
                        wordMaxAscent = ascent;
                        wordMaxDescent = descent;
                    } else {
                        word += char;
                        wordWidth += charInfo.xAdvance;
                        wordMaxAscent = lineMaxAscent = Math.max(wordMaxAscent, ascent);
                        wordMaxDescent = lineMaxDescent = Math.max(wordMaxDescent, descent);
                    }
                }
            }
            if (wordWidth > 0) {
                // If the total width from line and word exceed wrap width
                if (lineWidth + wordWidth > wrapWidth) {
                    // Push chars to a single line
                    this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                    textWidth = Math.max(textWidth, lineWidth);
                    lineWidth = 0;
                    // Push word to a single line
                    this._pushLine(lines, lineWidths, lineMaxSizes, word, wordWidth, wordMaxAscent, wordMaxDescent);
                    textWidth = Math.max(textWidth, wordWidth);
                } else {
                    // Merge to chars
                    line += word;
                    lineWidth += wordWidth;
                    lineMaxAscent = Math.max(lineMaxAscent, wordMaxAscent);
                    lineMaxDescent = Math.max(lineMaxDescent, wordMaxDescent);
                }
            }
            if (lineWidth > 0) {
                this._pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, lineMaxAscent, lineMaxDescent);
                textWidth = Math.max(textWidth, lineWidth);
            }
        }
        var height = renderer.height * pixelsPerUnit;
        if (renderer.overflowMode === OverflowMode.Overflow) {
            height = lineHeight * lines.length;
        }
        return {
            width: textWidth,
            height: height,
            lines: lines,
            lineWidths: lineWidths,
            lineHeight: lineHeight,
            lineMaxSizes: lineMaxSizes
        };
    };
    TextUtils.measureTextWithoutWrap = function measureTextWithoutWrap(renderer) {
        var subFont = renderer._subFont;
        var fontString = subFont.nativeFontString;
        var fontSizeInfo = TextUtils.measureFont(fontString);
        var lines = renderer.text.split(/(?:\r\n|\r|\n)/);
        var lineCount = lines.length;
        var lineWidths = new Array();
        var lineMaxSizes = new Array();
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var lineHeight = fontSizeInfo.size + renderer.lineSpacing * _pixelsPerUnit;
        var width = 0;
        var height = renderer.height * _pixelsPerUnit;
        if (renderer.overflowMode === OverflowMode.Overflow) {
            height = lineHeight * lineCount;
        }
        subFont.nativeFontString = fontString;
        for(var i = 0; i < lineCount; ++i){
            var line = lines[i];
            var curWidth = 0;
            var maxAscent = -1;
            var maxDescent = -1;
            for(var j = 0, m = line.length; j < m; ++j){
                var charInfo = TextUtils._getCharInfo(line[j], fontString, subFont);
                curWidth += charInfo.xAdvance;
                var offsetY = charInfo.offsetY;
                var halfH = charInfo.h * 0.5;
                var ascent = halfH + offsetY;
                var descent = halfH - offsetY;
                maxAscent < ascent && (maxAscent = ascent);
                maxDescent < descent && (maxDescent = descent);
            }
            lineWidths[i] = curWidth;
            lineMaxSizes[i] = {
                ascent: maxAscent,
                descent: maxDescent,
                size: maxAscent + maxDescent
            };
            if (curWidth > width) {
                width = curWidth;
            }
        }
        return {
            width: width,
            height: height,
            lines: lines,
            lineWidths: lineWidths,
            lineHeight: lineHeight,
            lineMaxSizes: lineMaxSizes
        };
    };
    /**
   * Get native font hash.
   * @param fontName - The font name
   * @param fontSize - The font size
   * @param style - The font style
   * @returns The native font hash
   */ TextUtils.getNativeFontHash = function getNativeFontHash(fontName, fontSize, style) {
        var str = style & FontStyle.Bold ? "bold" : "";
        style & FontStyle.Italic && (str += "italic");
        // Check if font already contains strings
        if (!/([\"\'])[^\'\"]+\1/.test(fontName) && TextUtils._genericFontFamilies.indexOf(fontName) == -1) {
            fontName = "" + fontName;
        }
        str += fontSize + "px" + fontName;
        return str;
    };
    /**
   * @internal
   * Use internal for CanvasRenderer plugin.
   */ TextUtils._measureFontOrChar = function _measureFontOrChar(fontString, char) {
        if (char === void 0) char = "";
        var _TextUtils_textContext = TextUtils.textContext(), canvas = _TextUtils_textContext.canvas, context = _TextUtils_textContext.context;
        context.font = fontString;
        var measureString = char || TextUtils._measureString;
        // Safari gets data confusion through getImageData when the canvas width is not an integer.
        // The measure text width of some special invisible characters may be 0, so make sure the width is at least 1.
        // @todo: Text layout may vary from standard and not support emoji.
        var width = Math.max(1, Math.round(context.measureText(measureString).width));
        var baseline = Math.ceil(context.measureText(TextUtils._measureBaseline).width);
        var height = baseline * TextUtils._heightMultiplier;
        baseline = TextUtils._baselineMultiplier * baseline | 0;
        canvas.width = width;
        canvas.height = height;
        context.font = fontString;
        context.fillStyle = "#000";
        context.clearRect(0, 0, width, height);
        context.textBaseline = "middle";
        context.fillStyle = "#fff";
        context.fillText(measureString, 0, baseline);
        var colorData = context.getImageData(0, 0, width, height).data;
        var len = colorData.length;
        var top = -1;
        var bottom = -1;
        var y;
        var ascent = 0;
        var descent = 0;
        var size = 0;
        var integerW = canvas.width;
        var integerWReciprocal = 1.0 / integerW;
        for(var i = 0; i < len; i += 4){
            if (colorData[i + 3] !== 0) {
                var idx = i * 0.25;
                y = ~~(idx * integerWReciprocal);
                if (top === -1) {
                    top = y;
                }
                if (y > bottom) {
                    bottom = y;
                }
            } else {
                colorData[i] = colorData[i + 1] = colorData[i + 2] = 255;
            }
        }
        if (top !== -1 && bottom !== -1) {
            ascent = baseline - top;
            descent = bottom - baseline + 1;
            size = ascent + descent;
        }
        var sizeInfo = {
            ascent: ascent,
            descent: descent,
            size: size
        };
        if (char) {
            var data = null;
            if (size > 0) {
                var lineIntegerW = integerW * 4;
                // gl.texSubImage2D uploading data of type Uint8ClampedArray is not supported in some devices(eg: IphoneX IOS 13.6.1).
                data = new Uint8Array(colorData.buffer, top * lineIntegerW, size * lineIntegerW);
            }
            return {
                char: char,
                x: 0,
                y: 0,
                w: width,
                h: size,
                offsetX: 0,
                offsetY: (ascent - descent) * 0.5,
                xAdvance: width,
                uvs: [
                    new Vector2(),
                    new Vector2(),
                    new Vector2(),
                    new Vector2()
                ],
                ascent: ascent,
                descent: descent,
                index: 0,
                data: data
            };
        } else {
            return sizeInfo;
        }
    };
    /**
   * @internal
   * Use internal for CanvasRenderer plugin.
   */ TextUtils._getCharInfo = function _getCharInfo(char, fontString, font) {
        var charInfo = font._getCharInfo(char);
        if (!charInfo) {
            charInfo = TextUtils.measureChar(char, fontString);
            font._uploadCharTexture(charInfo);
            font._addCharInfo(char, charInfo);
        }
        return charInfo;
    };
    TextUtils._pushLine = function _pushLine(lines, lineWidths, lineMaxSizes, line, lineWidth, ascent, descent) {
        lines.push(line);
        lineWidths.push(lineWidth);
        lineMaxSizes.push({
            ascent: ascent,
            descent: descent,
            size: ascent + descent
        });
    };
    return TextUtils;
}();
(function() {
    /** @internal */ TextUtils._genericFontFamilies = [
        "serif",
        "sans-serif",
        "monospace",
        "cursive",
        "fantasy",
        "system-ui",
        "math",
        "emoji",
        "fangsong"
    ];
})();
(function() {
    /** These characters are all tall to help calculate the height required for text. */ TextUtils._measureString = "|\xc9q\xc5";
})();
(function() {
    TextUtils._measureBaseline = "M";
})();
(function() {
    TextUtils._heightMultiplier = 2;
})();
(function() {
    TextUtils._baselineMultiplier = 1.4;
})();
(function() {
    TextUtils._fontSizeInfoCache = {};
})();
(function() {
    TextUtils._textContext = null;
})();

/**
 * @internal
 */ var SubFont = /*#__PURE__*/ function() {
    function SubFont(engine) {
        this._fontAtlases = [];
        this._lastIndex = -1;
        this._engine = engine;
    }
    var _proto = SubFont.prototype;
    _proto.destroy = function destroy() {
        var fontAtlases = this._fontAtlases;
        for(var i = 0, n = fontAtlases.length; i < n; ++i){
            fontAtlases[i].destroy(true);
        }
        fontAtlases.length = 0;
    };
    /**
   * @internal
   */ _proto._uploadCharTexture = function _uploadCharTexture(charInfo) {
        var fontAtlases = this._fontAtlases;
        var lastIndex = this._lastIndex;
        if (lastIndex === -1) {
            this._createFontAtlas();
            lastIndex++;
        }
        var fontAtlas = fontAtlases[lastIndex];
        if (!fontAtlas.uploadCharTexture(charInfo)) {
            fontAtlas = this._createFontAtlas();
            fontAtlas.uploadCharTexture(charInfo);
            lastIndex++;
        }
        this._lastIndex = lastIndex;
        charInfo.data = null;
    };
    /**
   * @internal
   */ _proto._addCharInfo = function _addCharInfo(char, charInfo) {
        var lastIndex = this._lastIndex;
        charInfo.index = lastIndex;
        this._fontAtlases[lastIndex].addCharInfo(char, charInfo);
    };
    /**
   * @internal
   */ _proto._getCharInfo = function _getCharInfo(char) {
        var fontAtlases = this._fontAtlases;
        for(var i = 0, n = fontAtlases.length; i < n; ++i){
            var fontAtlas = fontAtlases[i];
            var charInfo = fontAtlas.getCharInfo(char);
            if (charInfo) {
                return charInfo;
            }
        }
        return null;
    };
    /**
   * @internal
   */ _proto._getTextureByIndex = function _getTextureByIndex(index) {
        var fontAtlas = this._fontAtlases[index];
        if (fontAtlas) {
            return fontAtlas.texture;
        }
        return null;
    };
    /**
   * @internal
   */ _proto._getLastIndex = function _getLastIndex() {
        return this._lastIndex;
    };
    _proto._createFontAtlas = function _createFontAtlas() {
        var _this = this, engine = _this._engine;
        var fontAtlas = new FontAtlas(engine);
        var texture = new Texture2D(engine, 256, 256);
        fontAtlas.texture = texture;
        fontAtlas.isGCIgnored = texture.isGCIgnored = true;
        this._fontAtlases.push(fontAtlas);
        var nativeFontString = this.nativeFontString;
        engine.resourceManager.addContentRestorer(new /*#__PURE__*/ (function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, fontAtlas);
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                var resource = this.resource;
                var charInfoMap = resource._charInfoMap;
                var texture = resource.texture;
                for(var k in charInfoMap){
                    var charInfo = charInfoMap[k];
                    var data = TextUtils.measureChar(charInfo.char, nativeFontString).data;
                    if (charInfo.w > 0 && charInfo.h > 0 && data) {
                        var bufferOffset = charInfo.bufferOffset;
                        texture.setPixelBuffer(data, 0, bufferOffset.x, bufferOffset.y, charInfo.w, charInfo.h);
                    }
                }
                texture.generateMipmaps();
            };
            return _class;
        }(ContentRestorer))());
        return fontAtlas;
    };
    return SubFont;
}();

/**
 * Font.
 */ var Font = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Font, ReferResource);
    function Font(engine, name) {
        if (name === void 0) name = "";
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this._name = "";
        _this._subFontMap = {};
        _this._name = name;
        return _this;
    }
    var _proto = Font.prototype;
    /**
   * @internal
   */ _proto._getSubFont = function _getSubFont(fontSize, fontStyle) {
        var key = fontSize + "-" + fontStyle;
        var subFontMap = this._subFontMap;
        var subFont = subFontMap[key];
        if (subFont) {
            return subFont;
        }
        subFont = new SubFont(this.engine);
        subFontMap[key] = subFont;
        return subFont;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var subFontMap = this._subFontMap;
        for(var k in subFontMap){
            subFontMap[k].destroy();
        }
        this._subFontMap = null;
        delete this.engine._fontMap[this._name];
    };
    /**
   * Create a system font.
   * @param engine - Engine to which the font belongs
   * @param name - The name of font want to create
   * @returns The font object has been create
   */ Font.createFromOS = function createFromOS(engine, name) {
        if (name) {
            var fontMap = engine._fontMap;
            var font = fontMap[name];
            if (font) {
                return font;
            }
            font = new Font(engine, name);
            fontMap[name] = font;
            return font;
        }
        return null;
    };
    _create_class$3(Font, [
        {
            key: "name",
            get: /**
   * The name of the font object.
   */ function get() {
                return this._name;
            }
        }
    ]);
    return Font;
}(ReferResource);

var AssetPromise = /*#__PURE__*/ function() {
    function AssetPromise(executor) {
        var _this = this;
        this._state = "pending";
        this._onProgressCallback = [];
        this._promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            var onResolve = function(value) {
                if (_this._state === "pending") {
                    resolve(value);
                    _this._state = "fulfilled";
                    _this._onProgressCallback = undefined;
                }
            };
            var onReject = function(reason) {
                if (_this._state === "pending") {
                    reject(reason);
                    _this._state = "rejected";
                    _this._onProgressCallback = undefined;
                }
            };
            var onCancel = function(callback) {
                if (_this._state === "pending") {
                    _this._onCancelHandler = callback;
                }
            };
            var setProgress = function(progress) {
                if (_this._state === "pending") {
                    _this._onProgressCallback.forEach(function(callback) {
                        return callback(progress);
                    });
                }
            };
            executor(onResolve, onReject, setProgress, onCancel);
        });
    }
    var _proto = AssetPromise.prototype;
    /**
   * Progress callback.
   * @param callback
   * @returns AssetPromise
   */ _proto.onProgress = function onProgress(callback) {
        this._onProgressCallback.push(callback);
        return this;
    };
    _proto.then = function then(onfulfilled, onrejected) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this._promise.then(onfulfilled, onrejected).then(resolve).catch(reject);
        });
    };
    /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onRejected - The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */ _proto.catch = function _catch(onRejected) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this._promise.catch(onRejected).then(resolve).catch(reject);
        });
    };
    /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */ _proto.finally = function _finally(onFinally) {
        return this._promise.finally(onFinally);
    };
    /**
   * Cancel promise request.
   * @returns Asset promise
   */ _proto.cancel = function cancel() {
        if (this._state !== "pending") {
            return;
        }
        this._state = "canceled";
        this._reject("canceled");
        this._onCancelHandler && this._onCancelHandler();
        return this;
    };
    /**
   * Return a new resource Promise through the provided asset promise collection.
   * The resolved of the new AssetPromise will be triggered when all the Promises in the provided set are completed.
   * @param - Promise Collection
   * @returns AssetPromise
   */ AssetPromise.all = function all(promises) {
        return new AssetPromise(function(resolve, reject, setProgress) {
            var onComplete = function onComplete(index, resultValue) {
                completed++;
                results[index] = resultValue;
                setProgress(completed / count);
                if (completed === count) {
                    resolve(results);
                }
            };
            var onProgress = function onProgress(promise, index) {
                if (_instanceof$2(promise, Promise) || _instanceof$2(promise, AssetPromise)) {
                    promise.then(function(value) {
                        onComplete(index, value);
                    }, reject);
                } else {
                    Promise.resolve().then(function() {
                        onComplete(index, promise);
                    });
                }
            };
            var count = promises.length;
            var results = new Array(count);
            var completed = 0;
            if (count === 0) {
                return resolve(results);
            }
            for(var i = 0; i < count; i++){
                onProgress(promises[i], i);
            }
        });
    };
    _create_class$3(AssetPromise, [
        {
            key: Symbol.toStringTag,
            get: /** compatible with Promise */ function get() {
                return "AssetPromise";
            }
        }
    ]);
    return AssetPromise;
}();
var /** @internal */ PromiseState;
(function(PromiseState) {
    PromiseState["Pending"] = "pending";
    PromiseState["Fulfilled"] = "fulfilled";
    PromiseState["Rejected"] = "rejected";
    PromiseState["Canceled"] = "canceled";
})(PromiseState || (PromiseState = {}));

/**
 * ResourceManager
 */ var ResourceManager = /*#__PURE__*/ function() {
    function ResourceManager(engine) {
        this.engine = engine;
        this./** The number of retries after failing to load assets. */ retryCount = 1;
        this./** Retry delay time after failed to load assets, in milliseconds. */ retryInterval = 0;
        this./** The default timeout period for loading assets, in milliseconds. */ timeout = Infinity;
        this._loadingPromises = {};
        this._assetPool = Object.create(null);
        this._assetUrlPool = Object.create(null);
        this._referResourcePool = Object.create(null);
        this._graphicResourcePool = Object.create(null);
        this._contentRestorerPool = Object.create(null);
        this.//-----------------Editor temp solution-----------------
        /** @internal */ _objectPool = Object.create(null);
        this./** @internal */ _editorResourceConfig = Object.create(null);
        this./** @internal */ _virtualPathMap = Object.create(null);
    }
    var _proto = ResourceManager.prototype;
    _proto.load = function load(assetInfo) {
        var _this = this;
        // single item
        if (!Array.isArray(assetInfo)) {
            return this._loadSingleItem(assetInfo);
        }
        // multi items
        var promises = assetInfo.map(function(item) {
            return _this._loadSingleItem(item);
        });
        return AssetPromise.all(promises);
    };
    /**
   * Get the resource from cache by asset url, return the resource object if it loaded, otherwise return null.
   * @param url - Resource url
   * @returns Resource object
   */ _proto.getFromCache = function getFromCache(url) {
        var _this__assetUrlPool_url;
        return (_this__assetUrlPool_url = this._assetUrlPool[url]) != null ? _this__assetUrlPool_url : null;
    };
    /**
   * Get asset url from instanceId.
   * @param instanceId - Engine instance id
   * @returns Asset url
   */ _proto.getAssetPath = function getAssetPath(instanceId) {
        return this._assetPool[instanceId];
    };
    _proto.cancelNotLoaded = function cancelNotLoaded(url) {
        var _this = this;
        if (!url) {
            Utils.objectValues(this._loadingPromises).forEach(function(promise) {
                promise.cancel();
            });
        } else if (typeof url === "string") {
            var _this__loadingPromises_url;
            (_this__loadingPromises_url = this._loadingPromises[url]) == null ? void 0 : _this__loadingPromises_url.cancel();
        } else {
            url.forEach(function(p) {
                var _this__loadingPromises_p;
                (_this__loadingPromises_p = _this._loadingPromises[p]) == null ? void 0 : _this__loadingPromises_p.cancel();
            });
        }
    };
    /**
   * Garbage collection will release resource objects managed by reference counting.
   * @remarks The release principle is that it is not referenced by the components, including direct and indirect reference.
   */ _proto.gc = function gc() {
        this._gc(false);
        this.engine._pendingGC();
    };
    /**
   * Add content restorer.
   * @param restorer - The restorer
   */ _proto.addContentRestorer = function addContentRestorer(restorer) {
        this._contentRestorerPool[restorer.resource.instanceId] = restorer;
    };
    /**
   * @internal
   */ _proto._addAsset = function _addAsset(path, asset) {
        this._assetPool[asset.instanceId] = path;
        this._assetUrlPool[path] = asset;
    };
    /**
   * @internal
   */ _proto._deleteAsset = function _deleteAsset(asset) {
        var id = asset.instanceId;
        var path = this._assetPool[id];
        if (path) {
            delete this._assetPool[id];
            delete this._assetUrlPool[path];
        }
    };
    /**
   * @internal
   */ _proto._addReferResource = function _addReferResource(resource) {
        this._referResourcePool[resource.instanceId] = resource;
    };
    /**
   * @internal
   */ _proto._deleteReferResource = function _deleteReferResource(resource) {
        delete this._referResourcePool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._addGraphicResource = function _addGraphicResource(resource) {
        this._graphicResourcePool[resource.instanceId] = resource;
    };
    /**
   * @internal
   */ _proto._deleteGraphicResource = function _deleteGraphicResource(resource) {
        delete this._graphicResourcePool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._deleteContentRestorer = function _deleteContentRestorer(resource) {
        delete this._contentRestorerPool[resource.instanceId];
    };
    /**
   * @internal
   */ _proto._restoreGraphicResources = function _restoreGraphicResources() {
        var graphicResourcePool = this._graphicResourcePool;
        for(var id in graphicResourcePool){
            graphicResourcePool[id]._rebuild();
        }
    };
    /**
   * @internal
   */ _proto._restoreResourcesContent = function _restoreResourcesContent() {
        var restoreContentInfoPool = this._contentRestorerPool;
        var restorePromises = new Array();
        for(var k in restoreContentInfoPool){
            var restoreInfo = restoreContentInfoPool[k];
            var promise = restoreInfo.restoreContent();
            promise && restorePromises.push(promise);
        }
        return Promise.all(restorePromises);
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this.cancelNotLoaded();
        this._gc(true);
        this._assetPool = null;
        this._assetUrlPool = null;
        this._referResourcePool = null;
        this._graphicResourcePool = null;
        this._contentRestorerPool = null;
        this._loadingPromises = null;
    };
    _proto._assignDefaultOptions = function _assignDefaultOptions(assetInfo) {
        var _assetInfo_type;
        assetInfo.type = (_assetInfo_type = assetInfo.type) != null ? _assetInfo_type : ResourceManager._getTypeByUrl(assetInfo.url);
        if (assetInfo.type === undefined) {
            throw "asset type should be specified: " + assetInfo.url;
        }
        var _assetInfo_retryCount;
        assetInfo.retryCount = (_assetInfo_retryCount = assetInfo.retryCount) != null ? _assetInfo_retryCount : this.retryCount;
        var _assetInfo_timeout;
        assetInfo.timeout = (_assetInfo_timeout = assetInfo.timeout) != null ? _assetInfo_timeout : this.timeout;
        var _assetInfo_retryInterval;
        assetInfo.retryInterval = (_assetInfo_retryInterval = assetInfo.retryInterval) != null ? _assetInfo_retryInterval : this.retryInterval;
        var _assetInfo_url;
        assetInfo.url = (_assetInfo_url = assetInfo.url) != null ? _assetInfo_url : assetInfo.urls.join(",");
        return assetInfo;
    };
    _proto._loadSingleItem = function _loadSingleItem(itemOrURL) {
        var _this = this;
        var item = this._assignDefaultOptions(typeof itemOrURL === "string" ? {
            url: itemOrURL
        } : itemOrURL);
        // Check url mapping
        var itemURL = item.url;
        var url = this._virtualPathMap[itemURL] ? this._virtualPathMap[itemURL] : itemURL;
        // Parse url
        var _this__parseURL = this._parseURL(url), assetBaseURL = _this__parseURL.assetBaseURL, queryPath = _this__parseURL.queryPath;
        var paths = queryPath ? this._parseQueryPath(queryPath) : [];
        // Check cache
        var cacheObject = this._assetUrlPool[assetBaseURL];
        if (cacheObject) {
            return new AssetPromise(function(resolve) {
                resolve(_this._getResolveResource(cacheObject, paths));
            });
        }
        // Get asset url
        var assetURL = assetBaseURL;
        if (queryPath) {
            assetURL += "?q=" + paths.shift();
        }
        // Check is loading
        var loadingPromises = this._loadingPromises;
        var loadingPromise = loadingPromises[assetURL];
        if (loadingPromise) {
            return new AssetPromise(function(resolve, reject) {
                loadingPromise.then(function(resource) {
                    resolve(_this._getResolveResource(resource, paths));
                }).catch(function(error) {
                    reject(error);
                });
            });
        }
        // Check loader
        var loader = ResourceManager._loaders[item.type];
        if (!loader) {
            throw "loader not found: " + item.type;
        }
        // Load asset
        item.url = assetBaseURL;
        var promise = loader.load(item, this);
        if (_instanceof$2(promise, AssetPromise)) {
            loadingPromises[assetBaseURL] = promise;
            promise.then(function(resource) {
                if (loader.useCache) {
                    _this._addAsset(assetBaseURL, resource);
                }
                delete loadingPromises[assetBaseURL];
            }, function() {
                return delete loadingPromises[assetBaseURL];
            });
            return promise;
        } else {
            var _loop = function(subURL) {
                var subPromise = promise[subURL];
                var isMaster = assetBaseURL === subURL;
                loadingPromises[subURL] = subPromise;
                subPromise.then(function(resource) {
                    if (isMaster) {
                        if (loader.useCache) {
                            _this._addAsset(subURL, resource);
                            for(var k in promise)delete loadingPromises[k];
                        }
                    }
                }, function() {
                    for(var k in promise)delete loadingPromises[k];
                });
            };
            for(var subURL in promise)_loop(subURL);
            return promise[assetURL].then(function(resource) {
                return _this._getResolveResource(resource, paths);
            });
        }
    };
    _proto._gc = function _gc(forceDestroy) {
        var objects = Utils.objectValues(this._referResourcePool);
        for(var i = 0, len = objects.length; i < len; i++){
            if (!objects[i].isGCIgnored || forceDestroy) {
                objects[i].destroy();
            }
        }
    };
    _proto._getResolveResource = function _getResolveResource(resource, paths) {
        var subResource = resource;
        if (paths) {
            for(var i = 0, n = paths.length; i < n; i++){
                var path = paths[i];
                subResource = subResource[path];
            }
        }
        return subResource;
    };
    _proto._parseURL = function _parseURL(path) {
        var assetBaseURL = path;
        var index = assetBaseURL.indexOf("?");
        if (index !== -1) {
            assetBaseURL = assetBaseURL.slice(0, index);
        }
        return {
            assetBaseURL: assetBaseURL,
            queryPath: this._getParameterByName("q", path)
        };
    };
    _proto._getParameterByName = function _getParameterByName(name, url) {
        if (url === void 0) url = PlatformManager$1.polyfill.window.location.href;
        name = name.replace(/[\[\]]/g, "\\$&");
        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return "";
        return decodeURIComponent(results[2].replace(/\+/g, " "));
    };
    _proto._parseQueryPath = function _parseQueryPath(string) {
        var result = [];
        if (string.charCodeAt(0) === charCodeOfDot$1) {
            result.push("");
        }
        string.replace(rePropName$1, function(match, expression, quote, subString) {
            var key = match;
            if (quote) {
                key = subString.replace(reEscapeChar$1, "$1");
            } else if (expression) {
                key = expression.trim();
            }
            result.push(key);
        });
        return result;
    };
    /**
   * @internal
   * @beta Just for internal editor, not recommended for developers.
   */ _proto.getResourceByRef = function getResourceByRef(ref) {
        var refId = ref.refId, key = ref.key, isClone = ref.isClone;
        var obj = this._objectPool[refId];
        var promise;
        if (obj) {
            promise = Promise.resolve(obj);
        } else {
            var _this__editorResourceConfig_refId;
            var url = (_this__editorResourceConfig_refId = this._editorResourceConfig[refId]) == null ? void 0 : _this__editorResourceConfig_refId.path;
            if (!url) {
                Logger.warn("refId:" + refId + " is not find in this._editorResourceConfig.");
                return Promise.resolve(null);
            }
            url = key ? "" + url + (url.indexOf("?") > -1 ? "&" : "?") + "q=" + key : url;
            promise = this.load({
                url: url,
                type: this._editorResourceConfig[refId].type
            });
        }
        return promise.then(function(item) {
            return isClone ? item.clone() : item;
        });
    };
    /**
   * @internal
   * @beta Just for internal editor, not recommended for developers.
   */ _proto.initVirtualResources = function initVirtualResources(config) {
        var _this = this;
        config.forEach(function(element) {
            _this._virtualPathMap[element.virtualPath] = element.path;
            _this._editorResourceConfig[element.id] = element;
        });
    };
    /**
   * @internal
   */ ResourceManager._addLoader = function _addLoader(type, loader, extNames) {
        this._loaders[type] = loader;
        for(var i = 0, len = extNames.length; i < len; i++){
            this._extTypeMapping[extNames[i]] = type;
        }
    };
    ResourceManager._getTypeByUrl = function _getTypeByUrl(url) {
        var path = url.split("?")[0];
        return this._extTypeMapping[path.substring(path.lastIndexOf(".") + 1)];
    };
    return ResourceManager;
}();
(function() {
    /** Loader collection. */ ResourceManager._loaders = {};
})();
(function() {
    ResourceManager._extTypeMapping = {};
})();
/**
 * Declare ResourceLoader's decorator.
 * @param assetType - Type of asset
 * @param extNames - Name of file extension
 */ function resourceLoader(assetType, extNames, useCache) {
    if (useCache === void 0) useCache = true;
    return function(Target) {
        var loader = new Target(useCache);
        ResourceManager._addLoader(assetType, loader, extNames);
    };
}
var charCodeOfDot$1 = ".".charCodeAt(0);
var reEscapeChar$1 = /\\(\\)?/g;
var rePropName$1 = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");

/**
 * EventDispatcher, which can be inherited as a base class.
 */ var EventDispatcher = /*#__PURE__*/ function() {
    function EventDispatcher() {
        this._events = Object.create(null);
        this._eventCount = 0;
        this._dispatchingListeners = [];
    }
    var _proto = EventDispatcher.prototype;
    /**
   * Determine whether there is event listening.
   * @param event - Event name
   * @returns Returns whether there is a corresponding event
   */ _proto.hasEvent = function hasEvent(event) {
        return this._events[event] != null;
    };
    /**
   * Returns the names of all registered events.
   * @returns All event names
   */ _proto.eventNames = function eventNames() {
        if (this._eventCount === 0) return [];
        return Object.keys(this._events);
    };
    /**
   * Returns the number of listeners with the specified event name.
   * @param event - Event name
   * @returns The count of listeners
   */ _proto.listenerCount = function listenerCount(event) {
        var listeners = this._events[event];
        if (!listeners) return 0;
        if (Array.isArray(listeners)) return listeners.length;
        return 1;
    };
    /**
   * Dispatch the event with the specified event name.
   * @param event - Event name
   * @param data - Data
   * @returns - Whether the dispatching is successful
   */ _proto.dispatch = function dispatch(event, data) {
        if (!this._events[event]) {
            return false;
        }
        var listeners = this._events[event];
        if (Array.isArray(listeners)) {
            var count = listeners.length;
            // cloning list to avoid structure breaking
            var dispatchingListeners = this._dispatchingListeners;
            dispatchingListeners.length = count;
            for(var i = 0; i < count; i++){
                dispatchingListeners[i] = listeners[i];
            }
            for(var i1 = 0; i1 < count; i1++){
                var listener = dispatchingListeners[i1];
                if (!listener.destroyed) {
                    if (listener.once) this.off(event, listener.fn);
                    listener.fn(data);
                }
            }
            // remove hooked function to avoid gc problem
            dispatchingListeners.length = 0;
        } else {
            if (listeners.once) this.off(event, listeners.fn);
            listeners.fn(data);
        }
        return true;
    };
    /**
   * Add a listener/
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */ _proto.on = function on(event, fn) {
        return this._addEventListener(event, fn);
    };
    /**
   * Add a one-time listener.
   * @param event - Event name
   * @param fn - Function
   * @returns This
   */ _proto.once = function once(event, fn) {
        return this._addEventListener(event, fn, true);
    };
    /**
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */ _proto.off = function off(event, fn) {
        if (!this._events[event]) return this;
        if (!fn) {
            this._clearEvent(event);
            return this;
        }
        var listeners = this._events[event];
        var isArray = Array.isArray(listeners);
        if (!isArray && listeners.fn === fn) {
            this._clearEvent(event);
        } else if (isArray) {
            for(var i = listeners.length - 1; i >= 0; i--){
                if (listeners[i].fn === fn) {
                    // mark as destroyed
                    listeners[i].destroyed = true;
                    listeners.splice(i, 1);
                }
            }
            if (listeners.length === 0) {
                this._clearEvent(event);
            } else if (listeners.length === 1) {
                this._events[event] = listeners[0];
            }
        }
        return this;
    };
    /**
   * @deprecated Use `off` instead.
   * Remove the event listener(s) of the specified event name.
   * @param event - Event name
   * @param fn - Function, If is undefined, delete all corresponding event listeners.
   */ _proto.removeEventListener = function removeEventListener(event, fn) {
        return this.off(event, fn);
    };
    /**
   * Remove all event listeners.
   * @param event - Event name, delete all events if not passed
   */ _proto.removeAllEventListeners = function removeAllEventListeners(event) {
        if (event) {
            if (this._events[event]) this._clearEvent(event);
        } else {
            this._events = Object.create(null);
            this._eventCount = 0;
        }
    };
    _proto._addEventListener = function _addEventListener(event, fn, once) {
        var listener = {
            fn: fn,
            once: once
        };
        var events = this._events;
        var element = events[event];
        if (!element) {
            events[event] = listener;
            this._eventCount++;
        } else if (Array.isArray(element)) {
            element.push(listener);
        } else {
            events[event] = [
                element,
                listener
            ];
        }
        return this;
    };
    _proto._clearEvent = function _clearEvent(event) {
        if (--this._eventCount === 0) {
            this._events = Object.create(null);
        } else {
            delete this._events[event];
        }
    };
    return EventDispatcher;
}();

/**
 * Shader property.
 */ var ShaderProperty = /*#__PURE__*/ function() {
    function ShaderProperty(name) {
        this.name = name;
        this._uniqueId = ShaderProperty._propertyNameCounter++;
    }
    /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ ShaderProperty.getByName = function getByName(name) {
        var propertyNameMap = ShaderProperty._propertyNameMap;
        if (propertyNameMap[name] != null) {
            return propertyNameMap[name];
        } else {
            var property = new ShaderProperty(name);
            propertyNameMap[name] = property;
            ShaderProperty._propertyIdMap[property._uniqueId] = property;
            return property;
        }
    };
    /**
   * @internal
   */ ShaderProperty._getShaderPropertyGroup = function _getShaderPropertyGroup(propertyName) {
        var shaderProperty = ShaderProperty._propertyNameMap[propertyName];
        return shaderProperty == null ? void 0 : shaderProperty._group;
    };
    _create_class$3(ShaderProperty, [
        {
            key: "type",
            get: /**
   * Shader property type.
   */ function get() {
                return this._type;
            }
        }
    ]);
    return ShaderProperty;
}();
(function() {
    /** @internal */ ShaderProperty._propertyIdMap = Object.create(null);
})();
(function() {
    ShaderProperty._propertyNameCounter = 0;
})();
(function() {
    ShaderProperty._propertyNameMap = Object.create(null);
})();

/**
 * Provide time related information.
 */ var Time = /*#__PURE__*/ function() {
    function Time() {
        this._frameCount = 0;
        this._deltaTime = 0;
        this._actualDeltaTime = 0;
        this._elapsedTime = 0;
        this._actualElapsedTime = 0;
        this._elapsedTimeValue = new Vector4();
        this._deltaTimeValue = new Vector4();
        /** Maximum delta time allowed per frame in seconds. */ this.maximumDeltaTime = 0.333333;
        /** The scale of time. */ this.timeScale = 1.0;
        this._lastSystemTime = PlatformManager$1.polyfill.performance.now() / 1000;
    }
    var _proto = Time.prototype;
    /**
   * @internal
   */ _proto._reset = function _reset() {
        this._lastSystemTime = PlatformManager$1.polyfill.performance.now() / 1000;
    };
    /**
   * @internal
   */ _proto._update = function _update() {
        var currentSystemTime = PlatformManager$1.polyfill.performance.now() / 1000;
        var actualDeltaTime = currentSystemTime - this._lastSystemTime;
        this._actualDeltaTime = actualDeltaTime;
        this._actualElapsedTime += actualDeltaTime;
        var deltaTime = Math.min(actualDeltaTime, this.maximumDeltaTime) * this.timeScale;
        this._deltaTime = deltaTime;
        this._elapsedTime += deltaTime;
        this._frameCount++;
        this._lastSystemTime = currentSystemTime;
    };
    /**
   * @internal
   */ _proto._updateSceneShaderData = function _updateSceneShaderData(shaderData) {
        var _this = this, elapsedTimeValue = _this._elapsedTimeValue, deltaTimeValue = _this._deltaTimeValue;
        var time = this._elapsedTime;
        elapsedTimeValue.set(time, Math.sin(time), Math.cos(time), 0);
        shaderData.setVector4(Time._elapsedTimeProperty, elapsedTimeValue);
        deltaTimeValue.set(this._deltaTime, 0, 0, 0);
        shaderData.setVector4(Time._deltaTimeProperty, deltaTimeValue);
    };
    _create_class$3(Time, [
        {
            key: "frameCount",
            get: /*
   * The total number of frames since the start of the engine.
   */ function get() {
                return this._frameCount;
            }
        },
        {
            key: "deltaTime",
            get: /**
   * The delta time in seconds from the last frame to the current frame.
   *
   * @remarks When the frame rate is low or stutter occurs, `deltaTime` will not exceed the value of `maximumDeltaTime` * `timeScale`.
   */ function get() {
                return this._deltaTime;
            }
        },
        {
            key: "elapsedTime",
            get: /**
   * The amount of elapsed time in seconds since the start of the engine.
   */ function get() {
                return this._elapsedTime;
            }
        },
        {
            key: "actualDeltaTime",
            get: /**
   * The actual delta time in seconds from the last frame to the current frame.
   *
   * @remarks The actual delta time is not affected by `maximumDeltaTime` and `timeScale`.
   */ function get() {
                return this._actualDeltaTime;
            }
        },
        {
            key: "actualElapsedTime",
            get: /**
   * The amount of actual elapsed time in seconds since the start of the engine.
   */ function get() {
                return this._actualElapsedTime;
            }
        }
    ]);
    return Time;
}();
(function() {
    Time._elapsedTimeProperty = ShaderProperty.getByName("scene_ElapsedTime");
})();
(function() {
    Time._deltaTimeProperty = ShaderProperty.getByName("scene_DeltaTime");
})();

/**
 * Data type enumeration
 */ var DataType;
(function(DataType) {
    DataType[DataType[/** Float */ "FLOAT"] = 5126] = "FLOAT";
    DataType[DataType[/** Floating-point two-dimensional vector */ "FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    DataType[DataType[/** Floating-point three-dimensional vector */ "FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    DataType[DataType[/** Floating-point four-dimensional vector */ "FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    DataType[DataType[/** Integer */ "INT"] = 5124] = "INT";
    DataType[DataType[/** Integer two-dimensional vector */ "INT_VEC2"] = 35667] = "INT_VEC2";
    DataType[DataType[/** Integer three-dimensional vector */ "INT_VEC3"] = 35668] = "INT_VEC3";
    DataType[DataType[/** Integer four-dimensional vector */ "INT_VEC4"] = 35669] = "INT_VEC4";
    DataType[DataType[/** Boolean */ "BOOL"] = 35670] = "BOOL";
    DataType[DataType[/** Boolean two-dimensional vector */ "BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    DataType[DataType[/** Boolean three-dimensional vector */ "BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    DataType[DataType[/** Boolean four-dimensional vector */ "BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    DataType[DataType[/** Second-order matrix */ "FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    DataType[DataType[/** Third-order matrix */ "FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    DataType[DataType[/** Fourth-order matrix */ "FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    DataType[DataType[/** Float array */ "FLOAT_ARRAY"] = 35677] = "FLOAT_ARRAY";
    DataType[DataType[/** Floating-point two-dimensional vector array */ "FLOAT_VEC2_ARRAY"] = 100000] = "FLOAT_VEC2_ARRAY";
    DataType[DataType[/** Floating-point three-dimensional vector array */ "FLOAT_VEC3_ARRAY"] = 100001] = "FLOAT_VEC3_ARRAY";
    DataType[DataType[/** Floating-point four-dimensional vector array */ "FLOAT_VEC4_ARRAY"] = 100002] = "FLOAT_VEC4_ARRAY";
    DataType[DataType[/** Integer array */ "INT_ARRAY"] = 100003] = "INT_ARRAY";
    DataType[DataType[/** Integer two-dimensional vector array */ "INT_VEC2_ARRAY"] = 100004] = "INT_VEC2_ARRAY";
    DataType[DataType[/** Integer three-dimensional vector array */ "INT_VEC3_ARRAY"] = 100005] = "INT_VEC3_ARRAY";
    DataType[DataType[/** Integer four-dimensional vector array */ "INT_VEC4_ARRAY"] = 100006] = "INT_VEC4_ARRAY";
    DataType[DataType[/** Second-order matrix array */ "FLOAT_MAT2_ARRAY"] = 100007] = "FLOAT_MAT2_ARRAY";
    DataType[DataType[/** Third-order matrix array */ "FLOAT_MAT3_ARRAY"] = 100008] = "FLOAT_MAT3_ARRAY";
    DataType[DataType[/** Fourth-order matrix array */ "FLOAT_MAT4_ARRAY"] = 100009] = "FLOAT_MAT4_ARRAY";
    DataType[DataType[/** 2D texture sampler array */ "SAMPLER_2D_ARRAY"] = 100010] = "SAMPLER_2D_ARRAY";
    DataType[DataType[/** Cube map texture sampler array */ "SAMPLER_CUBE_ARRAY"] = 100011] = "SAMPLER_CUBE_ARRAY";
    DataType[DataType[/** 2D sampler */ "SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    DataType[DataType[/** Cube map Texture sampler */ "SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    DataType[DataType[/** Byte */ "BYTE"] = 5120] = "BYTE";
    DataType[DataType[/** Unsigned byte */ "UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    DataType[DataType[/** Short */ "SHORT"] = 5122] = "SHORT";
    DataType[DataType[/** Unsigned short */ "UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    DataType[DataType[/** Unsigned int */ "UNSIGNED_INT"] = 5125 // gl.UNSIGNED_INT
    ] = "UNSIGNED_INT";
})(DataType || (DataType = {}));
var GLCapabilityType;
(function(GLCapabilityType) {
    GLCapabilityType["shaderVertexID"] = "shaderVertexID";
    GLCapabilityType["standardDerivatives"] = "OES_standard_derivatives";
    GLCapabilityType["shaderTextureLod"] = "EXT_shader_texture_lod";
    GLCapabilityType["elementIndexUint"] = "OES_element_index_uint";
    GLCapabilityType["depthTexture"] = "WEBGL_depth_texture";
    GLCapabilityType["drawBuffers"] = "WEBGL_draw_buffers";
    GLCapabilityType["vertexArrayObject"] = "OES_vertex_array_object";
    GLCapabilityType["instancedArrays"] = "ANGLE_instanced_arrays";
    GLCapabilityType["multipleSample"] = "multipleSampleOnlySupportedInWebGL2";
    GLCapabilityType["textureFloat"] = "OES_texture_float";
    GLCapabilityType["textureFloatLinear"] = "OES_texture_float_linear";
    GLCapabilityType["textureHalfFloat"] = "OES_texture_half_float";
    GLCapabilityType["textureHalfFloatLinear"] = "OES_texture_half_float_linear";
    GLCapabilityType["WEBGL_colorBufferFloat"] = "WEBGL_color_buffer_float";
    GLCapabilityType["colorBufferFloat"] = "EXT_color_buffer_float";
    GLCapabilityType["colorBufferHalfFloat"] = "EXT_color_buffer_half_float";
    GLCapabilityType["textureFilterAnisotropic"] = "EXT_texture_filter_anisotropic";
    GLCapabilityType["blendMinMax"] = "EXT_blend_minmax";
    GLCapabilityType["astc"] = "WEBGL_compressed_texture_astc";
    GLCapabilityType["astc_webkit"] = "WEBKIT_WEBGL_compressed_texture_astc";
    GLCapabilityType["etc"] = "WEBGL_compressed_texture_etc";
    GLCapabilityType["etc_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc";
    GLCapabilityType["etc1"] = "WEBGL_compressed_texture_etc1";
    GLCapabilityType["etc1_webkit"] = "WEBKIT_WEBGL_compressed_texture_etc1";
    GLCapabilityType["pvrtc"] = "WEBGL_compressed_texture_pvrtc";
    GLCapabilityType["pvrtc_webkit"] = "WEBKIT_WEBGL_compressed_texture_pvrtc";
    GLCapabilityType["s3tc"] = "WEBGL_compressed_texture_s3tc";
    GLCapabilityType["s3tc_webkit"] = "WEBKIT_WEBGL_compressed_texture_s3tc";
    GLCapabilityType[// atc = "WEBGL_compressed_texture_atc",
    // s3tc_srgb = "WEBGL_compressed_texture_s3tc_srgb"
    "WEBGL_lose_context"] = "WEBGL_lose_context";
})(GLCapabilityType || (GLCapabilityType = {}));

/**
 * High-performance unordered array, delete uses exchange method to improve performance, internal capacity only increases.
 */ var DisorderedArray = /*#__PURE__*/ function() {
    function DisorderedArray(count) {
        if (count === void 0) count = 0;
        this.length = 0;
        this._elements = new Array(count);
    }
    var _proto = DisorderedArray.prototype;
    _proto.add = function add(element) {
        if (this.length === this._elements.length) this._elements.push(element);
        else this._elements[this.length] = element;
        this.length++;
    };
    _proto.delete = function _delete(element) {
        //TODO: It can be optimized for custom binary search and other algorithms, currently this._elements>=this.length wastes performance.
        var index = this._elements.indexOf(element);
        this.deleteByIndex(index);
    };
    _proto.get = function get(index) {
        if (index >= this.length) {
            throw "Index is out of range.";
        }
        return this._elements[index];
    };
    /**
   *
   * @param index
   * @returns The replaced item is used to reset its index.
   */ _proto.deleteByIndex = function deleteByIndex(index) {
        var elements = this._elements;
        var end = null;
        var lastIndex = this.length - 1;
        if (index !== lastIndex) {
            end = elements[lastIndex];
            elements[index] = end;
        }
        this.length--;
        return end;
    };
    _proto.garbageCollection = function garbageCollection() {
        this._elements.length = this.length;
    };
    return DisorderedArray;
}();

/**
 * The manager of the components.
 */ var ComponentsManager = /*#__PURE__*/ function() {
    function ComponentsManager() {
        /** @internal */ this._renderers = new DisorderedArray();
        // Script
        this._onStartScripts = new DisorderedArray();
        this._onUpdateScripts = new DisorderedArray();
        this._onLateUpdateScripts = new DisorderedArray();
        this._onPhysicsUpdateScripts = new DisorderedArray();
        this._disableScripts = [];
        this._pendingDestroyScripts = [];
        this._disposeDestroyScripts = [];
        // Animation
        this._onUpdateAnimations = new DisorderedArray();
        // Render
        this._onUpdateRenderers = new DisorderedArray();
        // Delay dispose active/inActive Pool
        this._componentsContainerPool = [];
    }
    var _proto = ComponentsManager.prototype;
    _proto.addRenderer = function addRenderer(renderer) {
        renderer._rendererIndex = this._renderers.length;
        this._renderers.add(renderer);
    };
    _proto.removeRenderer = function removeRenderer(renderer) {
        var replaced = this._renderers.deleteByIndex(renderer._rendererIndex);
        replaced && (replaced._rendererIndex = renderer._rendererIndex);
        renderer._rendererIndex = -1;
    };
    _proto.addOnStartScript = function addOnStartScript(script) {
        script._onStartIndex = this._onStartScripts.length;
        this._onStartScripts.add(script);
    };
    _proto.removeOnStartScript = function removeOnStartScript(script) {
        var replaced = this._onStartScripts.deleteByIndex(script._onStartIndex);
        replaced && (replaced._onStartIndex = script._onStartIndex);
        script._onStartIndex = -1;
    };
    _proto.addOnUpdateScript = function addOnUpdateScript(script) {
        script._onUpdateIndex = this._onUpdateScripts.length;
        this._onUpdateScripts.add(script);
    };
    _proto.removeOnUpdateScript = function removeOnUpdateScript(script) {
        var replaced = this._onUpdateScripts.deleteByIndex(script._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = script._onUpdateIndex);
        script._onUpdateIndex = -1;
    };
    _proto.addOnLateUpdateScript = function addOnLateUpdateScript(script) {
        script._onLateUpdateIndex = this._onLateUpdateScripts.length;
        this._onLateUpdateScripts.add(script);
    };
    _proto.removeOnLateUpdateScript = function removeOnLateUpdateScript(script) {
        var replaced = this._onLateUpdateScripts.deleteByIndex(script._onLateUpdateIndex);
        replaced && (replaced._onLateUpdateIndex = script._onLateUpdateIndex);
        script._onLateUpdateIndex = -1;
    };
    _proto.addOnPhysicsUpdateScript = function addOnPhysicsUpdateScript(script) {
        script._onPhysicsUpdateIndex = this._onPhysicsUpdateScripts.length;
        this._onPhysicsUpdateScripts.add(script);
    };
    _proto.removeOnPhysicsUpdateScript = function removeOnPhysicsUpdateScript(script) {
        var replaced = this._onPhysicsUpdateScripts.deleteByIndex(script._onPhysicsUpdateIndex);
        replaced && (replaced._onPhysicsUpdateIndex = script._onPhysicsUpdateIndex);
        script._onPhysicsUpdateIndex = -1;
    };
    _proto.addOnUpdateAnimations = function addOnUpdateAnimations(animation) {
        //@ts-ignore
        animation._onUpdateIndex = this._onUpdateAnimations.length;
        this._onUpdateAnimations.add(animation);
    };
    _proto.removeOnUpdateAnimations = function removeOnUpdateAnimations(animation) {
        //@ts-ignore
        var replaced = this._onUpdateAnimations.deleteByIndex(animation._onUpdateIndex);
        //@ts-ignore
        replaced && (replaced._onUpdateIndex = animation._onUpdateIndex);
        //@ts-ignore
        animation._onUpdateIndex = -1;
    };
    _proto.addOnUpdateRenderers = function addOnUpdateRenderers(renderer) {
        renderer._onUpdateIndex = this._onUpdateRenderers.length;
        this._onUpdateRenderers.add(renderer);
    };
    _proto.removeOnUpdateRenderers = function removeOnUpdateRenderers(renderer) {
        var replaced = this._onUpdateRenderers.deleteByIndex(renderer._onUpdateIndex);
        replaced && (replaced._onUpdateIndex = renderer._onUpdateIndex);
        renderer._onUpdateIndex = -1;
    };
    _proto.addDisableScript = function addDisableScript(component) {
        this._disableScripts.push(component);
    };
    _proto.addPendingDestroyScript = function addPendingDestroyScript(component) {
        this._pendingDestroyScripts.push(component);
    };
    _proto.callScriptOnStart = function callScriptOnStart() {
        var onStartScripts = this._onStartScripts;
        if (onStartScripts.length > 0) {
            var elements = onStartScripts._elements;
            // The 'onStartScripts.length' maybe add if you add some Script with addComponent() in some Script's onStart()
            for(var i = 0; i < onStartScripts.length; i++){
                var script = elements[i];
                if (!script._waitHandlingInValid) {
                    script._started = true;
                    script._onStartIndex = -1;
                    script.onStart();
                }
            }
            onStartScripts.length = 0;
        }
    };
    _proto.callScriptOnUpdate = function callScriptOnUpdate(deltaTime) {
        var elements = this._onUpdateScripts._elements;
        for(var i = this._onUpdateScripts.length - 1; i >= 0; --i){
            var element = elements[i];
            if (!element._waitHandlingInValid && element._started) {
                element.onUpdate(deltaTime);
            }
        }
    };
    _proto.callScriptOnLateUpdate = function callScriptOnLateUpdate(deltaTime) {
        var elements = this._onLateUpdateScripts._elements;
        for(var i = this._onLateUpdateScripts.length - 1; i >= 0; --i){
            var element = elements[i];
            if (!element._waitHandlingInValid && element._started) {
                element.onLateUpdate(deltaTime);
            }
        }
    };
    _proto.callScriptOnPhysicsUpdate = function callScriptOnPhysicsUpdate() {
        var elements = this._onPhysicsUpdateScripts._elements;
        for(var i = this._onPhysicsUpdateScripts.length - 1; i >= 0; --i){
            var element = elements[i];
            if (!element._waitHandlingInValid && element._started) {
                element.onPhysicsUpdate();
            }
        }
    };
    _proto.callAnimationUpdate = function callAnimationUpdate(deltaTime) {
        var elements = this._onUpdateAnimations._elements;
        for(var i = this._onUpdateAnimations.length - 1; i >= 0; --i){
            //@ts-ignore
            elements[i].update(deltaTime);
        }
    };
    _proto.callRendererOnUpdate = function callRendererOnUpdate(deltaTime) {
        var elements = this._onUpdateRenderers._elements;
        for(var i = this._onUpdateRenderers.length - 1; i >= 0; --i){
            elements[i].update(deltaTime);
        }
    };
    _proto.handlingInvalidScripts = function handlingInvalidScripts() {
        var _this = this, disableScripts = _this._disableScripts;
        var length = disableScripts.length;
        if (length > 0) {
            for(var i = length - 1; i >= 0; i--){
                var disableScript = disableScripts[i];
                disableScript._waitHandlingInValid && disableScript._handlingInValid();
            }
            disableScripts.length = 0;
        }
        var _this1 = this, pendingDestroyScripts = _this1._disposeDestroyScripts, disposeDestroyScripts = _this1._pendingDestroyScripts;
        this._disposeDestroyScripts = disposeDestroyScripts;
        this._pendingDestroyScripts = pendingDestroyScripts;
        length = disposeDestroyScripts.length;
        if (length > 0) {
            for(var i1 = length - 1; i1 >= 0; i1--){
                disposeDestroyScripts[i1].onDestroy();
            }
            disposeDestroyScripts.length = 0;
        }
    };
    _proto.callCameraOnBeginRender = function callCameraOnBeginRender(camera) {
        var scripts = camera.entity._scripts;
        for(var i = scripts.length - 1; i >= 0; --i){
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onBeginRender(camera);
        }
    };
    _proto.callCameraOnEndRender = function callCameraOnEndRender(camera) {
        var scripts = camera.entity._scripts;
        for(var i = scripts.length - 1; i >= 0; --i){
            var script = scripts.get(i);
            script._waitHandlingInValid || script.onEndRender(camera);
        }
    };
    _proto.getActiveChangedTempList = function getActiveChangedTempList() {
        return this._componentsContainerPool.length ? this._componentsContainerPool.pop() : [];
    };
    _proto.putActiveChangedTempList = function putActiveChangedTempList(componentContainer) {
        componentContainer.length = 0;
        this._componentsContainerPool.push(componentContainer);
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._renderers.garbageCollection();
        this._onStartScripts.garbageCollection();
        this._onUpdateScripts.garbageCollection();
        this._onLateUpdateScripts.garbageCollection();
        this._onPhysicsUpdateScripts.garbageCollection();
        this._onUpdateAnimations.garbageCollection();
        this._onUpdateRenderers.garbageCollection();
    };
    return ComponentsManager;
}();

/**
 * The base class of the components.
 */ var Component = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Component, EngineObject);
    function Component(entity) {
        var _this;
        _this = EngineObject.call(this, entity.engine) || this;
        /** @internal */ _this._awoken = false;
        _this._phasedActive = false;
        _this._enabled = true;
        _this._entity = entity;
        return _this;
    }
    var _proto = Component.prototype;
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {};
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {};
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {};
    /**
   * @internal
   */ _proto._setActive = function _setActive(value) {
        var entity = this._entity;
        if (value) {
            // Awake condition is un awake && current entity is active in hierarchy
            if (!this._awoken && entity._isActiveInHierarchy) {
                this._awoken = true;
                this._onAwake();
            }
            // Developer maybe do `isActive = false` in `onAwake` method
            // Enable condition is phased active state is false && current component is active in hierarchy
            if (!this._phasedActive && entity._isActiveInHierarchy && this._enabled) {
                this._phasedActive = true;
                this._onEnable();
            }
        } else {
            // Disable condition is phased active state is true && current compoment is inActive in hierarchy
            if (this._phasedActive && !(entity._isActiveInHierarchy && this._enabled)) {
                this._phasedActive = false;
                this._onDisable();
            }
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        EngineObject.prototype._onDestroy.call(this);
        this._entity._removeComponent(this);
        if (this._entity.isActiveInHierarchy) {
            this._enabled && this._onDisable();
        }
    };
    _create_class$3(Component, [
        {
            key: "enabled",
            get: /**
   * Indicates whether the component is enabled.
   */ function get() {
                return this._enabled;
            },
            set: function set(value) {
                if (value !== this._enabled) {
                    this._enabled = value;
                    if (this._entity.isActiveInHierarchy) {
                        if (value) {
                            this._phasedActive = true;
                            this._onEnable();
                        } else {
                            this._phasedActive = false;
                            this._onDisable();
                        }
                    }
                }
            }
        },
        {
            key: "entity",
            get: /**
   * The entity which the component belongs to.
   */ function get() {
                return this._entity;
            }
        },
        {
            key: "scene",
            get: /**
   * The scene which the component's entity belongs to.
   */ function get() {
                return this._entity.scene;
            }
        }
    ]);
    return Component;
}(EngineObject);
__decorate$1([
    ignoreClone
], Component.prototype, "_entity", void 0);
__decorate$1([
    ignoreClone
], Component.prototype, "_awoken", void 0);
__decorate$1([
    ignoreClone
], Component.prototype, "_phasedActive", void 0);
__decorate$1([
    assignmentClone
], Component.prototype, "_enabled", void 0);

/**
 * @internal
 * Used for component dependency registration.
 */ var ComponentsDependencies = /*#__PURE__*/ function() {
    function ComponentsDependencies() {}
    /**
   * @internal
   */ ComponentsDependencies._addCheck = function _addCheck(entity, type) {
        while(type !== Component){
            var dependentInfo = ComponentsDependencies._dependenciesMap.get(type);
            if (dependentInfo) {
                var components = dependentInfo.components, mode = dependentInfo.mode;
                for(var i = 0, n = components.length; i < n; i++){
                    var dependentComponent = components[i];
                    if (!entity.getComponent(dependentComponent)) {
                        if (mode === /** Auto add if dependent components do not exist. */ 1) {
                            entity.addComponent(dependentComponent);
                        } else {
                            throw "Should add " + dependentComponent.name + " before adding " + type.name;
                        }
                    }
                }
            }
            type = Object.getPrototypeOf(type);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._removeCheck = function _removeCheck(entity, type) {
        while(type !== Component){
            var invDependencies = ComponentsDependencies._invDependenciesMap.get(type);
            if (invDependencies) {
                for(var i = 0, len = invDependencies.length; i < len; i++){
                    if (entity.getComponent(invDependencies[i])) {
                        throw "Should remove " + invDependencies[i].name + " before adding " + type.name;
                    }
                }
            }
            type = Object.getPrototypeOf(type);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._addDependency = function _addDependency(targetInfo, dependentComponent, map) {
        var components = map.get(targetInfo);
        if (!components) {
            map.set(targetInfo, [
                dependentComponent
            ]);
        } else {
            components.includes(dependentComponent) || components.push(dependentComponent);
        }
    };
    /**
   * @internal
   */ ComponentsDependencies._addInvDependency = function _addInvDependency(currentComponent, dependentComponent) {
        var map = this._invDependenciesMap;
        var components = map.get(currentComponent);
        if (!components) {
            map.set(currentComponent, [
                dependentComponent
            ]);
        } else {
            components.includes(dependentComponent) || components.push(dependentComponent);
        }
    };
    return ComponentsDependencies;
}();
(function() {
    ComponentsDependencies._invDependenciesMap = new Map();
})();
(function() {
    ComponentsDependencies._dependenciesMap = new Map();
})();
function dependentComponents(componentOrComponents, dependentMode) {
    if (dependentMode === void 0) dependentMode = /** Check only, throw error if dependent components do not exist. */ 0;
    var components = Array.isArray(componentOrComponents) ? componentOrComponents : [
        componentOrComponents
    ];
    return function(target) {
        ComponentsDependencies._dependenciesMap.set(target, {
            mode: dependentMode,
            components: components
        });
        components.forEach(function(component) {
            return ComponentsDependencies._addInvDependency(component, target);
        });
    };
}
var DependentMode;
(function(DependentMode) {
    DependentMode[DependentMode["CheckOnly"] = 0] = "CheckOnly";
    DependentMode[DependentMode["AutoAdd"] = 1] = "AutoAdd";
})(DependentMode || (DependentMode = {}));

/**
 * Layer, used for bit operations.
 */ var Layer;
(function(Layer) {
    Layer[Layer[/** Layer 0. */ "Layer0"] = 0x1] = "Layer0";
    Layer[Layer[/** Layer 1. */ "Layer1"] = 0x2] = "Layer1";
    Layer[Layer[/** Layer 2. */ "Layer2"] = 0x4] = "Layer2";
    Layer[Layer[/** Layer 3. */ "Layer3"] = 0x8] = "Layer3";
    Layer[Layer[/** Layer 4. */ "Layer4"] = 0x10] = "Layer4";
    Layer[Layer[/** Layer 5. */ "Layer5"] = 0x20] = "Layer5";
    Layer[Layer[/** Layer 6. */ "Layer6"] = 0x40] = "Layer6";
    Layer[Layer[/** Layer 7. */ "Layer7"] = 0x80] = "Layer7";
    Layer[Layer[/** Layer 8. */ "Layer8"] = 0x100] = "Layer8";
    Layer[Layer[/** Layer 9. */ "Layer9"] = 0x200] = "Layer9";
    Layer[Layer[/** Layer 10. */ "Layer10"] = 0x400] = "Layer10";
    Layer[Layer[/** Layer 11. */ "Layer11"] = 0x800] = "Layer11";
    Layer[Layer[/** Layer 12. */ "Layer12"] = 0x1000] = "Layer12";
    Layer[Layer[/** Layer 13. */ "Layer13"] = 0x2000] = "Layer13";
    Layer[Layer[/** Layer 14. */ "Layer14"] = 0x4000] = "Layer14";
    Layer[Layer[/** Layer 15. */ "Layer15"] = 0x8000] = "Layer15";
    Layer[Layer[/** Layer 16. */ "Layer16"] = 0x10000] = "Layer16";
    Layer[Layer[/** Layer 17. */ "Layer17"] = 0x20000] = "Layer17";
    Layer[Layer[/** Layer 18. */ "Layer18"] = 0x40000] = "Layer18";
    Layer[Layer[/** Layer 19. */ "Layer19"] = 0x80000] = "Layer19";
    Layer[Layer[/** Layer 20. */ "Layer20"] = 0x100000] = "Layer20";
    Layer[Layer[/** Layer 21. */ "Layer21"] = 0x200000] = "Layer21";
    Layer[Layer[/** Layer 22. */ "Layer22"] = 0x400000] = "Layer22";
    Layer[Layer[/** Layer 23. */ "Layer23"] = 0x800000] = "Layer23";
    Layer[Layer[/** Layer 24. */ "Layer24"] = 0x1000000] = "Layer24";
    Layer[Layer[/** Layer 25. */ "Layer25"] = 0x2000000] = "Layer25";
    Layer[Layer[/** Layer 26. */ "Layer26"] = 0x4000000] = "Layer26";
    Layer[Layer[/** Layer 27. */ "Layer27"] = 0x8000000] = "Layer27";
    Layer[Layer[/** Layer 28. */ "Layer28"] = 0x10000000] = "Layer28";
    Layer[Layer[/** Layer 29. */ "Layer29"] = 0x20000000] = "Layer29";
    Layer[Layer[/** Layer 30. */ "Layer30"] = 0x40000000] = "Layer30";
    Layer[Layer[/** Layer 31. */ "Layer31"] = 0x80000000] = "Layer31";
    Layer[Layer[/** All layers. */ "Everything"] = 0xffffffff] = "Everything";
    Layer[Layer[/** None layer. */ "Nothing"] = 0x0] = "Nothing";
})(Layer || (Layer = {}));

var Utils = /*#__PURE__*/ function() {
    function Utils() {}
    /**
   * @internal
   */ Utils._floatMatrixMultiply = function _floatMatrixMultiply(left, re, rOffset, oe, offset) {
        var le = left.elements;
        // prettier-ignore
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3], l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7], l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11], l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        // prettier-ignore
        var r11 = re[rOffset], r12 = re[rOffset + 1], r13 = re[rOffset + 2], r14 = re[rOffset + 3], r21 = re[rOffset + 4], r22 = re[rOffset + 5], r23 = re[rOffset + 6], r24 = re[rOffset + 7], r31 = re[rOffset + 8], r32 = re[rOffset + 9], r33 = re[rOffset + 10], r34 = re[rOffset + 11], r41 = re[rOffset + 12], r42 = re[rOffset + 13], r43 = re[rOffset + 14], r44 = re[rOffset + 15];
        oe[offset] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[offset + 1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[offset + 2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[offset + 3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[offset + 4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[offset + 5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[offset + 6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[offset + 7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[offset + 8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[offset + 9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[offset + 10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[offset + 11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[offset + 12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[offset + 13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[offset + 14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[offset + 15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    };
    /**
   * @internal
   * Simplify lodash get: https://github.com/lodash/lodash/blob/master/get.js.
   * @param target - The object to query.
   * @param path - The path of the property to get.
   * @returns Returns the resolved value.
   */ Utils._reflectGet = function _reflectGet(target, path) {
        var pathArr = this._stringToPath(path);
        var object = target;
        var index = 0;
        var length = pathArr.length;
        while(object != null && index < length){
            object = object[pathArr[index++]];
        }
        return index && index == length ? object : undefined;
    };
    /**
   * Fast remove an element from array.
   * @param array - Array
   * @param item - Element
   */ Utils.removeFromArray = function removeFromArray(array, item) {
        var index = array.indexOf(item);
        if (index < 0) {
            return false;
        }
        var last = array.length - 1;
        if (index !== last) {
            var end = array[last];
            array[index] = end;
        }
        array.length--;
        return true;
    };
    /**
   * Decodes a given Uint8Array into a string.
   */ Utils.decodeText = function decodeText(array) {
        if (typeof PlatformManager$1.polyfill.TextDecoder !== "undefined") {
            return new PlatformManager$1.polyfill.TextDecoder().decode(array);
        }
        // TextDecoder polyfill
        var s = "";
        for(var i = 0, il = array.length; i < il; i++){
            s += String.fromCharCode(array[i]);
        }
        return decodeURIComponent(encodeURIComponent(s));
    };
    /**
   * Judge whether the url is absolute url.
   * @param url - The url to be judged.
   * @returns Whether the url is absolute url.
   */ Utils.isAbsoluteUrl = function isAbsoluteUrl(url) {
        return /^(?:http|blob|data:|\/)/.test(url);
    };
    /**
   * Get the values of an object.
   */ Utils.objectValues = function objectValues(obj) {
        return Object.keys(obj).map(function(key) {
            return obj[key];
        });
    };
    /**
   * Convert a relative URL to an absolute URL based on a given base URL.
   * @param baseUrl - The base url.
   * @param relativeUrl - The relative url.
   * @returns The resolved url.
   */ Utils.resolveAbsoluteUrl = function resolveAbsoluteUrl(baseUrl, relativeUrl) {
        if (Utils.isAbsoluteUrl(relativeUrl)) {
            return relativeUrl;
        }
        var char0 = relativeUrl.charAt(0);
        if (char0 === ".") {
            return Utils._formatRelativePath(relativeUrl + relativeUrl);
        }
        return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + relativeUrl;
    };
    Utils._stringToPath = function _stringToPath(string) {
        var result = [];
        if (string.charCodeAt(0) === charCodeOfDot) {
            result.push("");
        }
        string.replace(rePropName, function(match, expression, quote, subString) {
            var key = match;
            if (quote) {
                key = subString.replace(reEscapeChar, "$1");
            } else if (expression) {
                key = expression.trim();
            }
            result.push(key);
        });
        return result;
    };
    Utils._formatRelativePath = function _formatRelativePath(value) {
        var parts = value.split("/");
        for(var i = 0, n = parts.length; i < n; i++){
            if (parts[i] == "..") {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return parts.join("/");
    };
    return Utils;
}();
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar = /\\(\\)?/g;
var rePropName = RegExp(// Match anything that isn't a dot or bracket.
"[^.[\\]]+" + "|" + // Or match property names within brackets.
"\\[(?:" + // Match a non-string expression.
"([^\"'][^[]*)" + "|" + // Or match strings (supports escaping characters).
"([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2" + ")\\]" + "|" + // Or match "" as the space between consecutive dots or empty brackets.
"(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))", "g");

/**
 * Used to update tags.
 */ var UpdateFlag = /*#__PURE__*/ function() {
    function UpdateFlag() {
        /** @internal */ this._flagManagers = [];
    }
    var _proto = UpdateFlag.prototype;
    /**
   * Clear.
   */ _proto.clearFromManagers = function clearFromManagers() {
        this._removeFromManagers();
        this._flagManagers.length = 0;
    };
    /**
   * Destroy.
   */ _proto.destroy = function destroy() {
        this._removeFromManagers();
        this._flagManagers = null;
    };
    _proto._removeFromManagers = function _removeFromManagers() {
        var flagManagers = this._flagManagers;
        for(var i = 0, n = flagManagers.length; i < n; i++){
            Utils.removeFromArray(flagManagers[i]._updateFlags, this);
        }
    };
    return UpdateFlag;
}();

/**
 * Bool update flag.
 */ var BoolUpdateFlag = /*#__PURE__*/ function(UpdateFlag) {
    _inherits$2(BoolUpdateFlag, UpdateFlag);
    function BoolUpdateFlag() {
        var _this;
        _this = UpdateFlag.apply(this, arguments) || this;
        /** Bool flag. */ _this.flag = true;
        return _this;
    }
    var _proto = BoolUpdateFlag.prototype;
    /**
   * @inheritdoc
   */ _proto.dispatch = function dispatch() {
        this.flag = true;
    };
    return BoolUpdateFlag;
}(UpdateFlag);

/**
 * @internal
 */ var UpdateFlagManager = /*#__PURE__*/ function() {
    function UpdateFlagManager() {
        /** @internal */ this._updateFlags = [];
        this._listeners = [];
    }
    var _proto = UpdateFlagManager.prototype;
    /**
   * Create a UpdateFlag.
   * @returns - The UpdateFlag.
   */ _proto.createFlag = function createFlag(type) {
        var flag = new type();
        this.addFlag(flag);
        return flag;
    };
    /**
   * Add a UpdateFlag.
   * @param flag - The UpdateFlag.
   */ _proto.addFlag = function addFlag(flag) {
        this._updateFlags.push(flag);
        flag._flagManagers.push(this);
    };
    /**
   * Remove a UpdateFlag.
   * @param flag - The UpdateFlag.
   */ _proto.removeFlag = function removeFlag(flag) {
        var success = Utils.removeFromArray(this._updateFlags, flag);
        if (success) {
            Utils.removeFromArray(flag._flagManagers, this);
        }
    };
    /**
   * Add a listener.
   * @param listener - The listener
   */ _proto.addListener = function addListener(listener) {
        this._listeners.push(listener);
    };
    /**
   * Remove a listener.
   * @param listener - The listener
   */ _proto.removeListener = function removeListener(listener) {
        Utils.removeFromArray(this._listeners, listener);
    };
    /**
   * Dispatch a event.
   * @param type - Event type, usually in the form of enumeration
   * @param param - Event param
   */ _proto.dispatch = function dispatch(type, param) {
        var updateFlags = this._updateFlags;
        for(var i = updateFlags.length - 1; i >= 0; i--){
            updateFlags[i].dispatch(type, param);
        }
        var listeners = this._listeners;
        for(var i1 = listeners.length - 1; i1 >= 0; i1--){
            listeners[i1](type, param);
        }
    };
    return UpdateFlagManager;
}();

/**
 * Used to implement transformation related functions.
 */ var Transform = /*#__PURE__*/ function(Component) {
    _inherits$2(Transform, Component);
    function Transform(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        _this._position = new Vector3();
        _this._rotation = new Vector3();
        _this._rotationQuaternion = new Quaternion();
        _this._scale = new Vector3(1, 1, 1);
        _this._worldPosition = new Vector3();
        _this._worldRotation = new Vector3();
        _this._worldRotationQuaternion = new Quaternion();
        _this._lossyWorldScale = new Vector3(1, 1, 1);
        _this._localMatrix = new Matrix();
        _this._worldMatrix = new Matrix();
        _this._worldForward = null;
        _this._worldRight = null;
        _this._worldUp = null;
        _this._isParentDirty = true;
        _this._parentTransformCache = null;
        _this._dirtyFlag = 0xbc;
        /** @internal */ _this._updateFlagManager = new UpdateFlagManager();
        _this._onPositionChanged = _this._onPositionChanged.bind(_assert_this_initialized(_this));
        _this._onWorldPositionChanged = _this._onWorldPositionChanged.bind(_assert_this_initialized(_this));
        _this._onRotationChanged = _this._onRotationChanged.bind(_assert_this_initialized(_this));
        _this._onWorldRotationChanged = _this._onWorldRotationChanged.bind(_assert_this_initialized(_this));
        _this._onRotationQuaternionChanged = _this._onRotationQuaternionChanged.bind(_assert_this_initialized(_this));
        _this._onWorldRotationQuaternionChanged = _this._onWorldRotationQuaternionChanged.bind(_assert_this_initialized(_this));
        _this._onScaleChanged = _this._onScaleChanged.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._position._onValueChanged = _this._onPositionChanged;
        //@ts-ignore
        _this._worldPosition._onValueChanged = _this._onWorldPositionChanged;
        //@ts-ignore
        _this._rotation._onValueChanged = _this._onRotationChanged;
        //@ts-ignore
        _this._worldRotation._onValueChanged = _this._onWorldRotationChanged;
        //@ts-ignore
        _this._rotationQuaternion._onValueChanged = _this._onRotationQuaternionChanged;
        //@ts-ignore
        _this._worldRotationQuaternion._onValueChanged = _this._onWorldRotationQuaternionChanged;
        //@ts-ignore
        _this._scale._onValueChanged = _this._onScaleChanged;
        return _this;
    }
    var _proto = Transform.prototype;
    /**
   * Set local position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */ _proto.setPosition = function setPosition(x, y, z) {
        this._position.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z components of the euler angle, unit in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */ _proto.setRotation = function setRotation(x, y, z) {
        this._rotation.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */ _proto.setRotationQuaternion = function setRotationQuaternion(x, y, z, w) {
        this._rotationQuaternion.set(x, y, z, w);
    };
    /**
   * Set local scaling by scaling values along X, Y, Z axis.
   * @param x - Scaling along X axis
   * @param y - Scaling along Y axis
   * @param z - Scaling along Z axis
   */ _proto.setScale = function setScale(x, y, z) {
        this._scale.set(x, y, z);
    };
    /**
   * Set world position by X, Y, Z value.
   * @param x - X coordinate
   * @param y - Y coordinate
   * @param z - Z coordinate
   */ _proto.setWorldPosition = function setWorldPosition(x, y, z) {
        this._worldPosition.set(x, y, z);
    };
    /**
   * Set world rotation by the X, Y, Z components of the euler angle, unit in degrees, Yaw/Pitch/Roll sequence.
   * @param x - The angle of rotation around the X axis
   * @param y - The angle of rotation around the Y axis
   * @param z - The angle of rotation around the Z axis
   */ _proto.setWorldRotation = function setWorldRotation(x, y, z) {
        this._worldRotation.set(x, y, z);
    };
    /**
   * Set local rotation by the X, Y, Z, and W components of the quaternion.
   * @param x - X component of quaternion
   * @param y - Y component of quaternion
   * @param z - Z component of quaternion
   * @param w - W component of quaternion
   */ _proto.setWorldRotationQuaternion = function setWorldRotationQuaternion(x, y, z, w) {
        this._worldRotationQuaternion.set(x, y, z, w);
    };
    _proto.translate = function translate(translationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof translationOrX === "number") {
            var translate = Transform._tempVec30;
            translate.set(translationOrX, relativeToLocalOrY, z);
            this._translate(translate, relativeToLocal);
        } else {
            this._translate(translationOrX, relativeToLocalOrY);
        }
    };
    _proto.rotate = function rotate(rotationOrX, relativeToLocalOrY, z, relativeToLocal) {
        if (typeof rotationOrX === "number") {
            this._rotateXYZ(rotationOrX, relativeToLocalOrY, z, relativeToLocal);
        } else {
            this._rotateXYZ(rotationOrX.x, rotationOrX.y, rotationOrX.z, relativeToLocalOrY);
        }
    };
    /**
   * Rotate around the specified axis according to the specified angle.
   * @param axis - Rotate axis
   * @param angle - Rotate angle in degrees
   * @param relativeToLocal = `true` - Relative to local space
   */ _proto.rotateByAxis = function rotateByAxis(axis, angle, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        var rad = angle * MathUtil$1.degreeToRadFactor;
        Quaternion.rotationAxisAngle(axis, rad, Transform._tempQuat0);
        this._rotateByQuat(Transform._tempQuat0, relativeToLocal);
    };
    /**
   * Rotate and ensure that the world front vector points to the target world position.
   * @param targetPosition - Target world position
   * @param worldUp - Up direction in world space, default is Vector3(0, 1, 0)
   */ _proto.lookAt = function lookAt(targetPosition, worldUp) {
        var zAxis = Transform._tempVec30;
        Vector3.subtract(this.worldPosition, targetPosition, zAxis);
        var axisLen = zAxis.length();
        if (axisLen <= MathUtil$1.zeroTolerance) {
            // The current position and the target position are almost the same.
            return;
        }
        zAxis.scale(1 / axisLen);
        var xAxis = Transform._tempVec31;
        if (worldUp) {
            Vector3.cross(worldUp, zAxis, xAxis);
        } else {
            xAxis.set(zAxis.z, 0, -zAxis.x);
        }
        axisLen = xAxis.length();
        if (axisLen <= MathUtil$1.zeroTolerance) {
            // @todo:
            // 1.worldUp isï¼ˆ0,0,0ï¼‰
            // 2.worldUp is parallel to zAxis
            return;
        }
        xAxis.scale(1 / axisLen);
        var yAxis = Transform._tempVec32;
        Vector3.cross(zAxis, xAxis, yAxis);
        var rotMat = Transform._tempMat41;
        var e = rotMat.elements;
        e[0] = xAxis.x, e[1] = xAxis.y, e[2] = xAxis.z;
        e[4] = yAxis.x, e[5] = yAxis.y, e[6] = yAxis.z;
        e[8] = zAxis.x, e[9] = zAxis.y, e[10] = zAxis.z;
        rotMat.getRotation(this._worldRotationQuaternion);
    };
    /**
   * Register world transform change flag.
   * @returns Change flag
   */ _proto.registerWorldChangeFlag = function registerWorldChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
    };
    /**
   * @internal
   */ _proto._parentChange = function _parentChange() {
        this._isParentDirty = true;
        this._updateAllWorldFlag();
    };
    /**
   * @internal
   */ _proto._isFrontFaceInvert = function _isFrontFaceInvert() {
        var scale = this.lossyWorldScale;
        var isInvert = scale.x < 0;
        scale.y < 0 && (isInvert = !isInvert);
        scale.z < 0 && (isInvert = !isInvert);
        return isInvert;
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */ _proto._updateWorldPositionFlag = function _updateWorldPositionFlag() {
        if (!this._isContainDirtyFlags(0x84)) {
            this._worldAssociatedChange(0x84);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionFlag();
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */ _proto._updateWorldRotationFlag = function _updateWorldRotationFlag() {
        if (!this._isContainDirtyFlags(0x98)) {
            this._worldAssociatedChange(0x98);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndRotationFlag(); // Rotation update of parent entity will trigger world position and rotation update of all child entity.
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldRotationQuaternion: Will trigger the world rotation (in quaternion) update of itself and all parent entities.
   * Get worldRotation: Will trigger the world rotation(in euler and quaternion) update of itself and world rotation(in quaternion) update of all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix or worldRotationQuaternion) to be false.
   */ _proto._updateWorldPositionAndRotationFlag = function _updateWorldPositionAndRotationFlag() {
        if (!this._isContainDirtyFlags(0x9c)) {
            this._worldAssociatedChange(0x9c);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndRotationFlag();
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */ _proto._updateWorldScaleFlag = function _updateWorldScaleFlag() {
        if (!this._isContainDirtyFlags(0xa0)) {
            this._worldAssociatedChange(0xa0);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndScaleFlag();
            }
        }
    };
    /**
   * Get worldMatrix: Will trigger the worldMatrix update of itself and all parent entities.
   * Get worldPosition: Will trigger the worldMatrix, local position update of itself and the worldMatrix update of all parent entities.
   * Get worldScale: Will trigger the scaling update of itself and all parent entities.
   * In summary, any update of related variables will cause the dirty mark of one of the full process (worldMatrix) to be false.
   */ _proto._updateWorldPositionAndScaleFlag = function _updateWorldPositionAndScaleFlag() {
        if (!this._isContainDirtyFlags(0xa4)) {
            this._worldAssociatedChange(0xa4);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateWorldPositionAndScaleFlag();
            }
        }
    };
    /**
   * Update all world transform property dirty flag, the principle is the same as above.
   */ _proto._updateAllWorldFlag = function _updateAllWorldFlag() {
        if (!this._isContainDirtyFlags(0xbc)) {
            this._worldAssociatedChange(0xbc);
            var nodeChildren = this._entity._children;
            for(var i = 0, n = nodeChildren.length; i < n; i++){
                var _nodeChildren_i_transform;
                (_nodeChildren_i_transform = nodeChildren[i].transform) == null ? void 0 : _nodeChildren_i_transform._updateAllWorldFlag();
            }
        }
    };
    _proto._getParentTransform = function _getParentTransform() {
        if (!this._isParentDirty) {
            return this._parentTransformCache;
        }
        var parentCache = null;
        var parent = this._entity.parent;
        while(parent){
            var transform = parent.transform;
            if (transform) {
                parentCache = transform;
                break;
            } else {
                parent = parent.parent;
            }
        }
        this._parentTransformCache = parentCache;
        this._isParentDirty = false;
        return parentCache;
    };
    _proto._getScaleMatrix = function _getScaleMatrix() {
        var invRotation = Transform._tempQuat0;
        var invRotationMat = Transform._tempMat30;
        var worldRotScaMat = Transform._tempMat31;
        var scaMat = Transform._tempMat32;
        worldRotScaMat.copyFromMatrix(this.worldMatrix);
        Quaternion.invert(this.worldRotationQuaternion, invRotation);
        Matrix3x3.rotationQuaternion(invRotation, invRotationMat);
        Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
        return scaMat;
    };
    _proto._isContainDirtyFlags = function _isContainDirtyFlags(targetDirtyFlags) {
        return (this._dirtyFlag & targetDirtyFlags) === targetDirtyFlags;
    };
    _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
    };
    _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
    };
    _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
    };
    _proto._worldAssociatedChange = function _worldAssociatedChange(type) {
        this._dirtyFlag |= type;
        this._updateFlagManager.dispatch(0x80);
    };
    _proto._rotateByQuat = function _rotateByQuat(rotateQuat, relativeToLocal) {
        if (relativeToLocal) {
            Quaternion.multiply(this.rotationQuaternion, rotateQuat, this._rotationQuaternion);
        } else {
            Quaternion.multiply(rotateQuat, this.worldRotationQuaternion, this._worldRotationQuaternion);
        }
    };
    _proto._translate = function _translate(translation, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        if (relativeToLocal) {
            var _tempVec30 = Transform._tempVec30;
            Vector3.transformByQuat(translation, this.worldRotationQuaternion, _tempVec30);
            this._worldPosition.add(_tempVec30);
        } else {
            this._worldPosition.add(translation);
        }
    };
    _proto._rotateXYZ = function _rotateXYZ(x, y, z, relativeToLocal) {
        if (relativeToLocal === void 0) relativeToLocal = true;
        var radFactor = MathUtil$1.degreeToRadFactor;
        var rotQuat = Transform._tempQuat0;
        Quaternion.rotationEuler(x * radFactor, y * radFactor, z * radFactor, rotQuat);
        this._rotateByQuat(rotQuat, relativeToLocal);
    };
    _proto._onPositionChanged = function _onPositionChanged() {
        this._setDirtyFlagTrue(0x40);
        this._updateWorldPositionFlag();
    };
    _proto._onWorldPositionChanged = function _onWorldPositionChanged() {
        var worldPosition = this._worldPosition;
        var parent = this._getParentTransform();
        if (parent) {
            Matrix.invert(parent.worldMatrix, Transform._tempMat41);
            Vector3.transformCoordinate(worldPosition, Transform._tempMat41, this._position);
        } else {
            this._position.copyFrom(worldPosition);
        }
        this._setDirtyFlagFalse(0x4);
    };
    _proto._onRotationChanged = function _onRotationChanged() {
        this._setDirtyFlagTrue(0x40 | 0x2);
        this._setDirtyFlagFalse(0x1);
        this._updateWorldRotationFlag();
    };
    _proto._onWorldRotationChanged = function _onWorldRotationChanged() {
        var worldRotation = this._worldRotation;
        Quaternion.rotationEuler(MathUtil$1.degreeToRadian(worldRotation.x), MathUtil$1.degreeToRadian(worldRotation.y), MathUtil$1.degreeToRadian(worldRotation.z), this._worldRotationQuaternion);
        this._setDirtyFlagFalse(0x8);
    };
    _proto._onRotationQuaternionChanged = function _onRotationQuaternionChanged() {
        this._setDirtyFlagTrue(0x40 | 0x1);
        this._setDirtyFlagFalse(0x2);
        this._updateWorldRotationFlag();
    };
    _proto._onWorldRotationQuaternionChanged = function _onWorldRotationQuaternionChanged() {
        var worldRotationQuaternion = this._worldRotationQuaternion;
        var parent = this._getParentTransform();
        if (parent) {
            var invParentQuaternion = Transform._tempQuat0;
            Quaternion.invert(parent.worldRotationQuaternion, invParentQuaternion);
            Quaternion.multiply(invParentQuaternion, worldRotationQuaternion, this._rotationQuaternion);
        } else {
            this._rotationQuaternion.copyFrom(worldRotationQuaternion);
        }
        this._setDirtyFlagFalse(0x10);
    };
    _proto._onScaleChanged = function _onScaleChanged() {
        this._setDirtyFlagTrue(0x40);
        this._updateWorldScaleFlag();
    };
    _create_class$3(Transform, [
        {
            key: "position",
            get: /**
   * Local position.
   */ function get() {
                return this._position;
            },
            set: function set(value) {
                if (this._position !== value) {
                    this._position.copyFrom(value);
                }
            }
        },
        {
            key: "worldPosition",
            get: /**
   * World position.
   */ function get() {
                var worldPosition = this._worldPosition;
                if (this._isContainDirtyFlag(0x4)) {
                    //@ts-ignore
                    worldPosition._onValueChanged = null;
                    if (this._getParentTransform()) {
                        this.worldMatrix.getTranslation(worldPosition);
                    } else {
                        worldPosition.copyFrom(this._position);
                    }
                    //@ts-ignore
                    worldPosition._onValueChanged = this._onWorldPositionChanged;
                    this._setDirtyFlagFalse(0x4);
                }
                return worldPosition;
            },
            set: function set(value) {
                if (this._worldPosition !== value) {
                    this._worldPosition.copyFrom(value);
                }
            }
        },
        {
            key: "rotation",
            get: /**
   * Local rotation, defining the rotation value in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   */ function get() {
                var rotation = this._rotation;
                if (this._isContainDirtyFlag(0x1)) {
                    //@ts-ignore
                    rotation._onValueChanged = null;
                    this._rotationQuaternion.toEuler(rotation);
                    rotation.scale(MathUtil$1.radToDegreeFactor); // radians to degrees
                    //@ts-ignore
                    rotation._onValueChanged = this._onRotationChanged;
                    this._setDirtyFlagFalse(0x1);
                }
                return rotation;
            },
            set: function set(value) {
                if (this._rotation !== value) {
                    this._rotation.copyFrom(value);
                }
            }
        },
        {
            key: "worldRotation",
            get: /**
   * World rotation, defining the rotation value in degrees.
   * Rotations are performed around the Y axis, the X axis, and the Z axis, in that order.
   */ function get() {
                var worldRotation = this._worldRotation;
                if (this._isContainDirtyFlag(0x8)) {
                    //@ts-ignore
                    worldRotation._onValueChanged = null;
                    this.worldRotationQuaternion.toEuler(worldRotation);
                    worldRotation.scale(MathUtil$1.radToDegreeFactor); // Radian to angle
                    //@ts-ignore
                    worldRotation._onValueChanged = this._onWorldRotationChanged;
                    this._setDirtyFlagFalse(0x8);
                }
                return worldRotation;
            },
            set: function set(value) {
                if (this._worldRotation !== value) {
                    this._worldRotation.copyFrom(value);
                }
            }
        },
        {
            key: "rotationQuaternion",
            get: /**
   * Local rotation, defining the rotation by using a unit quaternion.
   */ function get() {
                var rotationQuaternion = this._rotationQuaternion;
                if (this._isContainDirtyFlag(0x2)) {
                    //@ts-ignore
                    rotationQuaternion._onValueChanged = null;
                    Quaternion.rotationEuler(MathUtil$1.degreeToRadian(this._rotation.x), MathUtil$1.degreeToRadian(this._rotation.y), MathUtil$1.degreeToRadian(this._rotation.z), rotationQuaternion);
                    //@ts-ignore
                    rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
                    this._setDirtyFlagFalse(0x2);
                }
                return rotationQuaternion;
            },
            set: function set(value) {
                if (this._rotationQuaternion !== value) {
                    if (value.normalized) {
                        this._rotationQuaternion.copyFrom(value);
                    } else {
                        Quaternion.normalize(value, this._rotationQuaternion);
                    }
                } else {
                    value.normalized || value.normalize();
                }
            }
        },
        {
            key: "worldRotationQuaternion",
            get: /**
   * World rotation, defining the rotation by using a unit quaternion.
   */ function get() {
                var worldRotationQuaternion = this._worldRotationQuaternion;
                if (this._isContainDirtyFlag(0x10)) {
                    //@ts-ignore
                    worldRotationQuaternion._onValueChanged = null;
                    var parent = this._getParentTransform();
                    if (parent != null) {
                        Quaternion.multiply(parent.worldRotationQuaternion, this.rotationQuaternion, worldRotationQuaternion);
                    } else {
                        worldRotationQuaternion.copyFrom(this.rotationQuaternion);
                    }
                    //@ts-ignore
                    worldRotationQuaternion._onValueChanged = this._onWorldRotationQuaternionChanged;
                    this._setDirtyFlagFalse(0x10);
                }
                return worldRotationQuaternion;
            },
            set: function set(value) {
                if (this._worldRotationQuaternion !== value) {
                    if (value.normalized) {
                        this._worldRotationQuaternion.copyFrom(value);
                    } else {
                        Quaternion.normalize(value, this._worldRotationQuaternion);
                    }
                }
                value.normalized || value.normalize();
            }
        },
        {
            key: "scale",
            get: /**
   * Local scaling.
   */ function get() {
                return this._scale;
            },
            set: function set(value) {
                if (this._scale !== value) {
                    this._scale.copyFrom(value);
                }
            }
        },
        {
            key: "lossyWorldScale",
            get: /**
   * Local lossy scaling.
   * @remarks The value obtained may not be correct under certain conditions(for example, the parent node has scaling,
   * and the child node has a rotation), the scaling will be tilted. Vector3 cannot be used to correctly represent the scaling. Must use Matrix3x3.
   */ function get() {
                if (this._isContainDirtyFlag(0x20)) {
                    if (this._getParentTransform()) {
                        var scaleMat = this._getScaleMatrix();
                        var e = scaleMat.elements;
                        this._lossyWorldScale.set(e[0], e[4], e[8]);
                    } else {
                        this._lossyWorldScale.copyFrom(this._scale);
                    }
                    this._setDirtyFlagFalse(0x20);
                }
                return this._lossyWorldScale;
            }
        },
        {
            key: "localMatrix",
            get: /**
   * Local matrix.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                if (this._isContainDirtyFlag(0x40)) {
                    Matrix.affineTransformation(this._scale, this.rotationQuaternion, this._position, this._localMatrix);
                    this._setDirtyFlagFalse(0x40);
                }
                return this._localMatrix;
            },
            set: function set(value) {
                if (this._localMatrix !== value) {
                    this._localMatrix.copyFrom(value);
                }
                // @ts-ignore
                this._position._onValueChanged = this._rotationQuaternion._onValueChanged = this._scale._onValueChanged = null;
                this._localMatrix.decompose(this._position, this._rotationQuaternion, this._scale);
                // @ts-ignore
                this._position._onValueChanged = this._onPositionChanged;
                // @ts-ignore
                this._rotationQuaternion._onValueChanged = this._onRotationQuaternionChanged;
                // @ts-ignore
                this._scale._onValueChanged = this._onScaleChanged;
                this._setDirtyFlagTrue(0x1);
                this._setDirtyFlagFalse(0x40 | 0x2);
                this._updateAllWorldFlag();
            }
        },
        {
            key: "worldMatrix",
            get: /**
   * World matrix.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                if (this._isContainDirtyFlag(0x80)) {
                    var parent = this._getParentTransform();
                    if (parent) {
                        Matrix.multiply(parent.worldMatrix, this.localMatrix, this._worldMatrix);
                    } else {
                        this._worldMatrix.copyFrom(this.localMatrix);
                    }
                    this._setDirtyFlagFalse(0x80);
                }
                return this._worldMatrix;
            },
            set: function set(value) {
                if (this._worldMatrix !== value) {
                    this._worldMatrix.copyFrom(value);
                }
                var parent = this._getParentTransform();
                if (parent) {
                    Matrix.invert(parent.worldMatrix, Transform._tempMat42);
                    Matrix.multiply(Transform._tempMat42, value, this._localMatrix);
                } else {
                    this._localMatrix.copyFrom(value);
                }
                this.localMatrix = this._localMatrix;
                this._setDirtyFlagFalse(0x80);
            }
        },
        {
            key: "worldForward",
            get: /**
   * The forward direction in world space.
   */ function get() {
                var worldForward = this._worldForward || (this._worldForward = new Vector3());
                var e = this.worldMatrix.elements;
                worldForward.set(-e[8], -e[9], -e[10]);
                return worldForward.normalize();
            }
        },
        {
            key: "worldRight",
            get: /**
   * The right direction in world space.
   */ function get() {
                var worldRight = this._worldRight || (this._worldRight = new Vector3());
                var e = this.worldMatrix.elements;
                worldRight.set(e[0], e[1], e[2]);
                return worldRight.normalize();
            }
        },
        {
            key: "worldUp",
            get: /**
   * The up direction in world space.
   */ function get() {
                var worldUp = this._worldUp || (this._worldUp = new Vector3());
                var e = this.worldMatrix.elements;
                worldUp.set(e[4], e[5], e[6]);
                return worldUp.normalize();
            }
        }
    ]);
    return Transform;
}(Component);
(function() {
    Transform._tempQuat0 = new Quaternion();
})();
(function() {
    Transform._tempVec30 = new Vector3();
})();
(function() {
    Transform._tempVec31 = new Vector3();
})();
(function() {
    Transform._tempVec32 = new Vector3();
})();
(function() {
    Transform._tempMat30 = new Matrix3x3();
})();
(function() {
    Transform._tempMat31 = new Matrix3x3();
})();
(function() {
    Transform._tempMat32 = new Matrix3x3();
})();
(function() {
    Transform._tempMat41 = new Matrix();
})();
(function() {
    Transform._tempMat42 = new Matrix();
})();
__decorate$1([
    deepClone
], Transform.prototype, "_position", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_rotation", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_rotationQuaternion", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_scale", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldPosition", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldRotation", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldRotationQuaternion", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_lossyWorldScale", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_localMatrix", void 0);
__decorate$1([
    deepClone
], Transform.prototype, "_worldMatrix", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldForward", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldRight", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_worldUp", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_isParentDirty", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_parentTransformCache", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_updateFlagManager", void 0);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onPositionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldPositionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onRotationChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldRotationChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onRotationQuaternionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onWorldRotationQuaternionChanged", null);
__decorate$1([
    ignoreClone
], Transform.prototype, "_onScaleChanged", null);
var TransformModifyFlags;
(function(TransformModifyFlags) {
    TransformModifyFlags[TransformModifyFlags["LocalEuler"] = 0x1] = "LocalEuler";
    TransformModifyFlags[TransformModifyFlags["LocalQuat"] = 0x2] = "LocalQuat";
    TransformModifyFlags[TransformModifyFlags["WorldPosition"] = 0x4] = "WorldPosition";
    TransformModifyFlags[TransformModifyFlags["WorldEuler"] = 0x8] = "WorldEuler";
    TransformModifyFlags[TransformModifyFlags["WorldQuat"] = 0x10] = "WorldQuat";
    TransformModifyFlags[TransformModifyFlags["WorldScale"] = 0x20] = "WorldScale";
    TransformModifyFlags[TransformModifyFlags["LocalMatrix"] = 0x40] = "LocalMatrix";
    TransformModifyFlags[TransformModifyFlags["WorldMatrix"] = 0x80] = "WorldMatrix";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldPosition */ "WmWp"] = 0x84] = "WmWp";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldEuler | WorldQuat */ "WmWeWq"] = 0x98] = "WmWeWq";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldPosition | WorldEuler | WorldQuat */ "WmWpWeWq"] = 0x9c] = "WmWpWeWq";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldScale */ "WmWs"] = 0xa0] = "WmWs";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldPosition | WorldScale */ "WmWpWs"] = 0xa4] = "WmWpWs";
    TransformModifyFlags[TransformModifyFlags[/** WorldMatrix | WorldPosition | WorldEuler | WorldQuat | WorldScale */ "WmWpWeWqWs"] = 0xbc] = "WmWpWeWqWs";
})(TransformModifyFlags || (TransformModifyFlags = {}));

var ComponentCloner = /*#__PURE__*/ function() {
    function ComponentCloner() {}
    /**
   * Clone component.
   * @param source - Clone source
   * @param target - Clone target
   */ ComponentCloner.cloneComponent = function cloneComponent(source, target) {
        var cloneModes = CloneManager.getCloneMode(source.constructor);
        var keys = Object.keys(source);
        for(var i = 0, n = keys.length; i < n; i++){
            var k = keys[i];
            var cloneMode = cloneModes[k];
            switch(cloneMode){
                case undefined:
                case CloneMode.Assignment:
                    target[k] = source[k];
                    break;
                case CloneMode.Shallow:
                    var sourcePropS = source[k];
                    if (_instanceof$2(sourcePropS, Object)) {
                        var tarProp = target[k];
                        tarProp == null && (tarProp = target[k] = sourcePropS.constructor());
                        Object.assign(tarProp, sourcePropS);
                    } else {
                        // Null or undefined and primitive type.
                        target[k] = sourcePropS;
                    }
                    break;
                case CloneMode.Deep:
                    var sourcePropD = source[k];
                    if (_instanceof$2(sourcePropD, Object)) {
                        var tarProp1 = target[k];
                        tarProp1 == null && (tarProp1 = target[k] = sourcePropD.constructor());
                        CloneManager.deepCloneObject(sourcePropD, tarProp1);
                    } else {
                        // Null or undefined and primitive type.
                        target[k] = sourcePropD;
                    }
                    break;
            }
        }
        if (source._cloneTo) {
            source._cloneTo(target);
        }
    };
    return ComponentCloner;
}();

/**
 * Entity, be used as components container.
 */ var Entity = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Entity, EngineObject);
    function Entity(engine, name) {
        var _this;
        _this = EngineObject.call(this, engine) || this;
        /** The layer the entity belongs to. */ _this.layer = Layer.Layer0;
        /** @internal */ _this._isActiveInHierarchy = false;
        /** @internal */ _this._components = [];
        /** @internal */ _this._scripts = new DisorderedArray();
        /** @internal */ _this._children = [];
        /** @internal */ _this._isRoot = false;
        /** @internal */ _this._isActive = true;
        /** @internal */ _this._siblingIndex = -1;
        _this._parent = null;
        //--------------------------------------------------------------deprecated----------------------------------------------------------------
        _this._invModelMatrix = new Matrix();
        _this.name = name;
        _this.transform = _this.addComponent(Transform);
        _this._inverseWorldMatFlag = _this.transform.registerWorldChangeFlag();
        return _this;
    }
    var _proto = Entity.prototype;
    /**
   * Add component based on the component type.
   * @param type - The type of the component
   * @returns	The component which has been added
   */ _proto.addComponent = function addComponent(type) {
        ComponentsDependencies._addCheck(this, type);
        var component = new type(this);
        this._components.push(component);
        component._setActive(true);
        return component;
    };
    /**
   * Get component which match the type.
   * @param type - The type of the component
   * @returns	The first component which match type
   */ _proto.getComponent = function getComponent(type) {
        var components = this._components;
        // @todo: should inverse traversal
        for(var i = components.length - 1; i >= 0; i--){
            var component = components[i];
            if (_instanceof$2(component, type)) {
                return component;
            }
        }
    };
    /**
   * Get components which match the type.
   * @param type - The type of the component
   * @param results - The components which match type
   * @returns	The components which match type
   */ _proto.getComponents = function getComponents(type, results) {
        results.length = 0;
        var components = this._components;
        for(var i = 0, n = components.length; i < n; i++){
            var component = components[i];
            if (_instanceof$2(component, type)) {
                results.push(component);
            }
        }
        return results;
    };
    /**
   * Get the components which match the type of the entity and it's children.
   * @param type - The component type
   * @param results - The components collection
   * @returns	The components collection which match the type
   */ _proto.getComponentsIncludeChildren = function getComponentsIncludeChildren(type, results) {
        results.length = 0;
        this._getComponentsInChildren(type, results);
        return results;
    };
    _proto.addChild = function addChild(indexOrChild, child) {
        var index;
        if (typeof indexOrChild === "number") {
            index = indexOrChild;
        } else {
            index = undefined;
            child = indexOrChild;
        }
        if (child._isRoot) {
            child._scene._removeFromEntityList(child);
            child._isRoot = false;
            this._addToChildrenList(index, child);
            child._parent = this;
            var newScene = this._scene;
            if (child._scene !== newScene) {
                Entity._traverseSetOwnerScene(child, newScene);
            }
            if (this._isActiveInHierarchy) {
                !child._isActiveInHierarchy && child._isActive && child._processActive();
            } else {
                child._isActiveInHierarchy && child._processInActive();
            }
            child._setTransformDirty();
        } else {
            child._setParent(this, index);
        }
    };
    /**
   * Remove child entity.
   * @param child - The child entity which want to be removed
   */ _proto.removeChild = function removeChild(child) {
        child._setParent(null);
    };
    /**
   * @deprecated Please use `children` property instead.
   * Find child entity by index.
   * @param index - The index of the child entity
   * @returns	The component which be found
   */ _proto.getChild = function getChild(index) {
        return this._children[index];
    };
    /**
   * Find entity by name.
   * @param name - The name of the entity which want to be found
   * @returns The component which be found
   */ _proto.findByName = function findByName(name) {
        if (name === this.name) {
            return this;
        }
        var children = this._children;
        for(var i = 0, n = children.length; i < n; i++){
            var target = children[i].findByName(name);
            if (target) {
                return target;
            }
        }
        return null;
    };
    /**
   * Find the entity by path.
   * @param path - The path fo the entity eg: /entity
   * @returns The component which be found
   */ _proto.findByPath = function findByPath(path) {
        var splits = path.split("/");
        var entity = this;
        for(var i = 0, length = splits.length; i < length; ++i){
            var split = splits[i];
            if (split) {
                entity = Entity._findChildByName(entity, split);
                if (!entity) {
                    return null;
                }
            }
        }
        return entity;
    };
    /**
   * Create child entity.
   * @param name - The child entity's name
   * @returns The child entity
   */ _proto.createChild = function createChild(name) {
        var child = new Entity(this.engine, name);
        child.layer = this.layer;
        child.parent = this;
        return child;
    };
    /**
   * Clear children entities.
   */ _proto.clearChildren = function clearChildren() {
        var children = this._children;
        for(var i = children.length - 1; i >= 0; i--){
            var child = children[i];
            child._parent = null;
            child._isActiveInHierarchy && child._processInActive();
            Entity._traverseSetOwnerScene(child, null); // Must after child._processInActive().
        }
        children.length = 0;
    };
    /**
   * Clone.
   * @returns Cloned entity
   */ _proto.clone = function clone() {
        var cloneEntity = new Entity(this._engine, this.name);
        var _this = this, hookResource = _this._hookResource;
        if (hookResource) {
            cloneEntity._hookResource = hookResource;
            hookResource._addReferCount(1);
        }
        cloneEntity._isActive = this._isActive;
        cloneEntity.transform.localMatrix = this.transform.localMatrix;
        var children = this._children;
        for(var i = 0, len = this._children.length; i < len; i++){
            var child = children[i];
            cloneEntity.addChild(child.clone());
        }
        var components = this._components;
        for(var i1 = 0, n = components.length; i1 < n; i1++){
            var sourceComp = components[i1];
            if (!_instanceof$2(sourceComp, Transform)) {
                var targetComp = cloneEntity.addComponent(sourceComp.constructor);
                ComponentCloner.cloneComponent(sourceComp, targetComp);
            }
        }
        return cloneEntity;
    };
    /**
   * Destroy self.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        EngineObject.prototype.destroy.call(this);
        if (this._hookResource) {
            this._hookResource._addReferCount(-1);
            this._hookResource = null;
        }
        var components = this._components;
        for(var i = components.length - 1; i >= 0; i--){
            components[i].destroy();
        }
        this._components.length = 0;
        var children = this._children;
        while(children.length > 0){
            children[0].destroy();
        }
        if (this._isRoot) {
            this._scene._removeFromEntityList(this);
            this._isRoot = false;
        } else {
            this._removeFromParent();
        }
    };
    /**
   * @internal
   */ _proto._removeComponent = function _removeComponent(component) {
        ComponentsDependencies._removeCheck(this, component.constructor);
        var components = this._components;
        components.splice(components.indexOf(component), 1);
    };
    /**
   * @internal
   */ _proto._addScript = function _addScript(script) {
        script._entityScriptsIndex = this._scripts.length;
        this._scripts.add(script);
    };
    /**
   * @internal
   */ _proto._removeScript = function _removeScript(script) {
        var replaced = this._scripts.deleteByIndex(script._entityScriptsIndex);
        replaced && (replaced._entityScriptsIndex = script._entityScriptsIndex);
        script._entityScriptsIndex = -1;
    };
    /**
   * @internal
   */ _proto._removeFromParent = function _removeFromParent() {
        var oldParent = this._parent;
        if (oldParent != null) {
            var oldSibling = oldParent._children;
            var index = this._siblingIndex;
            oldSibling.splice(index, 1);
            for(var n = oldSibling.length; index < n; index++){
                oldSibling[index]._siblingIndex--;
            }
            this._parent = null;
            this._siblingIndex = -1;
        }
    };
    /**
   * @internal
   */ _proto._processActive = function _processActive() {
        if (this._activeChangedComponents) {
            throw "Note: can't set the 'main inActive entity' active in hierarchy, if the operation is in main inActive entity or it's children script's onDisable Event.";
        }
        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
        this._setActiveInHierarchy(this._activeChangedComponents);
        this._setActiveComponents(true);
    };
    /**
   * @internal
   */ _proto._processInActive = function _processInActive() {
        if (this._activeChangedComponents) {
            throw "Note: can't set the 'main active entity' inActive in hierarchy, if the operation is in main active entity or it's children script's onEnable Event.";
        }
        this._activeChangedComponents = this._engine._componentsManager.getActiveChangedTempList();
        this._setInActiveInHierarchy(this._activeChangedComponents);
        this._setActiveComponents(false);
    };
    _proto._addToChildrenList = function _addToChildrenList(index, child) {
        var children = this._children;
        var childCount = children.length;
        if (index === undefined) {
            child._siblingIndex = childCount;
            children.push(child);
        } else {
            if (index < 0 || index > childCount) {
                throw "The index " + index + " is out of child list bounds " + childCount;
            }
            child._siblingIndex = index;
            children.splice(index, 0, child);
            for(var i = index + 1, n = childCount + 1; i < n; i++){
                children[i]._siblingIndex++;
            }
        }
    };
    _proto._setParent = function _setParent(parent, siblingIndex) {
        var oldParent = this._parent;
        if (parent !== oldParent) {
            this._removeFromParent();
            this._parent = parent;
            if (parent) {
                parent._addToChildrenList(siblingIndex, this);
                var parentScene = parent._scene;
                if (this._scene !== parentScene) {
                    Entity._traverseSetOwnerScene(this, parentScene);
                }
                if (parent._isActiveInHierarchy) {
                    !this._isActiveInHierarchy && this._isActive && this._processActive();
                } else {
                    this._isActiveInHierarchy && this._processInActive();
                }
            } else {
                this._isActiveInHierarchy && this._processInActive();
                if (oldParent) {
                    Entity._traverseSetOwnerScene(this, null);
                }
            }
            this._setTransformDirty();
        }
    };
    _proto._getComponentsInChildren = function _getComponentsInChildren(type, results) {
        for(var i = this._components.length - 1; i >= 0; i--){
            var component = this._components[i];
            if (_instanceof$2(component, type)) {
                results.push(component);
            }
        }
        for(var i1 = this._children.length - 1; i1 >= 0; i1--){
            this._children[i1]._getComponentsInChildren(type, results);
        }
    };
    _proto._setActiveComponents = function _setActiveComponents(isActive) {
        var activeChangedComponents = this._activeChangedComponents;
        for(var i = 0, length = activeChangedComponents.length; i < length; ++i){
            activeChangedComponents[i]._setActive(isActive);
        }
        this._engine._componentsManager.putActiveChangedTempList(activeChangedComponents);
        this._activeChangedComponents = null;
    };
    _proto._setActiveInHierarchy = function _setActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = true;
        var components = this._components;
        for(var i = components.length - 1; i >= 0; i--){
            var component = components[i];
            (component.enabled || !component._awoken) && activeChangedComponents.push(component);
        }
        var children = this._children;
        for(var i1 = children.length - 1; i1 >= 0; i1--){
            var child = children[i1];
            child.isActive && child._setActiveInHierarchy(activeChangedComponents);
        }
    };
    _proto._setInActiveInHierarchy = function _setInActiveInHierarchy(activeChangedComponents) {
        this._isActiveInHierarchy = false;
        var components = this._components;
        for(var i = components.length - 1; i >= 0; i--){
            var component = components[i];
            component.enabled && activeChangedComponents.push(component);
        }
        var children = this._children;
        for(var i1 = children.length - 1; i1 >= 0; i1--){
            var child = children[i1];
            child.isActive && child._setInActiveInHierarchy(activeChangedComponents);
        }
    };
    _proto._setTransformDirty = function _setTransformDirty() {
        if (this.transform) {
            this.transform._parentChange();
        } else {
            for(var i = 0, len = this._children.length; i < len; i++){
                this._children[i]._setTransformDirty();
            }
        }
    };
    _proto._setSiblingIndex = function _setSiblingIndex(sibling, target) {
        target = Math.min(target, sibling.length - 1);
        if (target < 0) {
            throw "Sibling index " + target + " should large than 0";
        }
        if (this._siblingIndex !== target) {
            var oldIndex = this._siblingIndex;
            if (target < oldIndex) {
                for(var i = oldIndex; i >= target; i--){
                    var child = i == target ? this : sibling[i - 1];
                    sibling[i] = child;
                    child._siblingIndex = i;
                }
            } else {
                for(var i1 = oldIndex; i1 <= target; i1++){
                    var child1 = i1 == target ? this : sibling[i1 + 1];
                    sibling[i1] = child1;
                    child1._siblingIndex = i1;
                }
            }
        }
    };
    /**
   * @deprecated
   */ _proto.getInvModelMatrix = function getInvModelMatrix() {
        if (this._inverseWorldMatFlag.flag) {
            Matrix.invert(this.transform.worldMatrix, this._invModelMatrix);
            this._inverseWorldMatFlag.flag = false;
        }
        return this._invModelMatrix;
    };
    /**
   * @internal
   */ Entity._findChildByName = function _findChildByName(root, name) {
        var children = root._children;
        for(var i = children.length - 1; i >= 0; i--){
            var child = children[i];
            if (child.name === name) {
                return child;
            }
        }
        return null;
    };
    /**
   * @internal
   */ Entity._traverseSetOwnerScene = function _traverseSetOwnerScene(entity, scene) {
        entity._scene = scene;
        var children = entity._children;
        for(var i = entity.childCount - 1; i >= 0; i--){
            this._traverseSetOwnerScene(children[i], scene);
        }
    };
    _create_class$3(Entity, [
        {
            key: "isActive",
            get: /**
   * Whether to activate locally.
   */ function get() {
                return this._isActive;
            },
            set: function set(value) {
                if (value !== this._isActive) {
                    this._isActive = value;
                    if (value) {
                        var parent = this._parent;
                        if ((parent == null ? void 0 : parent._isActiveInHierarchy) || this._isRoot && this._scene._isActiveInEngine) {
                            this._processActive();
                        }
                    } else {
                        if (this._isActiveInHierarchy) {
                            this._processInActive();
                        }
                    }
                }
            }
        },
        {
            key: "isActiveInHierarchy",
            get: /**
   * Whether it is active in the hierarchy.
   */ function get() {
                return this._isActiveInHierarchy;
            }
        },
        {
            key: "parent",
            get: /**
   * The parent entity.
   */ function get() {
                return this._parent;
            },
            set: function set(value) {
                this._setParent(value);
            }
        },
        {
            key: "children",
            get: /**
   * The children entities
   */ function get() {
                return this._children;
            }
        },
        {
            key: "childCount",
            get: /**
   * @deprecated Please use `children.length` property instead.
   * Number of the children entities
   */ function get() {
                return this._children.length;
            }
        },
        {
            key: "scene",
            get: /**
   * The scene the entity belongs to.
   */ function get() {
                return this._scene;
            }
        },
        {
            key: "siblingIndex",
            get: /**
   * The sibling index.
   */ function get() {
                return this._siblingIndex;
            },
            set: function set(value) {
                if (this._siblingIndex === -1) {
                    throw "The entity " + this.name + " is not in the hierarchy";
                }
                this._setSiblingIndex(this._isRoot ? this._scene._rootEntities : this._parent._children, value);
            }
        }
    ]);
    return Entity;
}(EngineObject);

/**
 * Color Space.
 */ var ColorSpace;
(function(ColorSpace) {
    ColorSpace[ColorSpace[/** Linear color space. */ "Linear"] = 0] = "Linear";
    ColorSpace[ColorSpace[/** Gamma color space. */ "Gamma"] = 1] = "Gamma";
})(ColorSpace || (ColorSpace = {}));

/**
 *  The current phase of the pointer.
 */ var PointerPhase;
(function(PointerPhase) {
    PointerPhase[PointerPhase[/** A Pointer pressed on the screen. */ "Down"] = 0] = "Down";
    PointerPhase[PointerPhase[/** A pointer moved on the screen. */ "Move"] = 1] = "Move";
    PointerPhase[PointerPhase[/** A Pointer pressed on the screen but hasn't moved. */ "Stationary"] = 2] = "Stationary";
    PointerPhase[PointerPhase[/** A pointer was lifted from the screen. */ "Up"] = 3] = "Up";
    PointerPhase[PointerPhase[/** The system cancelled tracking for the pointer. */ "Leave"] = 4] = "Leave";
})(PointerPhase || (PointerPhase = {}));

/**
 * Pointer.
 */ var Pointer = /*#__PURE__*/ function() {
    function Pointer(id) {
        /** The phase of pointer. */ this.phase = PointerPhase.Leave;
        /** The position of the pointer in screen space pixel coordinates. */ this.position = new Vector2();
        /** The change of the pointer. */ this.deltaPosition = new Vector2();
        /** @internal */ this._events = [];
        /** @internal */ this._upMap = [];
        /** @internal */ this._downMap = [];
        /** @internal */ this._upList = new DisorderedArray();
        /** @internal */ this._downList = new DisorderedArray();
        this.id = id;
    }
    var _proto = Pointer.prototype;
    /** @internal */ _proto._firePointerExitAndEnter = function _firePointerExitAndEnter(rayCastEntity) {
        if (this._currentEnteredEntity !== rayCastEntity) {
            if (this._currentEnteredEntity) {
                var scripts = this._currentEnteredEntity._scripts;
                for(var i = scripts.length - 1; i >= 0; i--){
                    var script = scripts.get(i);
                    script._waitHandlingInValid || script.onPointerExit(this);
                }
            }
            if (rayCastEntity) {
                var scripts1 = rayCastEntity._scripts;
                for(var i1 = scripts1.length - 1; i1 >= 0; i1--){
                    var script1 = scripts1.get(i1);
                    script1._waitHandlingInValid || script1.onPointerEnter(this);
                }
            }
            this._currentEnteredEntity = rayCastEntity;
        }
    };
    /** @internal */ _proto._firePointerDown = function _firePointerDown(rayCastEntity) {
        if (rayCastEntity) {
            var scripts = rayCastEntity._scripts;
            for(var i = scripts.length - 1; i >= 0; i--){
                var script = scripts.get(i);
                script._waitHandlingInValid || script.onPointerDown(this);
            }
        }
        this._currentPressedEntity = rayCastEntity;
    };
    /** @internal */ _proto._firePointerDrag = function _firePointerDrag() {
        if (this._currentPressedEntity) {
            var scripts = this._currentPressedEntity._scripts;
            for(var i = scripts.length - 1; i >= 0; i--){
                var script = scripts.get(i);
                script._waitHandlingInValid || script.onPointerDrag(this);
            }
        }
    };
    /** @internal */ _proto._firePointerUpAndClick = function _firePointerUpAndClick(rayCastEntity) {
        var _this = this, pressedEntity = _this._currentPressedEntity;
        if (pressedEntity) {
            var sameTarget = pressedEntity === rayCastEntity;
            var scripts = pressedEntity._scripts;
            for(var i = scripts.length - 1; i >= 0; i--){
                var script = scripts.get(i);
                if (!script._waitHandlingInValid) {
                    sameTarget && script.onPointerClick(this);
                    script.onPointerUp(this);
                }
            }
            this._currentPressedEntity = null;
        }
    };
    return Pointer;
}();

/**
 * System info.
 */ var SystemInfo = /*#__PURE__*/ function() {
    function SystemInfo() {}
    /**
   * @internal
   */ SystemInfo._initialize = function _initialize() {
        {
            if (typeof PlatformManager$1.polyfill.navigator == "undefined") {
                return;
            }
            var userAgent = PlatformManager$1.polyfill.navigator.userAgent;
            if (/iPhone/i.test(userAgent)) {
                SystemInfo.platform = Platform.IPhone;
            } else if (/iPad/i.test(userAgent)) {
                SystemInfo.platform = Platform.IPad;
            } else if (/Android/i.test(userAgent)) {
                SystemInfo.platform = Platform.Android;
            } else if (/Macintosh/i.test(userAgent)) {
                SystemInfo.platform = Platform.Mac;
            }
            var v;
            switch(SystemInfo.platform){
                case Platform.IPhone:
                    v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "iPhone OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPhone OS";
                    break;
                case Platform.IPad:
                    v = userAgent.match(/OS (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "iPad OS " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "iPad OS";
                    break;
                case Platform.Android:
                    v = userAgent.match(/Android (\d+).?(\d+)?.?(\d+)?/);
                    this.operatingSystem = v ? "Android " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Android";
                    break;
                case Platform.Mac:
                    v = userAgent.match(/Mac OS X (\d+)_?(\d+)?_?(\d+)?/);
                    this.operatingSystem = v ? "Mac OS X " + v[1] + "." + (v[2] || 0) + "." + (v[3] || 0) : "Mac OS X";
                    break;
            }
        }
    };
    _create_class$3(SystemInfo, null, [
        {
            key: "devicePixelRatio",
            get: /**
   * The pixel ratio of the device.
   */ function get() {
                return PlatformManager$1.polyfill.window.devicePixelRatio;
            }
        }
    ]);
    return SystemInfo;
}();
(function() {
    /** The platform is running on. */ SystemInfo.platform = Platform.Unknown;
})();
(function() {
    /** The operating system is running on. */ SystemInfo.operatingSystem = "";
})();
SystemInfo._initialize();

/**
 * The keys of the keyboard.
 * Keep up with W3C standards.(https://www.w3.org/TR/2017/CR-uievents-code-20170601/)
 */ exports.Keys = void 0;
(function(Keys) {
    Keys[Keys[/** `~ on a US keyboard. This is the åŠè§’/å…¨è§’/æ¼¢å­— (hankaku/zenkaku/kanji) key on Japanese keyboards. */ "Backquote"] = 0] = "Backquote";
    Keys[Keys[/** Used for both the US \| (on the 101-key layout) and also for the key located between the " and Enter keys on row C of the 102-, 104- and 106-key layouts. Labelled #~ on a UK (102) keyboard. */ "Backslash"] = 1] = "Backslash";
    Keys[Keys[/**	Backspace or âŒ«. Labelled Delete on Apple keyboards. */ "Backspace"] = 2] = "Backspace";
    Keys[Keys[/** [{ on a US keyboard. */ "BracketLeft"] = 3] = "BracketLeft";
    Keys[Keys[/** ]} on a US keyboard. */ "BracketRight"] = 4] = "BracketRight";
    Keys[Keys[/** ,< on a US keyboard. */ "Comma"] = 5] = "Comma";
    Keys[Keys[/** 0) on a US keyboard. */ "Digit0"] = 6] = "Digit0";
    Keys[Keys[/** 1! on a US keyboard. */ "Digit1"] = 7] = "Digit1";
    Keys[Keys[/** 2@ on a US keyboard. */ "Digit2"] = 8] = "Digit2";
    Keys[Keys[/** 3# on a US keyboard. */ "Digit3"] = 9] = "Digit3";
    Keys[Keys[/** 4$ on a US keyboard. */ "Digit4"] = 10] = "Digit4";
    Keys[Keys[/** 5% on a US keyboard. */ "Digit5"] = 11] = "Digit5";
    Keys[Keys[/** 6^ on a US keyboard. */ "Digit6"] = 12] = "Digit6";
    Keys[Keys[/** 7& on a US keyboard. */ "Digit7"] = 13] = "Digit7";
    Keys[Keys[/** 8* on a US keyboard. */ "Digit8"] = 14] = "Digit8";
    Keys[Keys[/** 9( on a US keyboard. */ "Digit9"] = 15] = "Digit9";
    Keys[Keys[/** =+ on a US keyboard. */ "Equal"] = 16] = "Equal";
    Keys[Keys[/** Located between the left Shift and Z keys. Labelled \| on a UK keyboard. */ "IntlBackslash"] = 17] = "IntlBackslash";
    Keys[Keys[/** Located between the / and right Shift keys. Labelled \ã‚ (ro) on a Japanese keyboard. */ "IntlRo"] = 18] = "IntlRo";
    Keys[Keys[/** Located between the = and Backspace keys. Labelled Â¥ (yen) on a Japanese keyboard. \/ on a Russian keyboard. */ "IntlYen"] = 19] = "IntlYen";
    Keys[Keys[/** a on a US keyboard. Labelled q on an AZERTY (e.g., French) keyboard. */ "KeyA"] = 20] = "KeyA";
    Keys[Keys[/** b on a US keyboard. */ "KeyB"] = 21] = "KeyB";
    Keys[Keys[/** c on a US keyboard. */ "KeyC"] = 22] = "KeyC";
    Keys[Keys[/** d on a US keyboard. */ "KeyD"] = 23] = "KeyD";
    Keys[Keys[/** e on a US keyboard. */ "KeyE"] = 24] = "KeyE";
    Keys[Keys[/** f on a US keyboard. */ "KeyF"] = 25] = "KeyF";
    Keys[Keys[/** g on a US keyboard. */ "KeyG"] = 26] = "KeyG";
    Keys[Keys[/** h on a US keyboard. */ "KeyH"] = 27] = "KeyH";
    Keys[Keys[/** i on a US keyboard. */ "KeyI"] = 28] = "KeyI";
    Keys[Keys[/** j on a US keyboard. */ "KeyJ"] = 29] = "KeyJ";
    Keys[Keys[/** k on a US keyboard. */ "KeyK"] = 30] = "KeyK";
    Keys[Keys[/** l on a US keyboard. */ "KeyL"] = 31] = "KeyL";
    Keys[Keys[/** m on a US keyboard. */ "KeyM"] = 32] = "KeyM";
    Keys[Keys[/** n on a US keyboard. */ "KeyN"] = 33] = "KeyN";
    Keys[Keys[/** o on a US keyboard. */ "KeyO"] = 34] = "KeyO";
    Keys[Keys[/** p on a US keyboard. */ "KeyP"] = 35] = "KeyP";
    Keys[Keys[/** q on a US keyboard. Labelled a on an AZERTY (e.g., French) keyboard. */ "KeyQ"] = 36] = "KeyQ";
    Keys[Keys[/** r on a US keyboard. */ "KeyR"] = 37] = "KeyR";
    Keys[Keys[/** s on a US keyboard. */ "KeyS"] = 38] = "KeyS";
    Keys[Keys[/** t on a US keyboard. */ "KeyT"] = 39] = "KeyT";
    Keys[Keys[/** u on a US keyboard. */ "KeyU"] = 40] = "KeyU";
    Keys[Keys[/** v on a US keyboard. */ "KeyV"] = 41] = "KeyV";
    Keys[Keys[/** w on a US keyboard. Labelled z on an AZERTY (e.g., French) keyboard. */ "KeyW"] = 42] = "KeyW";
    Keys[Keys[/** x on a US keyboard. */ "KeyX"] = 43] = "KeyX";
    Keys[Keys[/** y on a US keyboard. Labelled z on a QWERTZ (e.g., German) keyboard. */ "KeyY"] = 44] = "KeyY";
    Keys[Keys[/** z on a US keyboard. Labelled w on an AZERTY (e.g., French) keyboard, and y on a QWERTZ (e.g., German) keyboard. */ "KeyZ"] = 45] = "KeyZ";
    Keys[Keys[/** -_ on a US keyboard. */ "Minus"] = 46] = "Minus";
    Keys[Keys[/** .> on a US keyboard. */ "Period"] = 47] = "Period";
    Keys[Keys[/** '" on a US keyboard. */ "Quote"] = 48] = "Quote";
    Keys[Keys[/** ;: on a US keyboard. */ "Semicolon"] = 49] = "Semicolon";
    Keys[Keys[/** /? on a US keyboard. */ "Slash"] = 50] = "Slash";
    Keys[Keys[/** Alt, Option or âŒ¥. */ "AltLeft"] = 51] = "AltLeft";
    Keys[Keys[/** Alt, Option or âŒ¥. This is labelled AltGr key on many keyboard layouts. */ "AltRight"] = 52] = "AltRight";
    Keys[Keys[/** CapsLock or â‡ª. */ "CapsLock"] = 53] = "CapsLock";
    Keys[Keys[/** The application context menu key, which is typically found between the right Meta key and the right Control key. */ "ContextMenu"] = 54] = "ContextMenu";
    Keys[Keys[/** Control or âŒƒ. */ "ControlLeft"] = 55] = "ControlLeft";
    Keys[Keys[/** Control or âŒƒ. */ "ControlRight"] = 56] = "ControlRight";
    Keys[Keys[/** Enter or â†µ. Labelled Return on Apple keyboards. */ "Enter"] = 57] = "Enter";
    Keys[Keys[/** The Windows, âŒ˜, Command or other OS symbol key. */ "MetaLeft"] = 58] = "MetaLeft";
    Keys[Keys[/** The Windows, âŒ˜, Command or other OS symbol key. */ "MetaRight"] = 59] = "MetaRight";
    Keys[Keys[/** Shift or â‡§. */ "ShiftLeft"] = 60] = "ShiftLeft";
    Keys[Keys[/** Shift or â‡§. */ "ShiftRight"] = 61] = "ShiftRight";
    Keys[Keys[/** Space. */ "Space"] = 62] = "Space";
    Keys[Keys[/** Tab or â‡¥. */ "Tab"] = 63] = "Tab";
    Keys[Keys[/** Japanese: å¤‰æ› (henkan). */ "Convert"] = 64] = "Convert";
    Keys[Keys[/** Japanese: ã‚«ã‚¿ã‚«ãƒŠ/ã²ã‚‰ãŒãª/ãƒ­ãƒ¼ãƒžå­— (katakana/hiragana/romaji). */ "KanaMode"] = 65] = "KanaMode";
    Keys[Keys[/**
   * Korean: HangulMode í•œ/ì˜ (han/yeong).
   * Japanese (Mac keyboard): ã‹ãª (kana).
   * */ "Lang1"] = 66] = "Lang1";
    Keys[Keys[/**
   * 	Korean: Hanja í•œìž (hanja).
   *  Japanese (Mac keyboard): è‹±æ•° (eisu).
   */ "Lang2"] = 67] = "Lang2";
    Keys[Keys[/** Japanese (word-processing keyboard): Katakana. */ "Lang3"] = 68] = "Lang3";
    Keys[Keys[/** Japanese (word-processing keyboard): Hiragana. */ "Lang4"] = 69] = "Lang4";
    Keys[Keys[/** Japanese (word-processing keyboard): Zenkaku/Hankaku. */ "Lang5"] = 70] = "Lang5";
    Keys[Keys[/** Japanese: ç„¡å¤‰æ› (muhenkan). */ "NonConvert"] = 71] = "NonConvert";
    Keys[Keys[/** âŒ¦. The forward delete key. Note that on Apple keyboards, the key labelled Delete on the main part of the keyboard should be encoded as "Backspace". */ "Delete"] = 72] = "Delete";
    Keys[Keys[/** Page Down, End or â†˜. */ "End"] = 73] = "End";
    Keys[Keys[/** Help. Not present on standard PC keyboards. */ "Help"] = 74] = "Help";
    Keys[Keys[/** Home or â†–. */ "Home"] = 75] = "Home";
    Keys[Keys[/** Insert or Ins. Not present on Apple keyboards. */ "Insert"] = 76] = "Insert";
    Keys[Keys[/** Page Down, PgDn or â‡Ÿ. */ "PageDown"] = 77] = "PageDown";
    Keys[Keys[/** Page Up, PgUp or â‡ž. */ "PageUp"] = 78] = "PageUp";
    Keys[Keys[/** â†“ */ "ArrowDown"] = 79] = "ArrowDown";
    Keys[Keys[/** â† */ "ArrowLeft"] = 80] = "ArrowLeft";
    Keys[Keys[/** â†’ */ "ArrowRight"] = 81] = "ArrowRight";
    Keys[Keys[/** â†‘ */ "ArrowUp"] = 82] = "ArrowUp";
    Keys[Keys[/** On the Mac, the "NumLock" code should be used for the numpad Clear key. */ "NumLock"] = 83] = "NumLock";
    Keys[Keys[/**
   * 0 Ins on a keyboard.
   * 0 on a phone or remote control.
   * */ "Numpad0"] = 84] = "Numpad0";
    Keys[Keys[/**
   * 1 End on a keyboard.
   * 1 or 1 QZ on a phone or remote control.
   */ "Numpad1"] = 85] = "Numpad1";
    Keys[Keys[/**
   * 2 â†“ on a keyboard.
   * 2 ABC on a phone or remote control.
   */ "Numpad2"] = 86] = "Numpad2";
    Keys[Keys[/**
   * 3 PgDn on a keyboard.
   * 3 DEF on a phone or remote control.
   */ "Numpad3"] = 87] = "Numpad3";
    Keys[Keys[/**
   * 4 â† on a keyboard.
   * 4 GHI on a phone or remote control.
   */ "Numpad4"] = 88] = "Numpad4";
    Keys[Keys[/**
   * 5 on a keyboard.
   * 5 JKL on a phone or remote control.
   */ "Numpad5"] = 89] = "Numpad5";
    Keys[Keys[/**
   * 6 â†’ on a keyboard.
   * 6 MNO on a phone or remote control.
   */ "Numpad6"] = 90] = "Numpad6";
    Keys[Keys[/**
   * 7 Home on a keyboard.
   * 7 PQRS or 7 PRS on a phone or remote control.
   */ "Numpad7"] = 91] = "Numpad7";
    Keys[Keys[/**
   * 8 â†‘ on a keyboard.
   * 8 TUV on a phone or remote control.
   */ "Numpad8"] = 92] = "Numpad8";
    Keys[Keys[/**
   * 9 PgUp on a keyboard.
   * 9 WXYZ or 9 WXY on a phone or remote control.
   */ "Numpad9"] = 93] = "Numpad9";
    Keys[Keys[/** + */ "NumpadAdd"] = 94] = "NumpadAdd";
    Keys[Keys[/** Found on the Microsoft Natural Keyboard. */ "NumpadBackspace"] = 95] = "NumpadBackspace";
    Keys[Keys[/** C or AC (All Clear). Also for use with numpads that have a Clear key that is separate from the NumLock key. On the Mac, the numpad Clear key should always be encoded as "NumLock". */ "NumpadClear"] = 96] = "NumpadClear";
    Keys[Keys[/** CE (Clear Entry) */ "NumpadClearEntry"] = 97] = "NumpadClearEntry";
    Keys[Keys[/** , (thousands separator). For locales where the thousands separator is a "." (e.g., Brazil), this key may generate a .. */ "NumpadComma"] = 98] = "NumpadComma";
    Keys[Keys[/** . Del. For locales where the decimal separator is "," (e.g., Brazil), this key may generate a ,. */ "NumpadDecimal"] = 99] = "NumpadDecimal";
    Keys[Keys[/** / */ "NumpadDivide"] = 100] = "NumpadDivide";
    Keys[Keys[/** Numpad Enter */ "NumpadEnter"] = 101] = "NumpadEnter";
    Keys[Keys[/** = */ "NumpadEqual"] = 102] = "NumpadEqual";
    Keys[Keys[/** # on a phone or remote control device. This key is typically found below the 9 key and to the right of the 0 key. */ "NumpadHash"] = 103] = "NumpadHash";
    Keys[Keys[/** M+ Add current entry to the value stored in memory. */ "NumpadMemoryAdd"] = 104] = "NumpadMemoryAdd";
    Keys[Keys[/** MC Clear the value stored in memory. */ "NumpadMemoryClear"] = 105] = "NumpadMemoryClear";
    Keys[Keys[/** MR Replace the current entry with the value stored in memory. */ "NumpadMemoryRecall"] = 106] = "NumpadMemoryRecall";
    Keys[Keys[/** MS Replace the value stored in memory with the current entry. */ "NumpadMemoryStore"] = 107] = "NumpadMemoryStore";
    Keys[Keys[/** M- Subtract current entry from the value stored in memory. */ "NumpadMemorySubtract"] = 108] = "NumpadMemorySubtract";
    Keys[Keys[/**
   * * on a keyboard. For use with numpads that provide mathematical operations (+, -, * and /).
   * Use "NumpadStar" for the * key on phones and remote controls.
   */ "NumpadMultiply"] = 109] = "NumpadMultiply";
    Keys[Keys[/** ( Found on the Microsoft Natural Keyboard. */ "NumpadParenLeft"] = 110] = "NumpadParenLeft";
    Keys[Keys[/** ) Found on the Microsoft Natural Keyboard. */ "NumpadParenRight"] = 111] = "NumpadParenRight";
    Keys[Keys[/**
   * * on a phone or remote control device. This key is typically found below the 7 key and to the left of the 0 key.
   * Use "NumpadMultiply" for the * key on numeric keypads.
   */ "NumpadStar"] = 112] = "NumpadStar";
    Keys[Keys[/** - */ "NumpadSubtract"] = 113] = "NumpadSubtract";
    Keys[Keys[/** Esc or âŽ‹. */ "Escape"] = 114] = "Escape";
    Keys[Keys[/** F1 */ "F1"] = 115] = "F1";
    Keys[Keys[/** F2 */ "F2"] = 116] = "F2";
    Keys[Keys[/** F3 */ "F3"] = 117] = "F3";
    Keys[Keys[/** F4 */ "F4"] = 118] = "F4";
    Keys[Keys[/** F5 */ "F5"] = 119] = "F5";
    Keys[Keys[/** F6 */ "F6"] = 120] = "F6";
    Keys[Keys[/** F7 */ "F7"] = 121] = "F7";
    Keys[Keys[/** F8 */ "F8"] = 122] = "F8";
    Keys[Keys[/** F9 */ "F9"] = 123] = "F9";
    Keys[Keys[/** F10 */ "F10"] = 124] = "F10";
    Keys[Keys[/** F11 */ "F11"] = 125] = "F11";
    Keys[Keys[/** F12 */ "F12"] = 126] = "F12";
    Keys[Keys[/** F13 */ "F13"] = 127] = "F13";
    Keys[Keys[/** F14 */ "F14"] = 128] = "F14";
    Keys[Keys[/** F15 */ "F15"] = 129] = "F15";
    Keys[Keys[/** Fn This is typically a hardware key that does not generate a separate code. Most keyboards do not place this key in the function section, but it is included here to keep it with related keys. */ "Fn"] = 130] = "Fn";
    Keys[Keys[/** FLock or FnLock. Function Lock key. Found on the Microsoft Natural Keyboard. */ "FnLock"] = 131] = "FnLock";
    Keys[Keys[/** PrtScr SysRq or Print Screen. */ "PrintScreen"] = 132] = "PrintScreen";
    Keys[Keys[/** Scroll Lock */ "ScrollLock"] = 133] = "ScrollLock";
    Keys[Keys[/** Pause Break */ "Pause"] = 134] = "Pause";
    Keys[Keys[/** Some laptops place this key to the left of the â†‘ key. */ "BrowserBack"] = 135] = "BrowserBack";
    Keys[Keys[/** Browser Favorites */ "BrowserFavorites"] = 136] = "BrowserFavorites";
    Keys[Keys[/** Some laptops place this key to the right of the â†‘ key. */ "BrowserForward"] = 137] = "BrowserForward";
    Keys[Keys[/** Browser Home */ "BrowserHome"] = 138] = "BrowserHome";
    Keys[Keys[/** Browser Refresh */ "BrowserRefresh"] = 139] = "BrowserRefresh";
    Keys[Keys[/** Browser Search */ "BrowserSearch"] = 140] = "BrowserSearch";
    Keys[Keys[/** Browser Stop */ "BrowserStop"] = 141] = "BrowserStop";
    Keys[Keys[/** Eject or â. This key is placed in the function section on some Apple keyboards. */ "Eject"] = 142] = "Eject";
    Keys[Keys[/** Sometimes labelled My Computer on the keyboard. */ "LaunchApp1"] = 143] = "LaunchApp1";
    Keys[Keys[/** Sometimes labelled Calculator on the keyboard. */ "LaunchApp2"] = 144] = "LaunchApp2";
    Keys[Keys[/** Launch Mail */ "LaunchMail"] = 145] = "LaunchMail";
    Keys[Keys[/** Media Play/Pause */ "MediaPlayPause"] = 146] = "MediaPlayPause";
    Keys[Keys[/** Media Select */ "MediaSelect"] = 147] = "MediaSelect";
    Keys[Keys[/** Media Stop */ "MediaStop"] = 148] = "MediaStop";
    Keys[Keys[/** Media Track Next */ "MediaTrackNext"] = 149] = "MediaTrackNext";
    Keys[Keys[/** Media Track Previous */ "MediaTrackPrevious"] = 150] = "MediaTrackPrevious";
    Keys[Keys[/** This key is placed in the function section on some Apple keyboards, replacing the Eject key. */ "Power"] = 151] = "Power";
    Keys[Keys[/** Sleep */ "Sleep"] = 152] = "Sleep";
    Keys[Keys[/** Audio Volume Down */ "AudioVolumeDown"] = 153] = "AudioVolumeDown";
    Keys[Keys[/** Audio Volume Mute */ "AudioVolumeMute"] = 154] = "AudioVolumeMute";
    Keys[Keys[/** Audio Volume Up */ "AudioVolumeUp"] = 155] = "AudioVolumeUp";
    Keys[Keys[/** Wake Up */ "WakeUp"] = 156] = "WakeUp";
    Keys[Keys[/** Hyper */ "Hyper"] = 157] = "Hyper";
    Keys[Keys[/** Super */ "Super"] = 158] = "Super";
    Keys[Keys[/** Turbo */ "Turbo"] = 159] = "Turbo";
    Keys[Keys[/** Abort */ "Abort"] = 160] = "Abort";
    Keys[Keys[/** Resume */ "Resume"] = 161] = "Resume";
    Keys[Keys[/** Suspend */ "Suspend"] = 162] = "Suspend";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Again"] = 163] = "Again";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Copy"] = 164] = "Copy";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Cut"] = 165] = "Cut";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Find"] = 166] = "Find";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Open"] = 167] = "Open";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Paste"] = 168] = "Paste";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Props"] = 169] = "Props";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Select"] = 170] = "Select";
    Keys[Keys[/** Found on Sunâ€™s USB keyboard. */ "Undo"] = 171] = "Undo";
    Keys[Keys[/** Use for dedicated ã²ã‚‰ãŒãª key found on some Japanese word processing keyboards. */ "Hiragana"] = 172] = "Hiragana";
    Keys[Keys[/** Use for dedicated ã‚«ã‚¿ã‚«ãƒŠ key found on some Japanese word processing keyboards. */ "Katakana"] = 173] = "Katakana";
    Keys[Keys[/** This value code should be used when no other value given in this specification is appropriate. */ "Unidentified"] = 174] = "Unidentified";
})(exports.Keys || (exports.Keys = {}));

/**
 * Keyboard Manager.
 * @internal
 */ var KeyboardManager = /*#__PURE__*/ function() {
    function KeyboardManager(engine) {
        /** @internal */ this._curHeldDownKeyToIndexMap = [];
        /** @internal */ this._upKeyToFrameCountMap = [];
        /** @internal */ this._downKeyToFrameCountMap = [];
        /** @internal */ this._curFrameHeldDownList = new DisorderedArray();
        /** @internal */ this._curFrameDownList = new DisorderedArray();
        /** @internal */ this._curFrameUpList = new DisorderedArray();
        this._nativeEvents = [];
        this._hadListener = false;
        // @ts-ignore
        var htmlCanvas = engine._canvas._webCanvas;
        this._engine = engine;
        this._htmlCanvas = htmlCanvas;
        // Need to set tabIndex to make the canvas focus.
        htmlCanvas.tabIndex = htmlCanvas.tabIndex;
        this._onKeyEvent = this._onKeyEvent.bind(this);
        htmlCanvas.addEventListener("keydown", this._onKeyEvent);
        htmlCanvas.addEventListener("keyup", this._onKeyEvent);
        this._hadListener = true;
    }
    var _proto = KeyboardManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this = this, nativeEvents = _this._nativeEvents, curFrameDownList = _this._curFrameDownList, curFrameUpList = _this._curFrameUpList;
        curFrameDownList.length = 0;
        curFrameUpList.length = 0;
        if (nativeEvents.length > 0) {
            var frameCount = this._engine.time.frameCount;
            var _this1 = this, curHeldDownKeyToIndexMap = _this1._curHeldDownKeyToIndexMap, curFrameHeldDownList = _this1._curFrameHeldDownList, downKeyToFrameCountMap = _this1._downKeyToFrameCountMap, upKeyToFrameCountMap = _this1._upKeyToFrameCountMap;
            for(var i = 0, n = nativeEvents.length; i < n; i++){
                var evt = nativeEvents[i];
                var codeKey = exports.Keys[evt.code];
                switch(evt.type){
                    case "keydown":
                        // Filter the repeated triggers of the keyboard.
                        if (curHeldDownKeyToIndexMap[codeKey] == null) {
                            curFrameDownList.add(codeKey);
                            curFrameHeldDownList.add(codeKey);
                            curHeldDownKeyToIndexMap[codeKey] = curFrameHeldDownList.length - 1;
                            downKeyToFrameCountMap[codeKey] = frameCount;
                        }
                        break;
                    case "keyup":
                        var delIndex = curHeldDownKeyToIndexMap[codeKey];
                        if (delIndex != null) {
                            curHeldDownKeyToIndexMap[codeKey] = null;
                            var swapCode = curFrameHeldDownList.deleteByIndex(delIndex);
                            swapCode && (curHeldDownKeyToIndexMap[swapCode] = delIndex);
                        }
                        curFrameUpList.add(codeKey);
                        upKeyToFrameCountMap[codeKey] = frameCount;
                        // Because on the mac, the keyup event is not responded to when the meta key is held down,
                        // in order to maintain the correct keystroke record, it is necessary to clear the record
                        // when the meta key is lifted.
                        // link: https://stackoverflow.com/questions/11818637/why-does-javascript-drop-keyup-events-when-the-metakey-is-pressed-on-mac-browser
                        if (SystemInfo.platform === Platform.Mac && (codeKey === exports.Keys.MetaLeft || codeKey === exports.Keys.MetaRight)) {
                            for(var i1 = 0, n1 = curFrameHeldDownList.length; i1 < n1; i1++){
                                curHeldDownKeyToIndexMap[curFrameHeldDownList.get(i1)] = null;
                            }
                            curFrameHeldDownList.length = 0;
                        }
                        break;
                }
            }
            nativeEvents.length = 0;
        }
    };
    /**
   * @internal
   */ _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
            this._htmlCanvas.addEventListener("keydown", this._onKeyEvent);
            this._htmlCanvas.addEventListener("keyup", this._onKeyEvent);
            this._hadListener = true;
        }
    };
    /**
   * @internal
   */ _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
            this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
            this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
            this._curHeldDownKeyToIndexMap.length = 0;
            this._curFrameHeldDownList.length = 0;
            this._curFrameDownList.length = 0;
            this._curFrameUpList.length = 0;
            this._nativeEvents.length = 0;
            this._hadListener = false;
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        if (this._hadListener) {
            this._htmlCanvas.removeEventListener("keydown", this._onKeyEvent);
            this._htmlCanvas.removeEventListener("keyup", this._onKeyEvent);
            this._hadListener = false;
        }
        this._curHeldDownKeyToIndexMap = null;
        this._upKeyToFrameCountMap = null;
        this._downKeyToFrameCountMap = null;
        this._nativeEvents = null;
        this._curFrameHeldDownList = null;
        this._curFrameDownList = null;
        this._curFrameUpList = null;
    };
    _proto._onKeyEvent = function _onKeyEvent(evt) {
        this._nativeEvents.push(evt);
    };
    return KeyboardManager;
}();

/**
 * Camera clear flags enumeration.
 */ var CameraClearFlags;
(function(CameraClearFlags) {
    CameraClearFlags[CameraClearFlags[/* Do nothing. */ "None"] = 0x0] = "None";
    CameraClearFlags[CameraClearFlags[/* Clear color with scene background. */ "Color"] = 0x1] = "Color";
    CameraClearFlags[CameraClearFlags[/* Clear depth only. */ "Depth"] = 0x2] = "Depth";
    CameraClearFlags[CameraClearFlags[/* Clear depth only. */ "Stencil"] = 0x4] = "Stencil";
    CameraClearFlags[CameraClearFlags[/* Clear color with scene background and depth. */ "ColorDepth"] = 0x3] = "ColorDepth";
    CameraClearFlags[CameraClearFlags[/* Clear color with scene background and stencil. */ "ColorStencil"] = 0x5] = "ColorStencil";
    CameraClearFlags[CameraClearFlags[/* Clear depth and stencil. */ "DepthStencil"] = 0x6] = "DepthStencil";
    CameraClearFlags[CameraClearFlags[/* Clear color with scene background, depth, and stencil. */ "All"] = 0x7] = "All";
})(CameraClearFlags || (CameraClearFlags = {}));

/**
 * Structure used to get information back from a raycast or a sweep.
 */ var HitResult = function HitResult() {
    /** The entity that was hit. */ this.entity = null;
    /** The distance from the ray's origin to the impact point. */ this.distance = 0;
    /** The impact point in world space where the ray hit the collider. */ this.point = new Vector3();
    /** The normal of the surface the ray hit. */ this.normal = new Vector3();
};

var Collision = function Collision() {
};

/**
 * A physics manager is a collection of colliders and constraints which can interact.
 */ var PhysicsManager = /*#__PURE__*/ function() {
    function PhysicsManager(engine) {
        var _this = this;
        /** @internal */ this._initialized = false;
        this._restTime = 0;
        this._colliders = new DisorderedArray();
        this._gravity = new Vector3(0, -9.81, 0);
        this._physicalObjectsMap = {};
        this._onContactEnter = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, len = scripts.length; i < len; i++){
                var script = scripts.get(i);
                if (!script._waitHandlingInValid) {
                    var collision = PhysicsManager._collision;
                    collision.shape = shape2;
                    script.onCollisionEnter(collision);
                }
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, len1 = scripts.length; i1 < len1; i1++){
                var script1 = scripts.get(i1);
                if (!script1._waitHandlingInValid) {
                    var collision1 = PhysicsManager._collision;
                    collision1.shape = shape1;
                    script1.onCollisionEnter(collision1);
                }
            }
        };
        this._onContactExit = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, len = scripts.length; i < len; i++){
                var script = scripts.get(i);
                if (!script._waitHandlingInValid) {
                    var collision = PhysicsManager._collision;
                    collision.shape = shape2;
                    script.onCollisionExit(collision);
                }
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, len1 = scripts.length; i1 < len1; i1++){
                var script1 = scripts.get(i1);
                if (!script1._waitHandlingInValid) {
                    var collision1 = PhysicsManager._collision;
                    collision1.shape = shape1;
                    script1.onCollisionExit(collision1);
                }
            }
        };
        this._onContactStay = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, len = scripts.length; i < len; i++){
                var script = scripts.get(i);
                if (!script._waitHandlingInValid) {
                    var collision = PhysicsManager._collision;
                    collision.shape = shape2;
                    script.onCollisionStay(collision);
                }
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, len1 = scripts.length; i1 < len1; i1++){
                var script1 = scripts.get(i1);
                if (!script1._waitHandlingInValid) {
                    var collision1 = PhysicsManager._collision;
                    collision1.shape = shape1;
                    script1.onCollisionStay(collision1);
                }
            }
        };
        this._onTriggerEnter = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, len = scripts.length; i < len; i++){
                var script = scripts.get(i);
                script._waitHandlingInValid || script.onTriggerEnter(shape2);
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, len1 = scripts.length; i1 < len1; i1++){
                var script1 = scripts.get(i1);
                script1._waitHandlingInValid || script1.onTriggerEnter(shape1);
            }
        };
        this._onTriggerExit = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, n = scripts.length; i < n; i++){
                var script = scripts.get(i);
                script._waitHandlingInValid || script.onTriggerExit(shape2);
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, n1 = scripts.length; i1 < n1; i1++){
                var script1 = scripts.get(i1);
                script1._waitHandlingInValid || script1.onTriggerExit(shape1);
            }
        };
        this._onTriggerStay = function(obj1, obj2) {
            var shape1 = _this._physicalObjectsMap[obj1];
            var shape2 = _this._physicalObjectsMap[obj2];
            var scripts = shape1.collider.entity._scripts;
            for(var i = 0, len = scripts.length; i < len; i++){
                var script = scripts.get(i);
                script._waitHandlingInValid || script.onTriggerStay(shape2);
            }
            scripts = shape2.collider.entity._scripts;
            for(var i1 = 0, len1 = scripts.length; i1 < len1; i1++){
                var script1 = scripts.get(i1);
                script1._waitHandlingInValid || script1.onTriggerStay(shape1);
            }
        };
        /** The fixed time step in seconds at which physics are performed. */ this.fixedTimeStep = 1 / 60;
        this._engine = engine;
        this._setGravity = this._setGravity.bind(this);
        //@ts-ignore
        this._gravity._onValueChanged = this._setGravity;
    }
    var _proto = PhysicsManager.prototype;
    _proto.raycast = function raycast(ray, distanceOrResult, layerMaskOrResult, outHitResult) {
        var _this = this;
        var hitResult;
        var distance = Number.MAX_VALUE;
        if (typeof distanceOrResult === "number") {
            distance = distanceOrResult;
        } else if (distanceOrResult != undefined) {
            hitResult = distanceOrResult;
        }
        var layerMask = Layer.Everything;
        if (typeof layerMaskOrResult === "number") {
            layerMask = layerMaskOrResult;
        } else if (layerMaskOrResult != undefined) {
            hitResult = layerMaskOrResult;
        }
        if (outHitResult) {
            hitResult = outHitResult;
        }
        var onRaycast = function(obj) {
            var shape = _this._physicalObjectsMap[obj];
            return shape.collider.entity.layer & layerMask && shape.isSceneQuery;
        };
        if (hitResult != undefined) {
            var result = this._nativePhysicsManager.raycast(ray, distance, onRaycast, function(idx, distance, position, normal) {
                hitResult.entity = _this._physicalObjectsMap[idx]._collider.entity;
                hitResult.distance = distance;
                hitResult.normal.copyFrom(normal);
                hitResult.point.copyFrom(position);
            });
            if (result) {
                return true;
            } else {
                hitResult.entity = null;
                hitResult.distance = 0;
                hitResult.point.set(0, 0, 0);
                hitResult.normal.set(0, 0, 0);
                return false;
            }
        } else {
            return this._nativePhysicsManager.raycast(ray, distance, onRaycast);
        }
    };
    /**
   * @internal
   */ _proto._initialize = function _initialize(physics) {
        PhysicsManager._nativePhysics = physics;
        this._nativePhysicsManager = PhysicsManager._nativePhysics.createPhysicsManager(this._onContactEnter, this._onContactExit, this._onContactStay, this._onTriggerEnter, this._onTriggerExit, this._onTriggerStay);
        this._initialized = true;
    };
    /**
   * Call on every frame to update pose of objects.
   * @internal
   */ _proto._update = function _update(deltaTime) {
        var _this = this, fixedTimeStep = _this.fixedTimeStep, nativePhysicsManager = _this._nativePhysicsManager;
        var componentsManager = this._engine._componentsManager;
        var simulateTime = this._restTime + deltaTime;
        var step = Math.floor(simulateTime / fixedTimeStep);
        this._restTime = simulateTime - step * fixedTimeStep;
        for(var i = 0; i < step; i++){
            componentsManager.callScriptOnPhysicsUpdate();
            this._callColliderOnUpdate();
            nativePhysicsManager.update(fixedTimeStep);
            this._callColliderOnLateUpdate();
        }
    };
    /**
   * Add ColliderShape into the manager.
   * @param colliderShape - The Collider Shape.
   * @internal
   */ _proto._addColliderShape = function _addColliderShape(colliderShape) {
        this._physicalObjectsMap[colliderShape.id] = colliderShape;
        this._nativePhysicsManager.addColliderShape(colliderShape._nativeShape);
    };
    /**
   * Remove ColliderShape.
   * @param colliderShape - The Collider Shape.
   * @internal
   */ _proto._removeColliderShape = function _removeColliderShape(colliderShape) {
        delete this._physicalObjectsMap[colliderShape.id];
        this._nativePhysicsManager.removeColliderShape(colliderShape._nativeShape);
    };
    /**
   * Add collider into the manager.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */ _proto._addCollider = function _addCollider(collider) {
        if (collider._index === -1) {
            collider._index = this._colliders.length;
            this._colliders.add(collider);
        }
        this._nativePhysicsManager.addCollider(collider._nativeCollider);
    };
    /**
   * Add character controller into the manager.
   * @param controller - Character Controller.
   * @internal
   */ _proto._addCharacterController = function _addCharacterController(controller) {
        if (controller._index === -1) {
            controller._index = this._colliders.length;
            this._colliders.add(controller);
        }
        this._nativePhysicsManager.addCharacterController(controller._nativeCollider);
    };
    /**
   * Remove collider.
   * @param collider - StaticCollider or DynamicCollider.
   * @internal
   */ _proto._removeCollider = function _removeCollider(collider) {
        var replaced = this._colliders.deleteByIndex(collider._index);
        replaced && (replaced._index = collider._index);
        collider._index = -1;
        this._nativePhysicsManager.removeCollider(collider._nativeCollider);
    };
    /**
   * Remove collider.
   * @param controller - Character Controller.
   * @internal
   */ _proto._removeCharacterController = function _removeCharacterController(controller) {
        var replaced = this._colliders.deleteByIndex(controller._index);
        replaced && (replaced._index = controller._index);
        controller._index = -1;
        this._nativePhysicsManager.removeCharacterController(controller._nativeCollider);
    };
    /**
   * @internal
   */ _proto._callColliderOnUpdate = function _callColliderOnUpdate() {
        var elements = this._colliders._elements;
        for(var i = this._colliders.length - 1; i >= 0; --i){
            elements[i]._onUpdate();
        }
    };
    /**
   * @internal
   */ _proto._callColliderOnLateUpdate = function _callColliderOnLateUpdate() {
        var elements = this._colliders._elements;
        for(var i = this._colliders.length - 1; i >= 0; --i){
            elements[i]._onLateUpdate();
        }
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._colliders.garbageCollection();
    };
    _proto._setGravity = function _setGravity() {
        this._nativePhysicsManager.setGravity(this._gravity);
    };
    _create_class$3(PhysicsManager, [
        {
            key: "gravity",
            get: /**
   * The gravity of physics scene.
   */ function get() {
                return this._gravity;
            },
            set: function set(value) {
                var gravity = this._gravity;
                if (gravity !== value) {
                    gravity.copyFrom(value);
                }
            }
        }
    ]);
    return PhysicsManager;
}();
(function() {
    PhysicsManager._collision = new Collision();
})();

/**
 * Describes how physics materials of the colliding objects are combined.
 */ var PhysicsMaterialCombineMode;
(function(PhysicsMaterialCombineMode) {
    PhysicsMaterialCombineMode[PhysicsMaterialCombineMode[/** Averages the friction/bounce of the two colliding materials. */ "Average"] = 0] = "Average";
    PhysicsMaterialCombineMode[PhysicsMaterialCombineMode[/** Uses the smaller friction/bounce of the two colliding materials. */ "Minimum"] = 1] = "Minimum";
    PhysicsMaterialCombineMode[PhysicsMaterialCombineMode[/** Multiplies the friction/bounce of the two colliding materials. */ "Multiply"] = 2] = "Multiply";
    PhysicsMaterialCombineMode[PhysicsMaterialCombineMode[/** Uses the larger friction/bounce of the two colliding materials. */ "Maximum"] = 3] = "Maximum";
})(PhysicsMaterialCombineMode || (PhysicsMaterialCombineMode = {}));

/**
 * Material class to represent a set of surface properties.
 */ var PhysicsMaterial = /*#__PURE__*/ function() {
    function PhysicsMaterial() {
        this._bounciness = 0.1;
        this._dynamicFriction = 0.1;
        this._staticFriction = 0.1;
        this._bounceCombine = PhysicsMaterialCombineMode.Average;
        this._frictionCombine = PhysicsMaterialCombineMode.Average;
        this._nativeMaterial = PhysicsManager._nativePhysics.createPhysicsMaterial(this._staticFriction, this._dynamicFriction, this._bounciness, this._bounceCombine, this._frictionCombine);
    }
    var _proto = PhysicsMaterial.prototype;
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._nativeMaterial.destroy();
    };
    _create_class$3(PhysicsMaterial, [
        {
            key: "bounciness",
            get: /**
   * The coefficient of bounciness.
   */ function get() {
                return this._bounciness;
            },
            set: function set(value) {
                if (this._bounciness !== value) {
                    this._bounciness = value;
                    this._nativeMaterial.setBounciness(value);
                }
            }
        },
        {
            key: "dynamicFriction",
            get: /**
   * The DynamicFriction value.
   */ function get() {
                return this._dynamicFriction;
            },
            set: function set(value) {
                if (this._dynamicFriction !== value) {
                    this._dynamicFriction = value;
                    this._nativeMaterial.setDynamicFriction(value);
                }
            }
        },
        {
            key: "staticFriction",
            get: /**
   * The coefficient of static friction.
   */ function get() {
                return this._staticFriction;
            },
            set: function set(value) {
                if (this._staticFriction !== value) {
                    this._staticFriction = value;
                    this._nativeMaterial.setStaticFriction(value);
                }
            }
        },
        {
            key: "bounceCombine",
            get: /**
   * The restitution combine mode.
   */ function get() {
                return this._bounceCombine;
            },
            set: function set(value) {
                if (this._bounceCombine !== value) {
                    this._bounceCombine = value;
                    this._nativeMaterial.setBounceCombine(value);
                }
            }
        },
        {
            key: "frictionCombine",
            get: /**
   * The friction combine mode.
   */ function get() {
                return this._frictionCombine;
            },
            set: function set(value) {
                if (this._frictionCombine !== value) {
                    this._frictionCombine = value;
                    this._nativeMaterial.setFrictionCombine(value);
                }
            }
        }
    ]);
    return PhysicsMaterial;
}();

var Collider = /*#__PURE__*/ function(Component) {
    _inherits$2(Collider, Component);
    function Collider(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        /** @internal */ _this._index = -1;
        _this._shapes = [];
        _this._updateFlag = _this.entity.transform.registerWorldChangeFlag();
        return _this;
    }
    var _proto = Collider.prototype;
    /**
   * Add collider shape on this collider.
   * @param shape - Collider shape
   */ _proto.addShape = function addShape(shape) {
        var oldCollider = shape._collider;
        if (oldCollider !== this) {
            if (oldCollider) {
                oldCollider.removeShape(shape);
            }
            this._shapes.push(shape);
            this.engine.physicsManager._addColliderShape(shape);
            shape._collider = this;
            this._nativeCollider.addShape(shape._nativeShape);
        }
    };
    /**
   * Remove a collider shape.
   * @param shape - The collider shape.
   */ _proto.removeShape = function removeShape(shape) {
        var index = this._shapes.indexOf(shape);
        if (index !== -1) {
            this._shapes.splice(index, 1);
            this.engine.physicsManager._removeColliderShape(shape);
            shape._collider = null;
            this._nativeCollider.removeShape(shape._nativeShape);
        }
    };
    /**
   * Remove all shape attached.
   */ _proto.clearShapes = function clearShapes() {
        var shapes = this._shapes;
        for(var i = 0, n = shapes.length; i < n; i++){
            var shape = shapes[i];
            this.engine.physicsManager._removeColliderShape(shape);
            shape._destroy();
            this._nativeCollider.removeShape(shape._nativeShape);
        }
        shapes.length = 0;
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
            var transform = this.entity.transform;
            this._nativeCollider.setWorldTransform(transform.worldPosition, transform.worldRotationQuaternion);
            var worldScale = transform.lossyWorldScale;
            for(var i = 0, n = this.shapes.length; i < n; i++){
                this.shapes[i]._nativeShape.setWorldScale(worldScale);
            }
            this._updateFlag.flag = false;
        }
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {};
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine.physicsManager._addCollider(this);
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine.physicsManager._removeCollider(this);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this.clearShapes();
        this._nativeCollider.destroy();
    };
    _create_class$3(Collider, [
        {
            key: "shapes",
            get: /**
   * The shapes of this collider.
   */ function get() {
                return this._shapes;
            }
        }
    ]);
    return Collider;
}(Component);
__decorate$1([
    ignoreClone
], Collider.prototype, "_index", void 0);
Collider = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], Collider);

/**
 * The up axis of the collider shape.
 */ var ControllerNonWalkableMode;
(function(ControllerNonWalkableMode) {
    ControllerNonWalkableMode[ControllerNonWalkableMode[/** Stops character from climbing up non-walkable slopes, but doesn't move it otherwise. */ "PreventClimbing"] = 0] = "PreventClimbing";
    ControllerNonWalkableMode[ControllerNonWalkableMode[/** Stops character from climbing up non-walkable slopes, and forces it to slide down those slopes. */ "PreventClimbingAndForceSliding"] = 1] = "PreventClimbingAndForceSliding";
})(ControllerNonWalkableMode || (ControllerNonWalkableMode = {}));

/**
 * The character controllers.
 */ var CharacterController = /*#__PURE__*/ function(Collider) {
    _inherits$2(CharacterController, Collider);
    function CharacterController(entity) {
        var _this;
        _this = Collider.call(this, entity) || this;
        _this._stepOffset = 0.5;
        _this._nonWalkableMode = ControllerNonWalkableMode.PreventClimbing;
        _this._upDirection = new Vector3(0, 1, 0);
        _this._slopeLimit = 0.707;
        _this._nativeCollider = PhysicsManager._nativePhysics.createCharacterController();
        _this._setUpDirection = _this._setUpDirection.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._upDirection._onValueChanged = _this._setUpDirection;
        return _this;
    }
    var _proto = CharacterController.prototype;
    /**
   * Moves the character using a "collide-and-slide" algorithm.
   * @param disp - Displacement vector
   * @param minDist - The minimum travelled distance to consider.
   * @param elapsedTime - Time elapsed since last call
   * @return flags - The ControllerCollisionFlag
   */ _proto.move = function move(disp, minDist, elapsedTime) {
        return this._nativeCollider.move(disp, minDist, elapsedTime);
    };
    /**
   * Add collider shape on this controller.
   * @param shape - Collider shape
   */ _proto.addShape = function addShape(shape) {
        if (this._shapes.length > 0) {
            throw "only allow single shape on controller!";
        }
        Collider.prototype.addShape.call(this, shape);
        this._updateFlag.flag = true;
    };
    /**
   * Remove all shape attached.
   */ _proto.clearShapes = function clearShapes() {
        if (this._shapes.length > 0) {
            Collider.prototype.removeShape.call(this, this._shapes[0]);
        }
    };
    /**
   * @internal
   */ _proto._onUpdate = function _onUpdate() {
        if (this._updateFlag.flag) {
            var transform = this.entity.transform;
            var shapes = this.shapes;
            this._nativeCollider.setWorldPosition(transform.worldPosition);
            var worldScale = transform.lossyWorldScale;
            for(var i = 0, n = shapes.length; i < n; i++){
                shapes[i]._nativeShape.setWorldScale(worldScale);
            }
            this._updateFlag.flag = false;
        }
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {
        var position = this.entity.transform.worldPosition;
        this._nativeCollider.getWorldPosition(position);
        this.entity.transform.worldPosition = position;
        this._updateFlag.flag = false;
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine.physicsManager._addCharacterController(this);
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine.physicsManager._removeCharacterController(this);
    };
    _proto._setUpDirection = function _setUpDirection() {
        this._nativeCollider.setUpDirection(this._upDirection);
    };
    _create_class$3(CharacterController, [
        {
            key: "stepOffset",
            get: /**
   * The step offset for the controller.
   */ function get() {
                return this._stepOffset;
            },
            set: function set(value) {
                if (this._stepOffset !== value) {
                    this._stepOffset = value;
                    this._nativeCollider.setStepOffset(value);
                }
            }
        },
        {
            key: "nonWalkableMode",
            get: /**
   * The value of the non-walkable mode.
   */ function get() {
                return this._nonWalkableMode;
            },
            set: function set(value) {
                if (this._nonWalkableMode !== value) {
                    this._nonWalkableMode = value;
                    this._nativeCollider.setNonWalkableMode(value);
                }
            }
        },
        {
            key: "upDirection",
            get: /**
   * The up direction for the controller.
   */ function get() {
                return this._upDirection;
            },
            set: function set(value) {
                if (this._upDirection !== value) {
                    this._upDirection.copyFrom(value);
                }
            }
        },
        {
            key: "slopeLimit",
            get: /**
   * The slope limit for the controller.
   */ function get() {
                return this._slopeLimit;
            },
            set: function set(value) {
                if (this._slopeLimit !== value) {
                    this._slopeLimit = value;
                    this._nativeCollider.setSlopeLimit(value);
                }
            }
        }
    ]);
    return CharacterController;
}(Collider);

/**
 * Abstract class for collider shapes.
 */ var ColliderShape = /*#__PURE__*/ function() {
    function ColliderShape() {
        this._isTrigger = false;
        this._rotation = new Vector3();
        this._position = new Vector3();
        this._contactOffset = 0.02;
        /**
   * @internal
   * @beta
   * Whether raycast can select it.
   */ this.isSceneQuery = true;
        this._material = new PhysicsMaterial();
        this._id = ColliderShape._idGenerator++;
        this._setRotation = this._setRotation.bind(this);
        this._setPosition = this._setPosition.bind(this);
        //@ts-ignore
        this._rotation._onValueChanged = this._setRotation;
        //@ts-ignore
        this._position._onValueChanged = this._setPosition;
    }
    var _proto = ColliderShape.prototype;
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._material._destroy();
        this._nativeShape.destroy();
    };
    _proto._setPosition = function _setPosition() {
        this._nativeShape.setPosition(this._position);
    };
    _proto._setRotation = function _setRotation() {
        this._nativeShape.setRotation(this._rotation);
    };
    _create_class$3(ColliderShape, [
        {
            key: "collider",
            get: /**
   * Collider owner of this shape.
   */ function get() {
                return this._collider;
            }
        },
        {
            key: "id",
            get: /**
   * Unique id for this shape.
   */ function get() {
                return this._id;
            }
        },
        {
            key: "contactOffset",
            get: /**
   * Contact offset for this shape.
   */ function get() {
                return this._contactOffset;
            },
            set: function set(value) {
                if (this._contactOffset !== value) {
                    this._contactOffset = value;
                    this._nativeShape.setContactOffset(value);
                }
            }
        },
        {
            key: "material",
            get: /**
   * Physical material.
   */ function get() {
                return this._material;
            },
            set: function set(value) {
                if (this._material !== value) {
                    this._material = value;
                    this._nativeShape.setMaterial(value._nativeMaterial);
                }
            }
        },
        {
            key: "rotation",
            get: /**
   * The local rotation of this ColliderShape.
   */ function get() {
                return this._rotation;
            },
            set: function set(value) {
                if (this._rotation != value) {
                    this._rotation.copyFrom(value);
                }
            }
        },
        {
            key: "position",
            get: /**
   * The local position of this ColliderShape.
   */ function get() {
                return this._position;
            },
            set: function set(value) {
                if (this._position !== value) {
                    this._position.copyFrom(value);
                }
            }
        },
        {
            key: "isTrigger",
            get: /**
   * True for TriggerShape, false for SimulationShape.
   */ function get() {
                return this._isTrigger;
            },
            set: function set(value) {
                if (this._isTrigger !== value) {
                    this._isTrigger = value;
                    this._nativeShape.setIsTrigger(value);
                }
            }
        }
    ]);
    return ColliderShape;
}();
(function() {
    ColliderShape._idGenerator = 0;
})();

/**
 * Physical collider shape for box.
 */ var BoxColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(BoxColliderShape, ColliderShape);
    function BoxColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this;
        _this._size = new Vector3(1, 1, 1);
        _this._nativeShape = PhysicsManager._nativePhysics.createBoxColliderShape(_this._id, _this._size, _this._material._nativeMaterial);
        _this._setSize = _this._setSize.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._size._onValueChanged = _this._setSize;
        return _this;
    }
    var _proto = BoxColliderShape.prototype;
    _proto._setSize = function _setSize() {
        this._nativeShape.setSize(this._size);
    };
    _create_class$3(BoxColliderShape, [
        {
            key: "size",
            get: /**
   * Size of box shape.
   */ function get() {
                return this._size;
            },
            set: function set(value) {
                if (this._size !== value) {
                    this._size.copyFrom(value);
                }
            }
        }
    ]);
    return BoxColliderShape;
}(ColliderShape);

/**
 * Physical collider shape for sphere.
 */ var SphereColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(SphereColliderShape, ColliderShape);
    function SphereColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this;
        _this._radius = 1;
        _this._nativeShape = PhysicsManager._nativePhysics.createSphereColliderShape(_this._id, _this._radius, _this._material._nativeMaterial);
        return _this;
    }
    _create_class$3(SphereColliderShape, [
        {
            key: "radius",
            get: /**
   * Radius of sphere shape.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (this._radius !== value) {
                    this._radius = value;
                    this._nativeShape.setRadius(value);
                }
            }
        }
    ]);
    return SphereColliderShape;
}(ColliderShape);

/**
 * Physical collider shape plane.
 */ var PlaneColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(PlaneColliderShape, ColliderShape);
    function PlaneColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this;
        _this._nativeShape = PhysicsManager._nativePhysics.createPlaneColliderShape(_this._id, _this._material._nativeMaterial);
        return _this;
    }
    return PlaneColliderShape;
}(ColliderShape);

/**
 * The up axis of the collider shape.
 */ var ColliderShapeUpAxis;
(function(ColliderShapeUpAxis) {
    ColliderShapeUpAxis[ColliderShapeUpAxis[/** Up axis is X. */ "X"] = 0] = "X";
    ColliderShapeUpAxis[ColliderShapeUpAxis[/** Up axis is Y. */ "Y"] = 1] = "Y";
    ColliderShapeUpAxis[ColliderShapeUpAxis[/** Up axis is Z. */ "Z"] = 2] = "Z";
})(ColliderShapeUpAxis || (ColliderShapeUpAxis = {}));

/**
 * Physical collider shape for capsule.
 */ var CapsuleColliderShape = /*#__PURE__*/ function(ColliderShape) {
    _inherits$2(CapsuleColliderShape, ColliderShape);
    function CapsuleColliderShape() {
        var _this;
        _this = ColliderShape.call(this) || this;
        _this._radius = 1;
        _this._height = 2;
        _this._upAxis = ColliderShapeUpAxis.Y;
        _this._nativeShape = PhysicsManager._nativePhysics.createCapsuleColliderShape(_this._id, _this._radius, _this._height, _this._material._nativeMaterial);
        return _this;
    }
    _create_class$3(CapsuleColliderShape, [
        {
            key: "radius",
            get: /**
   * Radius of capsule.
   */ function get() {
                return this._radius;
            },
            set: function set(value) {
                if (this._radius !== value) {
                    this._radius = value;
                    this._nativeShape.setRadius(value);
                }
            }
        },
        {
            key: "height",
            get: /**
   * Height of capsule.
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._height = value;
                    this._nativeShape.setHeight(value);
                }
            }
        },
        {
            key: "upAxis",
            get: /**
   * Up axis of capsule.
   */ function get() {
                return this._upAxis;
            },
            set: function set(value) {
                if (this._upAxis !== value) {
                    this._upAxis = value;
                    this._nativeShape.setUpAxis(value);
                }
            }
        }
    ]);
    return CapsuleColliderShape;
}(ColliderShape);

var Joint = /*#__PURE__*/ function(Component) {
    _inherits$2(Joint, Component);
    function Joint(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        _this._connectedCollider = new JointCollider();
        _this._collider = new JointCollider();
        _this._force = 0;
        _this._torque = 0;
        _this._connectedCollider.localPosition = new Vector3();
        return _this;
    }
    _create_class$3(Joint, [
        {
            key: "connectedCollider",
            get: /**
   * The connected collider.
   */ function get() {
                return this._connectedCollider.collider;
            },
            set: function set(value) {
                if (this._connectedCollider.collider !== value) {
                    this._connectedCollider.collider = value;
                    this._nativeJoint.setConnectedCollider(value._nativeCollider);
                }
            }
        },
        {
            key: "connectedAnchor",
            get: /**
   * The connected anchor position.
   * @remarks If connectedCollider is set, this anchor is relative offset, or the anchor is world position.
   */ function get() {
                return this._connectedCollider.localPosition;
            },
            set: function set(value) {
                var connectedAnchor = this._connectedCollider.localPosition;
                if (value !== connectedAnchor) {
                    connectedAnchor.copyFrom(value);
                }
                this._nativeJoint.setConnectedAnchor(value);
            }
        },
        {
            key: "connectedMassScale",
            get: /**
   *  The scale to apply to the inverse mass of collider 0 for resolving this constraint.
   */ function get() {
                return this._connectedCollider.massScale;
            },
            set: function set(value) {
                if (value !== this._connectedCollider.massScale) {
                    this._connectedCollider.massScale = value;
                    this._nativeJoint.setConnectedMassScale(value);
                }
            }
        },
        {
            key: "connectedInertiaScale",
            get: /**
   * The scale to apply to the inverse inertia of collider0 for resolving this constraint.
   */ function get() {
                return this._connectedCollider.inertiaScale;
            },
            set: function set(value) {
                if (value !== this._connectedCollider.inertiaScale) {
                    this._connectedCollider.inertiaScale = value;
                    this._nativeJoint.setConnectedInertiaScale(value);
                }
            }
        },
        {
            key: "massScale",
            get: /**
   * The scale to apply to the inverse mass of collider 1 for resolving this constraint.
   */ function get() {
                return this._collider.massScale;
            },
            set: function set(value) {
                if (value !== this._collider.massScale) {
                    this._collider.massScale = value;
                    this._nativeJoint.setMassScale(value);
                }
            }
        },
        {
            key: "inertiaScale",
            get: /**
   * The scale to apply to the inverse inertia of collider1 for resolving this constraint.
   */ function get() {
                return this._collider.inertiaScale;
            },
            set: function set(value) {
                if (value !== this._collider.inertiaScale) {
                    this._collider.inertiaScale = value;
                    this._nativeJoint.setInertiaScale(value);
                }
            }
        },
        {
            key: "breakForce",
            get: /**
   * The maximum force the joint can apply before breaking.
   */ function get() {
                return this._force;
            },
            set: function set(value) {
                if (value !== this._force) {
                    this._force = value;
                    this._nativeJoint.setBreakForce(value);
                }
            }
        },
        {
            key: "breakTorque",
            get: /**
   * The maximum torque the joint can apply before breaking.
   */ function get() {
                return this._torque;
            },
            set: function set(value) {
                if (value !== this._torque) {
                    this._torque = value;
                    this._nativeJoint.setBreakTorque(value);
                }
            }
        }
    ]);
    return Joint;
}(Component);
Joint = __decorate$1([
    dependentComponents(Collider, DependentMode.CheckOnly)
], Joint);
/**
 * @internal
 */ var JointCollider = function JointCollider() {
    this.collider = null;
    this.massScale = 0;
    this.inertiaScale = 0;
};

/*
 * A fixed joint permits no relative movement between two colliders. ie the colliders are glued together.
 */ var FixedJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(FixedJoint, Joint);
    function FixedJoint() {
        return Joint.apply(this, arguments);
    }
    var _proto = FixedJoint.prototype;
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createFixedJoint(collider.collider._nativeCollider);
    };
    return FixedJoint;
}(Joint);

/**
 * Flags specific to the Hinge Joint.
 * @internal
 */ var HingeJointFlag;
(function(HingeJointFlag) {
    HingeJointFlag[HingeJointFlag[/** enable the limit */ "LimitEnabled"] = 1] = "LimitEnabled";
    HingeJointFlag[HingeJointFlag[/** enable the drive */ "DriveEnabled"] = 2] = "DriveEnabled";
    HingeJointFlag[HingeJointFlag[/** if the existing velocity is beyond the drive velocity, do not add force */ "DriveFreeSpin"] = 4] = "DriveFreeSpin";
})(HingeJointFlag || (HingeJointFlag = {}));

/**
 * A joint which behaves in a similar way to a hinge or axle.
 */ var HingeJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(HingeJoint, Joint);
    function HingeJoint() {
        var _this;
        _this = Joint.apply(this, arguments) || this;
        _this._axis = new Vector3(1, 0, 0);
        _this._hingeFlags = 0;
        _this._useSpring = false;
        return _this;
    }
    var _proto = HingeJoint.prototype;
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.localPosition = new Vector3();
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createHingeJoint(collider.collider._nativeCollider);
    };
    _create_class$3(HingeJoint, [
        {
            key: "axis",
            get: /**
   * The anchor rotation.
   */ function get() {
                return this._axis;
            },
            set: function set(value) {
                var axis = this._axis;
                if (value !== axis) {
                    axis.copyFrom(value);
                }
                this._nativeJoint.setAxis(axis);
            }
        },
        {
            key: "swingOffset",
            get: /**
   * The swing offset.
   */ function get() {
                return this._collider.localPosition;
            },
            set: function set(value) {
                var swingOffset = this._collider.localPosition;
                if (value !== swingOffset) {
                    swingOffset.copyFrom(value);
                }
                this._nativeJoint.setSwingOffset(swingOffset);
            }
        },
        {
            key: "angle",
            get: /**
   * The current angle in degrees of the joint relative to its rest position.
   */ function get() {
                return this._nativeJoint.getAngle();
            }
        },
        {
            key: "velocity",
            get: /**
   * The angular velocity of the joint in degrees per second.
   */ function get() {
                return this._nativeJoint.getVelocity();
            }
        },
        {
            key: "useLimits",
            get: /**
   * Enables the joint's limits. Disabled by default.
   */ function get() {
                return (this._hingeFlags & HingeJointFlag.LimitEnabled) == HingeJointFlag.LimitEnabled;
            },
            set: function set(value) {
                if (value !== this.useLimits) {
                    this._hingeFlags |= HingeJointFlag.LimitEnabled;
                }
                this._nativeJoint.setHingeJointFlag(HingeJointFlag.LimitEnabled, value);
            }
        },
        {
            key: "useMotor",
            get: /**
   * Enables the joint's motor. Disabled by default.
   */ function get() {
                return (this._hingeFlags & HingeJointFlag.DriveEnabled) == HingeJointFlag.DriveEnabled;
            },
            set: function set(value) {
                if (value !== this.useMotor) {
                    this._hingeFlags |= HingeJointFlag.DriveEnabled;
                }
                this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveEnabled, value);
            }
        },
        {
            key: "useSpring",
            get: /**
   * Enables the joint's spring. Disabled by default.
   */ function get() {
                return this._useSpring;
            },
            set: function set(value) {
                if (this._useSpring !== value) {
                    this._useSpring = value;
                    this.limits = this._limits;
                }
            }
        },
        {
            key: "motor",
            get: /**
   * The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
   */ function get() {
                return this._jointMonitor;
            },
            set: function set(value) {
                if (this._jointMonitor !== value) {
                    this._jointMonitor = value;
                    this._nativeJoint.setDriveVelocity(value.targetVelocity);
                    this._nativeJoint.setDriveForceLimit(value.forceLimit);
                    this._nativeJoint.setDriveGearRatio(value.gearRation);
                    this._nativeJoint.setHingeJointFlag(HingeJointFlag.DriveFreeSpin, value.freeSpin);
                }
            }
        },
        {
            key: "limits",
            get: /**
   * Limit of angular rotation (in degrees) on the hinge joint.
   */ function get() {
                return this._limits;
            },
            set: function set(value) {
                if (this._limits !== value) {
                    this._limits = value;
                    if (this.useSpring) {
                        this._nativeJoint.setSoftLimit(value.min, value.max, value.stiffness, value.damping);
                    } else {
                        this._nativeJoint.setHardLimit(value.min, value.max, value.contactDistance);
                    }
                }
            }
        }
    ]);
    return HingeJoint;
}(Joint);

/**
 * A joint that maintains an upper or lower bound (or both) on the distance between two points on different objects.
 */ var SpringJoint = /*#__PURE__*/ function(Joint) {
    _inherits$2(SpringJoint, Joint);
    function SpringJoint() {
        var _this;
        _this = Joint.apply(this, arguments) || this;
        _this._minDistance = 0;
        _this._maxDistance = 0;
        _this._tolerance = 0.25;
        _this._stiffness = 0;
        _this._damping = 0;
        return _this;
    }
    var _proto = SpringJoint.prototype;
    /**
   * @internal
   */ _proto._onAwake = function _onAwake() {
        var collider = this._collider;
        collider.localPosition = new Vector3();
        collider.collider = this.entity.getComponent(Collider);
        this._nativeJoint = PhysicsManager._nativePhysics.createSpringJoint(collider.collider._nativeCollider);
    };
    _create_class$3(SpringJoint, [
        {
            key: "swingOffset",
            get: /**
   * The swing offset.
   */ function get() {
                return this._collider.localPosition;
            },
            set: function set(value) {
                var swingOffset = this._collider.localPosition;
                if (value !== swingOffset) {
                    swingOffset.copyFrom(value);
                }
                this._nativeJoint.setSwingOffset(value);
            }
        },
        {
            key: "minDistance",
            get: /**
   * The minimum distance.
   */ function get() {
                return this._minDistance;
            },
            set: function set(value) {
                if (this._minDistance !== value) {
                    this._minDistance = value;
                    this._nativeJoint.setMinDistance(value);
                }
            }
        },
        {
            key: "maxDistance",
            get: /**
   * The maximum distance.
   */ function get() {
                return this._maxDistance;
            },
            set: function set(value) {
                if (this._maxDistance !== value) {
                    this._maxDistance = value;
                    this._nativeJoint.setMaxDistance(value);
                }
            }
        },
        {
            key: "tolerance",
            get: /**
   * The distance beyond the allowed range at which the joint becomes active.
   */ function get() {
                return this._tolerance;
            },
            set: function set(value) {
                if (this._tolerance !== value) {
                    this._tolerance = value;
                    this._nativeJoint.setTolerance(value);
                }
            }
        },
        {
            key: "stiffness",
            get: /**
   * The spring strength of the joint.
   */ function get() {
                return this._stiffness;
            },
            set: function set(value) {
                if (this._stiffness !== value) {
                    this._stiffness = value;
                    this._nativeJoint.setStiffness(value);
                }
            }
        },
        {
            key: "damping",
            get: /**
   * The degree of damping of the joint spring of the joint.
   */ function get() {
                return this._damping;
            },
            set: function set(value) {
                if (this._damping !== value) {
                    this._damping = value;
                    this._nativeJoint.setDamping(value);
                }
            }
        }
    ]);
    return SpringJoint;
}(Joint);

/**
 * JointLimits is used to limit the joints angle.
 */ var JointLimits = function JointLimits() {
    /** The upper angular limit (in degrees) of the joint. */ this.max = 0;
    /** The lower angular limit (in degrees) of the joint. */ this.min = 0;
    /** Distance inside the limit value at which the limit will be considered to be active by the solver. */ this.contactDistance = -1;
    /** The spring forces used to reach the target position. */ this.stiffness = 0;
    /** The damper force uses to dampen the spring. */ this.damping = 0;
};

/**
 * The JointMotor is used to motorize a joint.
 */ var JointMotor = function JointMotor() {
    /** The motor will apply a force up to force to achieve targetVelocity. */ this.targetVelocity = 0;
    /** The force limit.*/ this.forceLimit = Number.MAX_VALUE;
    /** Gear ration for the motor */ this.gearRation = 1.0;
    /** If freeSpin is enabled the motor will only accelerate but never slow down. */ this.freeSpin = false;
};

/**
 * The up axis of the collider shape.
 */ var ControllerCollisionFlag;
(function(ControllerCollisionFlag) {
    ControllerCollisionFlag[ControllerCollisionFlag[/** Character is colliding to the sides. */ "Sides"] = 1] = "Sides";
    ControllerCollisionFlag[ControllerCollisionFlag[/** Character has collision above. */ "Up"] = 2] = "Up";
    ControllerCollisionFlag[ControllerCollisionFlag[/** Character has collision below. */ "Down"] = 4] = "Down";
})(ControllerCollisionFlag || (ControllerCollisionFlag = {}));

/**
 * A static collider component that will not move.
 * @remarks Mostly used for object which always stays at the same place and never moves around.
 */ var StaticCollider = /*#__PURE__*/ function(Collider) {
    _inherits$2(StaticCollider, Collider);
    function StaticCollider(entity) {
        var _this;
        _this = Collider.call(this, entity) || this;
        var transform = _this.entity.transform;
        _this._nativeCollider = PhysicsManager._nativePhysics.createStaticCollider(transform.worldPosition, transform.worldRotationQuaternion);
        return _this;
    }
    return StaticCollider;
}(Collider);

/**
 * A dynamic collider can act with self-defined movement or physical force.
 */ var DynamicCollider = /*#__PURE__*/ function(Collider) {
    _inherits$2(DynamicCollider, Collider);
    function DynamicCollider(entity) {
        var _this;
        _this = Collider.call(this, entity) || this;
        _this._linearDamping = 0;
        _this._angularDamping = 0.05;
        _this._linearVelocity = new Vector3();
        _this._angularVelocity = new Vector3();
        _this._mass = 1.0;
        _this._centerOfMass = new Vector3();
        _this._inertiaTensor = new Vector3(1, 1, 1);
        _this._maxAngularVelocity = 100;
        _this._maxDepenetrationVelocity = 1000;
        _this._solverIterations = 4;
        _this._isKinematic = false;
        _this._constraints = 0;
        _this._collisionDetectionMode = /** Continuous collision detection is off for this dynamic collider. */ 0;
        _this._sleepThreshold = 5e-3;
        var transform = _this.entity.transform;
        _this._nativeCollider = PhysicsManager._nativePhysics.createDynamicCollider(transform.worldPosition, transform.worldRotationQuaternion);
        _this._setLinearVelocity = _this._setLinearVelocity.bind(_assert_this_initialized(_this));
        _this._setAngularVelocity = _this._setAngularVelocity.bind(_assert_this_initialized(_this));
        _this._setCenterOfMass = _this._setCenterOfMass.bind(_assert_this_initialized(_this));
        _this._setInertiaTensor = _this._setInertiaTensor.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._linearVelocity._onValueChanged = _this._setLinearVelocity;
        //@ts-ignore
        _this._angularVelocity._onValueChanged = _this._setAngularVelocity;
        //@ts-ignore
        _this._centerOfMass._onValueChanged = _this._setCenterOfMass;
        //@ts-ignore
        _this._inertiaTensor._onValueChanged = _this._setInertiaTensor;
        return _this;
    }
    var _proto = DynamicCollider.prototype;
    /**
   * Apply a force to the DynamicCollider.
   * @param force - The force make the collider move
   */ _proto.applyForce = function applyForce(force) {
        this._nativeCollider.addForce(force);
    };
    /**
   * Apply a torque to the DynamicCollider.
   * @param torque - The force make the collider rotate
   */ _proto.applyTorque = function applyTorque(torque) {
        this._nativeCollider.addTorque(torque);
    };
    _proto.move = function move(positionOrRotation, rotation) {
        this._nativeCollider.move(positionOrRotation, rotation);
    };
    /**
   * Forces a collider to sleep at least one frame.
   */ _proto.sleep = function sleep() {
        this._nativeCollider.sleep();
    };
    /**
   * Forces a collider to wake up.
   */ _proto.wakeUp = function wakeUp() {
        this._nativeCollider.wakeUp();
    };
    /**
   * @internal
   */ _proto._onLateUpdate = function _onLateUpdate() {
        var transform = this.entity.transform;
        var worldPosition = transform.worldPosition, worldRotationQuaternion = transform.worldRotationQuaternion;
        this._nativeCollider.getWorldTransform(worldPosition, worldRotationQuaternion);
        this._updateFlag.flag = false;
    };
    _proto._setLinearVelocity = function _setLinearVelocity() {
        this._nativeCollider.setLinearVelocity(this._linearVelocity);
    };
    _proto._setAngularVelocity = function _setAngularVelocity() {
        this._nativeCollider.setAngularVelocity(this._angularVelocity);
    };
    _proto._setCenterOfMass = function _setCenterOfMass() {
        this._nativeCollider.setCenterOfMass(this._centerOfMass);
    };
    _proto._setInertiaTensor = function _setInertiaTensor() {
        this._nativeCollider.setInertiaTensor(this._inertiaTensor);
    };
    _create_class$3(DynamicCollider, [
        {
            key: "linearDamping",
            get: /**
   * The linear damping of the dynamic collider.
   */ function get() {
                return this._linearDamping;
            },
            set: function set(value) {
                if (this._linearDamping !== value) {
                    this._linearDamping = value;
                    this._nativeCollider.setLinearDamping(value);
                }
            }
        },
        {
            key: "angularDamping",
            get: /**
   * The angular damping of the dynamic collider.
   */ function get() {
                return this._angularDamping;
            },
            set: function set(value) {
                if (this._angularDamping !== value) {
                    this._angularDamping = value;
                    this._nativeCollider.setAngularDamping(value);
                }
            }
        },
        {
            key: "linearVelocity",
            get: /**
   * The linear velocity vector of the dynamic collider measured in world unit per second.
   */ function get() {
                return this._linearVelocity;
            },
            set: function set(value) {
                if (this._linearVelocity !== value) {
                    this._linearVelocity.copyFrom(value);
                }
            }
        },
        {
            key: "angularVelocity",
            get: /**
   * The angular velocity vector of the dynamic collider measured in radians per second.
   */ function get() {
                return this._angularVelocity;
            },
            set: function set(value) {
                if (this._angularVelocity !== value) {
                    this._angularVelocity.copyFrom(value);
                }
            }
        },
        {
            key: "mass",
            get: /**
   * The mass of the dynamic collider.
   */ function get() {
                return this._mass;
            },
            set: function set(value) {
                if (this._mass !== value) {
                    this._mass = value;
                    this._nativeCollider.setMass(value);
                }
            }
        },
        {
            key: "centerOfMass",
            get: /**
   * The center of mass relative to the transform's origin.
   */ function get() {
                return this._centerOfMass;
            },
            set: function set(value) {
                if (this._centerOfMass !== value) {
                    this._centerOfMass.copyFrom(value);
                }
            }
        },
        {
            key: "inertiaTensor",
            get: /**
   * The diagonal inertia tensor of mass relative to the center of mass.
   */ function get() {
                return this._inertiaTensor;
            },
            set: function set(value) {
                if (this._inertiaTensor !== value) {
                    this._inertiaTensor.copyFrom(value);
                }
            }
        },
        {
            key: "maxAngularVelocity",
            get: /**
   * The maximum angular velocity of the collider measured in radians per second. (Default 7) range { 0, infinity }.
   */ function get() {
                return this._maxAngularVelocity;
            },
            set: function set(value) {
                if (this._maxAngularVelocity !== value) {
                    this._maxAngularVelocity = value;
                    this._nativeCollider.setMaxAngularVelocity(value);
                }
            }
        },
        {
            key: "maxDepenetrationVelocity",
            get: /**
   * Maximum velocity of a collider when moving out of penetrating state.
   */ function get() {
                return this._maxDepenetrationVelocity;
            },
            set: function set(value) {
                if (this._maxDepenetrationVelocity !== value) {
                    this._maxDepenetrationVelocity = value;
                    this._nativeCollider.setMaxDepenetrationVelocity(value);
                }
            }
        },
        {
            key: "sleepThreshold",
            get: /**
   * The mass-normalized energy threshold, below which objects start going to sleep.
   */ function get() {
                return this._sleepThreshold;
            },
            set: function set(value) {
                if (value !== this._sleepThreshold) {
                    this._sleepThreshold = value;
                    this._nativeCollider.setSleepThreshold(value);
                }
            }
        },
        {
            key: "solverIterations",
            get: /**
   * The solverIterations determines how accurately collider joints and collision contacts are resolved.
   */ function get() {
                return this._solverIterations;
            },
            set: function set(value) {
                if (this._solverIterations !== value) {
                    this._solverIterations = value;
                    this._nativeCollider.setSolverIterations(value);
                }
            }
        },
        {
            key: "isKinematic",
            get: /**
   * Controls whether physics affects the dynamic collider.
   */ function get() {
                return this._isKinematic;
            },
            set: function set(value) {
                if (this._isKinematic !== value) {
                    this._isKinematic = value;
                    this._nativeCollider.setIsKinematic(value);
                }
            }
        },
        {
            key: "constraints",
            get: /**
   * The particular rigid dynamic lock flag.
   */ function get() {
                return this._constraints;
            },
            set: function set(value) {
                if (this._constraints !== value) {
                    this._constraints = value;
                    this._nativeCollider.setConstraints(value);
                }
            }
        },
        {
            key: "collisionDetectionMode",
            get: /**
   * The colliders' collision detection mode.
   */ function get() {
                return this._collisionDetectionMode;
            },
            set: function set(value) {
                if (this._collisionDetectionMode !== value) {
                    this._collisionDetectionMode = value;
                    this._nativeCollider.setCollisionDetectionMode(value);
                }
            }
        }
    ]);
    return DynamicCollider;
}(Collider);
var CollisionDetectionMode;
(function(CollisionDetectionMode) {
    CollisionDetectionMode[CollisionDetectionMode["Discrete"] = 0] = "Discrete";
    CollisionDetectionMode[CollisionDetectionMode[/** Continuous collision detection is on for colliding with static mesh geometry. */ "Continuous"] = 1] = "Continuous";
    CollisionDetectionMode[CollisionDetectionMode[/** Continuous collision detection is on for colliding with static and dynamic geometry. */ "ContinuousDynamic"] = 2] = "ContinuousDynamic";
    CollisionDetectionMode[CollisionDetectionMode[/** Speculative continuous collision detection is on for static and dynamic geometries */ "ContinuousSpeculative"] = 3] = "ContinuousSpeculative";
})(CollisionDetectionMode || (CollisionDetectionMode = {}));
var DynamicColliderConstraints;
(function(DynamicColliderConstraints) {
    DynamicColliderConstraints[DynamicColliderConstraints[/** Not Freeze. */ "None"] = 0] = "None";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze motion along the X-axis. */ "FreezePositionX"] = 1] = "FreezePositionX";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze motion along the Y-axis. */ "FreezePositionY"] = 2] = "FreezePositionY";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze motion along the Z-axis. */ "FreezePositionZ"] = 4] = "FreezePositionZ";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze rotation along the X-axis. */ "FreezeRotationX"] = 8] = "FreezeRotationX";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze rotation along the Y-axis. */ "FreezeRotationY"] = 16] = "FreezeRotationY";
    DynamicColliderConstraints[DynamicColliderConstraints[/** Freeze rotation along the Z-axis. */ "FreezeRotationZ"] = 32] = "FreezeRotationZ";
})(DynamicColliderConstraints || (DynamicColliderConstraints = {}));

/**
 * Defines values that specify the buttons on a pointer device.
 * Refer to the W3C standards:
 * (https://www.w3.org/TR/uievents/#dom-mouseevent-button)
 * (https://www.w3.org/TR/uievents/#dom-mouseevent-buttons)
 * Refer to Microsoft's documentation.(https://docs.microsoft.com/en-us/dotnet/api/system.windows.input.mousebutton?view=windowsdesktop-6.0)
 */ exports.PointerButton = void 0;
(function(PointerButton) {
    PointerButton[PointerButton[/** No button. */ "None"] = 0x0] = "None";
    PointerButton[PointerButton[/** Indicate the primary pointer of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value. */ "Primary"] = 0x1] = "Primary";
    PointerButton[PointerButton[/** Indicate the secondary pointer (in general, the right button, often used to display a context menu). */ "Secondary"] = 0x2] = "Secondary";
    PointerButton[PointerButton[/** Indicate the auxiliary pointer (in general, the middle button, often combined with a mouse wheel). */ "Auxiliary"] = 0x4] = "Auxiliary";
    PointerButton[PointerButton[/** Indicate the X1 (back) pointer. */ "XButton1"] = 0x8] = "XButton1";
    PointerButton[PointerButton[/** Indicate the X2 (forward) pointer. */ "XButton2"] = 0x10] = "XButton2";
    PointerButton[PointerButton[/** Indicate the X3 pointer. */ "XButton3"] = 0x20] = "XButton3";
    PointerButton[PointerButton[/** Indicate the X4 pointer. */ "XButton4"] = 0x40] = "XButton4";
    PointerButton[PointerButton[/** Indicate the X5 pointer. */ "XButton5"] = 0x80] = "XButton5";
    PointerButton[PointerButton[/** Indicate the X6 pointer. */ "XButton6"] = 0x100] = "XButton6";
    PointerButton[PointerButton[/** Indicate the X7 pointer. */ "XButton7"] = 0x200] = "XButton7";
    PointerButton[PointerButton[/** Indicate the X8 pointer. */ "XButton8"] = 0x400] = "XButton8";
})(exports.PointerButton || (exports.PointerButton = {}));
/**
 * @internal
 */ var _pointerDec2BinMap = [
    0x1,
    0x4,
    0x2,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400
];
/**
 * @internal
 */ var _pointerBin2DecMap = {
    /** Primary */ 0x1: 0,
    /** Secondary */ 0x2: 2,
    /** Auxiliary */ 0x4: 1,
    /** XButton1 */ 0x8: 3,
    /** XButton2 */ 0x10: 4,
    /** XButton3 */ 0x20: 5,
    /** XButton4 */ 0x40: 6,
    /** XButton5 */ 0x80: 7,
    /** XButton6 */ 0x100: 8,
    /** XButton7 */ 0x200: 9,
    /** XButton8 */ 0x400: 10
};

/**
 * Pointer Manager.
 * @internal
 */ var PointerManager = /*#__PURE__*/ function() {
    function PointerManager(engine) {
        /** @internal */ this._pointers = [];
        /** @internal */ this._multiPointerEnabled = true;
        /** @internal */ this._buttons = exports.PointerButton.None;
        /** @internal */ this._upMap = [];
        /** @internal */ this._downMap = [];
        /** @internal */ this._upList = new DisorderedArray();
        /** @internal */ this._downList = new DisorderedArray();
        this._nativeEvents = [];
        this._hadListener = false;
        // @ts-ignore
        var htmlCanvas = engine._canvas._webCanvas;
        this._engine = engine;
        this._canvas = engine.canvas;
        this._htmlCanvas = htmlCanvas;
        this._onPointerEvent = this._onPointerEvent.bind(this);
        this._updatePointerWithPhysics = this._updatePointerWithPhysics.bind(this);
        this._updatePointerWithoutPhysics = this._updatePointerWithoutPhysics.bind(this);
        this._onFocus();
        // If there are no compatibility issues, navigator.maxTouchPoints should be used here
        this._pointerPool = new Array(11);
    }
    var _proto = PointerManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this = this, pointers = _this._pointers, nativeEvents = _this._nativeEvents;
        // Clean up the pointer released in the previous frame
        var lastIndex = pointers.length - 1;
        if (lastIndex >= 0) {
            for(var i = lastIndex; i >= 0; i--){
                if (pointers[i].phase === PointerPhase.Leave) {
                    pointers.splice(i, 1);
                }
            }
        }
        // Generate the pointer received for this frame
        lastIndex = nativeEvents.length - 1;
        if (lastIndex >= 0) {
            for(var i1 = 0; i1 <= lastIndex; i1++){
                var _this__getPointer;
                var evt = nativeEvents[i1];
                (_this__getPointer = this._getPointer(evt.pointerId)) == null ? void 0 : _this__getPointer._events.push(evt);
            }
            nativeEvents.length = 0;
        }
        // Pointer handles its own events
        this._upList.length = this._downList.length = 0;
        this._buttons = exports.PointerButton.None;
        lastIndex = pointers.length - 1;
        if (lastIndex >= 0) {
            var frameCount = this._engine.time.frameCount;
            var updatePointer = this._engine.physicsManager._initialized ? this._updatePointerWithPhysics : this._updatePointerWithoutPhysics;
            var clientRect = this._htmlCanvas.getBoundingClientRect();
            var _this__htmlCanvas = this._htmlCanvas, clientWidth = _this__htmlCanvas.clientWidth, clientHeight = _this__htmlCanvas.clientHeight;
            var _this__canvas = this._canvas, width = _this__canvas.width, height = _this__canvas.height;
            for(var i2 = lastIndex; i2 >= 0; i2--){
                var pointer = pointers[i2];
                pointer._upList.length = pointer._downList.length = 0;
                updatePointer(frameCount, pointer, clientRect, clientWidth, clientHeight, width, height);
                this._buttons |= pointer.pressedButtons;
            }
        }
    };
    /**
   * @internal
   */ _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
            var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
            htmlCanvas.addEventListener("pointerdown", onPointerEvent);
            htmlCanvas.addEventListener("pointerup", onPointerEvent);
            htmlCanvas.addEventListener("pointerleave", onPointerEvent);
            htmlCanvas.addEventListener("pointermove", onPointerEvent);
            htmlCanvas.addEventListener("pointercancel", onPointerEvent);
            this._hadListener = true;
        }
    };
    /**
   * @internal
   */ _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
            var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
            htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
            htmlCanvas.removeEventListener("pointerup", onPointerEvent);
            htmlCanvas.removeEventListener("pointerleave", onPointerEvent);
            htmlCanvas.removeEventListener("pointermove", onPointerEvent);
            htmlCanvas.removeEventListener("pointercancel", onPointerEvent);
            this._hadListener = false;
            this._downList.length = 0;
            this._upList.length = 0;
            var _this1 = this, pointers = _this1._pointers;
            for(var i = pointers.length - 1; i >= 0; i--){
                pointers[i].phase = PointerPhase.Leave;
            }
            pointers.length = 0;
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        // @ts-ignore
        if (this._hadListener) {
            var _this = this, htmlCanvas = _this._htmlCanvas, onPointerEvent = _this._onPointerEvent;
            htmlCanvas.removeEventListener("pointerdown", onPointerEvent);
            htmlCanvas.removeEventListener("pointerup", onPointerEvent);
            htmlCanvas.removeEventListener("pointerleave", onPointerEvent);
            htmlCanvas.removeEventListener("pointermove", onPointerEvent);
            htmlCanvas.removeEventListener("pointercancel", onPointerEvent);
            this._hadListener = false;
        }
        this._pointerPool.length = 0;
        this._pointers.length = 0;
        this._downList.length = 0;
        this._upList.length = 0;
        this._htmlCanvas = null;
        this._engine = null;
    };
    _proto._onPointerEvent = function _onPointerEvent(evt) {
        evt.type === "pointerdown" && this._htmlCanvas.focus();
        this._nativeEvents.push(evt);
    };
    _proto._getIndexByPointerID = function _getIndexByPointerID(pointerId) {
        var _this = this, pointers = _this._pointers;
        for(var i = pointers.length - 1; i >= 0; i--){
            if (pointers[i]._uniqueID === pointerId) {
                return i;
            }
        }
        return -1;
    };
    _proto._getPointer = function _getPointer(pointerId) {
        var _this = this, pointers = _this._pointers;
        var index = this._getIndexByPointerID(pointerId);
        if (index >= 0) {
            return pointers[index];
        } else {
            var lastCount = pointers.length;
            if (lastCount === 0 || this._multiPointerEnabled) {
                var _this1 = this, pointerPool = _this1._pointerPool;
                // Get Pointer smallest index
                var i = 0;
                for(; i < lastCount; i++){
                    if (pointers[i].id > i) {
                        break;
                    }
                }
                var pointer = pointerPool[i];
                if (!pointer) {
                    pointer = pointerPool[i] = new Pointer(i);
                }
                pointer._uniqueID = pointerId;
                pointers.splice(i, 0, pointer);
                return pointer;
            } else {
                return null;
            }
        }
    };
    _proto._pointerRayCast = function _pointerRayCast(normalizedX, normalizedY) {
        var point = PointerManager._tempPoint, ray = PointerManager._tempRay, hitResult = PointerManager._tempHitResult;
        var _this__engine_sceneManager_activeScene = this._engine.sceneManager.activeScene, cameras = _this__engine_sceneManager_activeScene._activeCameras;
        for(var i = cameras.length - 1; i >= 0; i--){
            var camera = cameras[i];
            if (!camera.enabled || camera.renderTarget) {
                continue;
            }
            var _camera_viewport = camera.viewport, vpX = _camera_viewport.x, vpY = _camera_viewport.y, vpW = _camera_viewport.z, vpH = _camera_viewport.w;
            if (normalizedX >= vpX && normalizedY >= vpY && normalizedX - vpX <= vpW && normalizedY - vpY <= vpH) {
                point.set((normalizedX - vpX) / vpW, (normalizedY - vpY) / vpH);
                if (this._engine.physicsManager.raycast(camera.viewportPointToRay(point, ray), Number.MAX_VALUE, camera.cullingMask, hitResult)) {
                    return hitResult.entity;
                } else if (camera.clearFlags & CameraClearFlags.Color) {
                    return null;
                }
            }
        }
    };
    _proto._updatePointerWithPhysics = function _updatePointerWithPhysics(frameCount, pointer, rect, clientW, clientH, canvasW, canvasH) {
        var events = pointer._events, position = pointer.position;
        var length = events.length;
        if (length > 0) {
            var _this = this, _upList = _this._upList, _upMap = _this._upMap, _downList = _this._downList, _downMap = _this._downMap;
            var latestEvent = events[length - 1];
            var normalizedX = (latestEvent.clientX - rect.left) / clientW;
            var normalizedY = (latestEvent.clientY - rect.top) / clientH;
            var currX = normalizedX * canvasW;
            var currY = normalizedY * canvasH;
            pointer.deltaPosition.set(currX - position.x, currY - position.y);
            position.set(currX, currY);
            pointer._firePointerDrag();
            var rayCastEntity = this._pointerRayCast(normalizedX, normalizedY);
            pointer._firePointerExitAndEnter(rayCastEntity);
            for(var i = 0; i < length; i++){
                var event = events[i];
                var button = event.button;
                pointer.button = _pointerDec2BinMap[button] || exports.PointerButton.None;
                pointer.pressedButtons = event.buttons;
                switch(event.type){
                    case "pointerdown":
                        _downList.add(button);
                        _downMap[button] = frameCount;
                        pointer._downList.add(button);
                        pointer._downMap[button] = frameCount;
                        pointer.phase = PointerPhase.Down;
                        pointer._firePointerDown(rayCastEntity);
                        break;
                    case "pointerup":
                        _upList.add(button);
                        _upMap[button] = frameCount;
                        pointer._upList.add(button);
                        pointer._upMap[button] = frameCount;
                        pointer.phase = PointerPhase.Up;
                        pointer._firePointerUpAndClick(rayCastEntity);
                        break;
                    case "pointermove":
                        pointer.phase = PointerPhase.Move;
                        break;
                    case "pointerleave":
                    case "pointercancel":
                        pointer.phase = PointerPhase.Leave;
                        pointer._firePointerExitAndEnter(null);
                }
            }
            pointer._events.length = 0;
        } else {
            pointer.deltaPosition.set(0, 0);
            pointer.phase = PointerPhase.Stationary;
            pointer._firePointerDrag();
            pointer._firePointerExitAndEnter(this._pointerRayCast(position.x / canvasW, position.y / canvasH));
        }
    };
    _proto._updatePointerWithoutPhysics = function _updatePointerWithoutPhysics(frameCount, pointer, rect, clientW, clientH, canvasW, canvasH) {
        var events = pointer._events;
        var length = events.length;
        if (length > 0) {
            var position = pointer.position;
            var latestEvent = events[length - 1];
            var currX = (latestEvent.clientX - rect.left) / clientW * canvasW;
            var currY = (latestEvent.clientY - rect.top) / clientH * canvasH;
            pointer.deltaPosition.set(currX - position.x, currY - position.y);
            position.set(currX, currY);
            pointer.button = _pointerDec2BinMap[latestEvent.button] || exports.PointerButton.None;
            pointer.pressedButtons = latestEvent.buttons;
            var _this = this, _upList = _this._upList, _upMap = _this._upMap, _downList = _this._downList, _downMap = _this._downMap;
            for(var i = 0; i < length; i++){
                var button = events[i].button;
                switch(events[i].type){
                    case "pointerdown":
                        _downList.add(button);
                        _downMap[button] = frameCount;
                        pointer._downList.add(button);
                        pointer._downMap[button] = frameCount;
                        pointer.phase = PointerPhase.Down;
                        break;
                    case "pointerup":
                        _upList.add(button);
                        _upMap[button] = frameCount;
                        pointer._upList.add(button);
                        pointer._upMap[button] = frameCount;
                        pointer.phase = PointerPhase.Up;
                        break;
                    case "pointermove":
                        pointer.phase = PointerPhase.Move;
                        break;
                    case "pointerleave":
                    case "pointercancel":
                        pointer.phase = PointerPhase.Leave;
                }
            }
            pointer._events.length = 0;
        } else {
            pointer.deltaPosition.set(0, 0);
            pointer.phase = PointerPhase.Stationary;
        }
    };
    return PointerManager;
}();
(function() {
    PointerManager._tempRay = new Ray();
})();
(function() {
    PointerManager._tempPoint = new Vector2();
})();
(function() {
    PointerManager._tempHitResult = new HitResult();
})();

/**
 * Wheel Manager.
 * @internal
 */ var WheelManager = /*#__PURE__*/ function() {
    function WheelManager(engine) {
        /** @internal */ this._delta = new Vector3();
        this._nativeEvents = [];
        // @ts-ignore
        var htmlCanvas = engine._canvas._webCanvas;
        this._onWheelEvent = this._onWheelEvent.bind(this);
        htmlCanvas.addEventListener("wheel", this._onWheelEvent);
        this._canvas = htmlCanvas;
        this._hadListener = true;
    }
    var _proto = WheelManager.prototype;
    /**
   * @internal
   */ _proto._update = function _update() {
        var _this = this, delta = _this._delta;
        delta.set(0, 0, 0);
        var _this1 = this, nativeEvents = _this1._nativeEvents;
        if (nativeEvents.length > 0) {
            for(var i = nativeEvents.length - 1; i >= 0; i--){
                var evt = nativeEvents[i];
                delta.x += evt.deltaX;
                delta.y += evt.deltaY;
                delta.z += evt.deltaZ;
            }
            nativeEvents.length = 0;
        }
    };
    /**
   * @internal
   */ _proto._onFocus = function _onFocus() {
        if (!this._hadListener) {
            this._canvas.addEventListener("wheel", this._onWheelEvent);
            this._hadListener = true;
        }
    };
    /**
   * @internal
   */ _proto._onBlur = function _onBlur() {
        if (this._hadListener) {
            this._canvas.removeEventListener("wheel", this._onWheelEvent);
            this._nativeEvents.length = 0;
            this._delta.set(0, 0, 0);
            this._hadListener = false;
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        if (this._hadListener) {
            this._canvas.removeEventListener("wheel", this._onWheelEvent);
            this._hadListener = false;
        }
        this._nativeEvents = null;
    };
    _proto._onWheelEvent = function _onWheelEvent(evt) {
        evt.cancelable && evt.preventDefault();
        this._nativeEvents.push(evt);
    };
    return WheelManager;
}();

/**
 * InputManager manages device input such as mouse, touch, keyboard, etc.
 */ var InputManager = /*#__PURE__*/ function() {
    function InputManager(engine) {
        /** Sometimes the input module will not be initialized, such as off-screen rendering. */ this._initialized = false;
        this._engine = engine;
        // @ts-ignore
        var canvas = engine._canvas._webCanvas;
        if (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$2(canvas, PlatformManager$1.polyfill.OffscreenCanvas)) {
            this._wheelManager = new WheelManager(engine);
            this._pointerManager = new PointerManager(engine);
            this._keyboardManager = new KeyboardManager(engine);
            this._onBlur = this._onBlur.bind(this);
            PlatformManager$1.polyfill.window.addEventListener("blur", this._onBlur);
            this._onFocus = this._onFocus.bind(this);
            PlatformManager$1.polyfill.window.addEventListener("focus", this._onFocus);
            this._initialized = true;
        }
    }
    var _proto = InputManager.prototype;
    /**
   * Whether the key is being held down, if there is no parameter, return whether any key is being held down.
   * @param key - The keys of the keyboard
   * @returns Whether the key is being held down
   */ _proto.isKeyHeldDown = function isKeyHeldDown(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameHeldDownList.length > 0;
            } else {
                return this._keyboardManager._curHeldDownKeyToIndexMap[key] != null;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the key starts to be pressed down during the current frame, if there is no parameter, return whether any key starts to be pressed down during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key starts to be pressed down during the current frame
   */ _proto.isKeyDown = function isKeyDown(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameDownList.length > 0;
            } else {
                return this._keyboardManager._downKeyToFrameCountMap[key] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the key is released during the current frame, if there is no parameter, return whether any key released during the current frame.
   * @param key - The keys of the keyboard
   * @returns Whether the key is released during the current frame
   */ _proto.isKeyUp = function isKeyUp(key) {
        if (this._initialized) {
            if (key === undefined) {
                return this._keyboardManager._curFrameUpList.length > 0;
            } else {
                return this._keyboardManager._upKeyToFrameCountMap[key] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer is being held down, if there is no parameter, return whether any pointer is being held down.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer is being held down
   */ _proto.isPointerHeldDown = function isPointerHeldDown(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._buttons !== 0;
            } else {
                return (this._pointerManager._buttons & pointerButton) !== 0;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer starts to be pressed down during the current frame, if there is no parameter, return whether any pointer starts to be pressed down during the current frame.
   * @param pointerButton - The pointerButton on a pointer device
   * @returns Whether the pointer starts to be pressed down during the current frame
   */ _proto.isPointerDown = function isPointerDown(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._downList.length > 0;
            } else {
                return this._pointerManager._downMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * Whether the pointer is released during the current frame, if there is no parameter, return whether any pointer released during the current frame.
   * @param pointerButton - The pointerButtons on a mouse device
   * @returns Whether the pointer is released during the current frame
   */ _proto.isPointerUp = function isPointerUp(pointerButton) {
        if (this._initialized) {
            if (pointerButton === undefined) {
                return this._pointerManager._upList.length > 0;
            } else {
                return this._pointerManager._upMap[_pointerBin2DecMap[pointerButton]] === this._engine.time.frameCount;
            }
        } else {
            return false;
        }
    };
    /**
   * @internal
   */ _proto._update = function _update() {
        if (this._initialized) {
            this._wheelManager._update();
            this._pointerManager._update();
            this._keyboardManager._update();
        }
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        if (this._initialized) {
            PlatformManager$1.polyfill.window.removeEventListener("blur", this._onBlur);
            PlatformManager$1.polyfill.window.removeEventListener("focus", this._onFocus);
            this._wheelManager._destroy();
            this._pointerManager._destroy();
            this._keyboardManager._destroy();
        }
    };
    _proto._onBlur = function _onBlur() {
        this._wheelManager._onBlur();
        this._pointerManager._onBlur();
        this._keyboardManager._onBlur();
    };
    _proto._onFocus = function _onFocus() {
        this._wheelManager._onFocus();
        this._pointerManager._onFocus();
        this._keyboardManager._onFocus();
    };
    _create_class$3(InputManager, [
        {
            key: "pointers",
            get: /**
   * Pointer list.
   */ function get() {
                return this._initialized ? this._pointerManager._pointers : [];
            }
        },
        {
            key: "multiPointerEnabled",
            get: /**
   *  Whether to handle multi-pointer.
   */ function get() {
                return this._initialized ? this._pointerManager._multiPointerEnabled : false;
            },
            set: function set(enabled) {
                this._initialized && (this._pointerManager._multiPointerEnabled = enabled);
            }
        },
        {
            key: "wheelDelta",
            get: /**
   * Get the change of the scroll wheel on the x-axis.
   * @returns Change value
   */ function get() {
                return this._initialized ? this._wheelManager._delta : null;
            }
        }
    ]);
    return InputManager;
}();

/**
 * Number of cascades to use for directional light shadows.
 */ var ShadowCascadesMode;
(function(ShadowCascadesMode) {
    ShadowCascadesMode[ShadowCascadesMode[/** No cascades */ "NoCascades"] = 1] = "NoCascades";
    ShadowCascadesMode[ShadowCascadesMode[/** Two cascades */ "TwoCascades"] = 2] = "TwoCascades";
    ShadowCascadesMode[ShadowCascadesMode[/** Four cascades */ "FourCascades"] = 4] = "FourCascades";
})(ShadowCascadesMode || (ShadowCascadesMode = {}));

/**
 * Default shadow resolution.
 */ var ShadowResolution;
(function(ShadowResolution) {
    ShadowResolution[ShadowResolution[/** Low shadow map resolution. */ "Low"] = 0] = "Low";
    ShadowResolution[ShadowResolution[/** Medium shadow map resolution. */ "Medium"] = 1] = "Medium";
    ShadowResolution[ShadowResolution[/**  High shadow map resolution. */ "High"] = 2] = "High";
    ShadowResolution[ShadowResolution[/** Very high shadow map resolution. */ "VeryHigh"] = 3] = "VeryHigh";
})(ShadowResolution || (ShadowResolution = {}));

/**
 * Determines which type of shadows should be used.
 */ exports.ShadowType = void 0;
(function(ShadowType) {
    ShadowType[ShadowType[/** Disable Shadows. */ "None"] = 0] = "None";
    ShadowType[ShadowType[/** Hard Shadows Only. */ "Hard"] = 1] = "Hard";
    ShadowType[ShadowType[/** Cast "soft" shadows with low range. */ "SoftLow"] = 2] = "SoftLow";
    ShadowType[ShadowType[/** Cast "soft" shadows with large range. */ "SoftHigh"] = 3] = "SoftHigh";
})(exports.ShadowType || (exports.ShadowType = {}));

/**
 * Light base class.
 */ var Light = /*#__PURE__*/ function(Component) {
    _inherits$2(Light, Component);
    function Light() {
        var _this;
        _this = Component.apply(this, arguments) || this;
        /** Light Intensity */ _this.intensity = 1;
        /**
   * Culling mask - which layers the light affect.
   * @remarks Support bit manipulation, corresponding to `Layer`.
   */ _this.cullingMask = Layer.Everything;
        /** How this light casts shadows. */ _this.shadowType = exports.ShadowType.None;
        /** Shadow bias.*/ _this.shadowBias = 1;
        /** Shadow mapping normal-based bias. */ _this.shadowNormalBias = 1;
        /** Near plane value to use for shadow frustums. */ _this.shadowNearPlane = 0.1;
        /** Shadow intensity, the larger the value, the clearer and darker the shadow. */ _this.shadowStrength = 1.0;
        /** @internal */ _this._lightIndex = -1;
        _this._color = new Color$1(1, 1, 1, 1);
        _this._lightColor = new Color$1();
        return _this;
    }
    var _proto = Light.prototype;
    /**
   * Light Color, include intensity.
   * @internal
   */ _proto._getLightIntensityColor = function _getLightIntensityColor() {
        this._lightColor.r = this.color.r * this.intensity;
        this._lightColor.g = this.color.g * this.intensity;
        this._lightColor.b = this.color.b * this.intensity;
        this._lightColor.a = this.color.a * this.intensity;
        return this._lightColor;
    };
    _create_class$3(Light, [
        {
            key: "color",
            get: /**
   * Light Color.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "viewMatrix",
            get: /**
   * View matrix.
   */ function get() {
                if (!this._viewMat) this._viewMat = new Matrix();
                Matrix.invert(this.entity.transform.worldMatrix, this._viewMat);
                return this._viewMat;
            }
        },
        {
            key: "inverseViewMatrix",
            get: /**
   * Inverse view matrix.
   */ function get() {
                if (!this._inverseViewMat) this._inverseViewMat = new Matrix();
                Matrix.invert(this.viewMatrix, this._inverseViewMat);
                return this._inverseViewMat;
            }
        }
    ]);
    return Light;
}(Component);
(function() {
    /**
   * Each type of light source is at most 10, beyond which it will not take effect.
   * */ Light._maxLight = 10;
})();
__decorate$1([
    ignoreClone
], Light.prototype, "_lightIndex", void 0);

/**
 * Directional light.
 */ var DirectLight = /*#__PURE__*/ function(Light) {
    _inherits$2(DirectLight, Light);
    function DirectLight() {
        var _this;
        _this = Light.apply(this, arguments) || this;
        _this._reverseDirection = new Vector3();
        return _this;
    }
    var _proto = DirectLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var lightColor = this._getLightIntensityColor();
        var direction = this.direction;
        var data = DirectLight._combinedData;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        if (this.engine.settings.colorSpace === ColorSpace.Linear) {
            data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
            data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
            data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
        } else {
            data.color[colorStart] = lightColor.r;
            data.color[colorStart + 1] = lightColor.g;
            data.color[colorStart + 2] = lightColor.b;
        }
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
    };
    /**
   * Mount to the current Scene.
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine._lightManager._attachDirectLight(this);
    };
    /**
   * Unmount from the current Scene.
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine._lightManager._detachDirectLight(this);
    };
    /**
   * @internal
   */ DirectLight._updateShaderData = function _updateShaderData(shaderData) {
        var data = DirectLight._combinedData;
        shaderData.setIntArray(DirectLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(DirectLight._colorProperty, data.color);
        shaderData.setFloatArray(DirectLight._directionProperty, data.direction);
    };
    _create_class$3(DirectLight, [
        {
            key: "direction",
            get: /**
   * Get direction.
   */ function get() {
                return this.entity.transform.worldForward;
            }
        },
        {
            key: "reverseDirection",
            get: /**
   * Get the opposite direction of the directional light direction.
   */ function get() {
                Vector3.scale(this.direction, -1, this._reverseDirection);
                return this._reverseDirection;
            }
        },
        {
            key: "_shadowProjectionMatrix",
            get: /**
   * @internal
   */ function get() {
                throw "Unknown!";
            }
        }
    ]);
    return DirectLight;
}(Light);
(function() {
    DirectLight._cullingMaskProperty = ShaderProperty.getByName("scene_DirectLightCullingMask");
})();
(function() {
    DirectLight._colorProperty = ShaderProperty.getByName("scene_DirectLightColor");
})();
(function() {
    DirectLight._directionProperty = ShaderProperty.getByName("scene_DirectLightDirection");
})();
(function() {
    DirectLight._combinedData = {
        cullingMask: new Int32Array(Light._maxLight * 2),
        color: new Float32Array(Light._maxLight * 3),
        direction: new Float32Array(Light._maxLight * 3)
    };
})();

/**
 * Point light.
 */ var PointLight = /*#__PURE__*/ function(Light) {
    _inherits$2(PointLight, Light);
    function PointLight() {
        var _this;
        _this = Light.apply(this, arguments) || this;
        /** Defines a distance cutoff at which the light's intensity must be considered zero. */ _this.distance = 100;
        return _this;
    }
    var _proto = PointLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var lightColor = this._getLightIntensityColor();
        var lightPosition = this.position;
        var data = PointLight._combinedData;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        if (this.engine.settings.colorSpace === ColorSpace.Linear) {
            data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
            data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
            data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
        } else {
            data.color[colorStart] = lightColor.r;
            data.color[colorStart + 1] = lightColor.g;
            data.color[colorStart + 2] = lightColor.b;
        }
        data.position[positionStart] = lightPosition.x;
        data.position[positionStart + 1] = lightPosition.y;
        data.position[positionStart + 2] = lightPosition.z;
        data.distance[distanceStart] = this.distance;
    };
    /**
   * Mount to the current Scene.
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine._lightManager._attachPointLight(this);
    };
    /**
   * Unmount from the current Scene.
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine._lightManager._detachPointLight(this);
    };
    /**
   * @internal
   */ PointLight._updateShaderData = function _updateShaderData(shaderData) {
        var data = PointLight._combinedData;
        shaderData.setIntArray(PointLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(PointLight._colorProperty, data.color);
        shaderData.setFloatArray(PointLight._positionProperty, data.position);
        shaderData.setFloatArray(PointLight._distanceProperty, data.distance);
    };
    _create_class$3(PointLight, [
        {
            key: "position",
            get: /**
   * Get light position.
   */ function get() {
                return this.entity.transform.worldPosition;
            }
        },
        {
            key: "_shadowProjectionMatrix",
            get: /**
   * @internal
   */ function get() {
                throw "Unknown!";
            }
        }
    ]);
    return PointLight;
}(Light);
(function() {
    PointLight._cullingMaskProperty = ShaderProperty.getByName("scene_PointLightCullingMask");
})();
(function() {
    PointLight._colorProperty = ShaderProperty.getByName("scene_PointLightColor");
})();
(function() {
    PointLight._positionProperty = ShaderProperty.getByName("scene_PointLightPosition");
})();
(function() {
    PointLight._distanceProperty = ShaderProperty.getByName("scene_PointLightDistance");
})();
(function() {
    PointLight._combinedData = {
        cullingMask: new Int32Array(Light._maxLight * 2),
        color: new Float32Array(Light._maxLight * 3),
        position: new Float32Array(Light._maxLight * 3),
        distance: new Float32Array(Light._maxLight)
    };
})();

/**
 * Spot light.
 */ var SpotLight = /*#__PURE__*/ function(Light) {
    _inherits$2(SpotLight, Light);
    function SpotLight() {
        var _this;
        _this = Light.apply(this, arguments) || this;
        /** Defines a distance cutoff at which the light's intensity must be considered zero. */ _this.distance = 100;
        /** Angle, in radians, from centre of spotlight where falloff begins. */ _this.angle = Math.PI / 6;
        /** Angle, in radians, from falloff begins to ends. */ _this.penumbra = Math.PI / 12;
        _this._inverseDirection = new Vector3();
        _this._projectMatrix = new Matrix();
        return _this;
    }
    var _proto = SpotLight.prototype;
    /**
   * @internal
   */ _proto._appendData = function _appendData(lightIndex) {
        var cullingMaskStart = lightIndex * 2;
        var colorStart = lightIndex * 3;
        var positionStart = lightIndex * 3;
        var directionStart = lightIndex * 3;
        var distanceStart = lightIndex;
        var penumbraCosStart = lightIndex;
        var angleCosStart = lightIndex;
        var lightColor = this._getLightIntensityColor();
        var position = this.position;
        var direction = this.direction;
        var data = SpotLight._combinedData;
        var cullingMask = this.cullingMask;
        data.cullingMask[cullingMaskStart] = cullingMask & 65535;
        data.cullingMask[cullingMaskStart + 1] = cullingMask >>> 16 & 65535;
        if (this.engine.settings.colorSpace === ColorSpace.Linear) {
            data.color[colorStart] = Color$1.gammaToLinearSpace(lightColor.r);
            data.color[colorStart + 1] = Color$1.gammaToLinearSpace(lightColor.g);
            data.color[colorStart + 2] = Color$1.gammaToLinearSpace(lightColor.b);
        } else {
            data.color[colorStart] = lightColor.r;
            data.color[colorStart + 1] = lightColor.g;
            data.color[colorStart + 2] = lightColor.b;
        }
        data.position[positionStart] = position.x;
        data.position[positionStart + 1] = position.y;
        data.position[positionStart + 2] = position.z;
        data.direction[directionStart] = direction.x;
        data.direction[directionStart + 1] = direction.y;
        data.direction[directionStart + 2] = direction.z;
        data.distance[distanceStart] = this.distance;
        data.angleCos[angleCosStart] = Math.cos(this.angle);
        data.penumbraCos[penumbraCosStart] = Math.cos(this.angle + this.penumbra);
    };
    /**
   * Mount to the current Scene.
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine._lightManager._attachSpotLight(this);
    };
    /**
   * Unmount from the current Scene.
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine._lightManager._detachSpotLight(this);
    };
    /**
   * @internal
   */ SpotLight._updateShaderData = function _updateShaderData(shaderData) {
        var data = SpotLight._combinedData;
        shaderData.setIntArray(SpotLight._cullingMaskProperty, data.cullingMask);
        shaderData.setFloatArray(SpotLight._colorProperty, data.color);
        shaderData.setFloatArray(SpotLight._positionProperty, data.position);
        shaderData.setFloatArray(SpotLight._directionProperty, data.direction);
        shaderData.setFloatArray(SpotLight._distanceProperty, data.distance);
        shaderData.setFloatArray(SpotLight._angleCosProperty, data.angleCos);
        shaderData.setFloatArray(SpotLight._penumbraCosProperty, data.penumbraCos);
    };
    _create_class$3(SpotLight, [
        {
            key: "position",
            get: /**
   * Get light position.
   */ function get() {
                return this.entity.transform.worldPosition;
            }
        },
        {
            key: "direction",
            get: /**
   * Get light direction.
   */ function get() {
                return this.entity.transform.worldForward;
            }
        },
        {
            key: "reverseDirection",
            get: /**
   * Get the opposite direction of the spotlight.
   */ function get() {
                Vector3.scale(this.direction, -1, this._inverseDirection);
                return this._inverseDirection;
            }
        },
        {
            key: "_shadowProjectionMatrix",
            get: /**
   * @internal
   */ function get() {
                var matrix = this._projectMatrix;
                var fov = Math.min(Math.PI / 2, this.angle * 2 * Math.sqrt(2));
                Matrix.perspective(fov, 1, this.shadowNearPlane, this.distance + this.shadowNearPlane, matrix);
                return matrix;
            }
        }
    ]);
    return SpotLight;
}(Light);
(function() {
    SpotLight._cullingMaskProperty = ShaderProperty.getByName("scene_SpotLightCullingMask");
})();
(function() {
    SpotLight._colorProperty = ShaderProperty.getByName("scene_SpotLightColor");
})();
(function() {
    SpotLight._positionProperty = ShaderProperty.getByName("scene_SpotLightPosition");
})();
(function() {
    SpotLight._directionProperty = ShaderProperty.getByName("scene_SpotLightDirection");
})();
(function() {
    SpotLight._distanceProperty = ShaderProperty.getByName("scene_SpotLightDistance");
})();
(function() {
    SpotLight._angleCosProperty = ShaderProperty.getByName("scene_SpotLightAngleCos");
})();
(function() {
    SpotLight._penumbraCosProperty = ShaderProperty.getByName("scene_SpotLightPenumbraCos");
})();
(function() {
    SpotLight._combinedData = {
        cullingMask: new Int32Array(Light._maxLight * 2),
        color: new Float32Array(Light._maxLight * 3),
        position: new Float32Array(Light._maxLight * 3),
        direction: new Float32Array(Light._maxLight * 3),
        distance: new Float32Array(Light._maxLight),
        angleCos: new Float32Array(Light._maxLight),
        penumbraCos: new Float32Array(Light._maxLight)
    };
})();

/**
 * Light manager.
 */ var LightManager = /*#__PURE__*/ function() {
    function LightManager() {
        /** @internal */ this._spotLights = new DisorderedArray();
        /** @internal */ this._pointLights = new DisorderedArray();
        /** @internal */ this._directLights = new DisorderedArray();
    }
    var _proto = LightManager.prototype;
    /**
   * @internal
   */ _proto._attachSpotLight = function _attachSpotLight(light) {
        light._lightIndex = this._spotLights.length;
        this._spotLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachSpotLight = function _detachSpotLight(light) {
        var replaced = this._spotLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._attachPointLight = function _attachPointLight(light) {
        light._lightIndex = this._pointLights.length;
        this._pointLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachPointLight = function _detachPointLight(light) {
        var replaced = this._pointLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._attachDirectLight = function _attachDirectLight(light) {
        light._lightIndex = this._directLights.length;
        this._directLights.add(light);
    };
    /**
   * @internal
   */ _proto._detachDirectLight = function _detachDirectLight(light) {
        var replaced = this._directLights.deleteByIndex(light._lightIndex);
        replaced && (replaced._lightIndex = light._lightIndex);
        light._lightIndex = -1;
    };
    /**
   * @internal
   */ _proto._getSunLightIndex = function _getSunLightIndex() {
        var directLights = this._directLights;
        var sunLightIndex = -1;
        var maxIntensity = Number.NEGATIVE_INFINITY;
        var hasShadowLight = false;
        for(var i = 0, n = directLights.length; i < n; i++){
            var directLight = directLights.get(i);
            if (directLight.shadowType !== exports.ShadowType.None && !hasShadowLight) {
                maxIntensity = Number.NEGATIVE_INFINITY;
                hasShadowLight = true;
            }
            var intensity = directLight.intensity * directLight.color.getBrightness();
            if (hasShadowLight) {
                if (directLight.shadowType !== exports.ShadowType.None && maxIntensity < intensity) {
                    maxIntensity = intensity;
                    sunLightIndex = i;
                }
            } else {
                if (maxIntensity < intensity) {
                    maxIntensity = intensity;
                    sunLightIndex = i;
                }
            }
        }
        return sunLightIndex;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData) {
        var spotLight = this._spotLights;
        var pointLight = this._pointLights;
        var directLight = this._directLights;
        var spotLightCount = spotLight.length;
        var pointLightCount = pointLight.length;
        var directLightCount = directLight.length;
        for(var i = 0, len = spotLightCount; i < len; i++){
            var light = spotLight.get(i);
            light._appendData(i);
        }
        for(var i1 = 0, len1 = pointLightCount; i1 < len1; i1++){
            var light1 = pointLight.get(i1);
            light1._appendData(i1);
        }
        for(var i2 = 0, len2 = directLightCount; i2 < len2; i2++){
            var light2 = directLight.get(i2);
            light2._appendData(i2);
        }
        if (directLightCount) {
            DirectLight._updateShaderData(shaderData);
            shaderData.enableMacro("SCENE_DIRECT_LIGHT_COUNT", directLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_DIRECT_LIGHT_COUNT");
        }
        if (pointLightCount) {
            PointLight._updateShaderData(shaderData);
            shaderData.enableMacro("SCENE_POINT_LIGHT_COUNT", pointLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_POINT_LIGHT_COUNT");
        }
        if (spotLightCount) {
            SpotLight._updateShaderData(shaderData);
            shaderData.enableMacro("SCENE_SPOT_LIGHT_COUNT", spotLightCount.toString());
        } else {
            shaderData.disableMacro("SCENE_SPOT_LIGHT_COUNT");
        }
    };
    /**
   * @internal
   */ _proto._gc = function _gc() {
        this._spotLights.garbageCollection();
        this._pointLights.garbageCollection();
        this._directLights.garbageCollection();
    };
    return LightManager;
}();

/**
 * Shader data grouping.
 */ var ShaderDataGroup;
(function(ShaderDataGroup) {
    ShaderDataGroup[ShaderDataGroup[/** Scene group. */ "Scene"] = 0] = "Scene";
    ShaderDataGroup[ShaderDataGroup[/** Camera group. */ "Camera"] = 1] = "Camera";
    ShaderDataGroup[ShaderDataGroup[/** Renderer group. */ "Renderer"] = 2] = "Renderer";
    ShaderDataGroup[ShaderDataGroup[/** material group. */ "Material"] = 3] = "Material";
})(ShaderDataGroup || (ShaderDataGroup = {}));

/**
 * Shader Property type.
 */ var ShaderPropertyType;
(function(ShaderPropertyType) {
    ShaderPropertyType[ShaderPropertyType[/** Float type. */ "Float"] = 0] = "Float";
    ShaderPropertyType[ShaderPropertyType[/** Int type. */ "Int"] = 1] = "Int";
    ShaderPropertyType[ShaderPropertyType[/** Vector2 type. */ "Vector2"] = 2] = "Vector2";
    ShaderPropertyType[ShaderPropertyType[/** Vector3 type. */ "Vector3"] = 3] = "Vector3";
    ShaderPropertyType[ShaderPropertyType[/** Vector4 type. */ "Vector4"] = 4] = "Vector4";
    ShaderPropertyType[ShaderPropertyType[/** Matrix type. */ "Matrix"] = 5] = "Matrix";
    ShaderPropertyType[ShaderPropertyType[/** Color type. */ "Color"] = 6] = "Color";
    ShaderPropertyType[ShaderPropertyType[/** Texture type. */ "Texture"] = 7] = "Texture";
    ShaderPropertyType[ShaderPropertyType[/** Float array type. */ "FloatArray"] = 8] = "FloatArray";
    ShaderPropertyType[ShaderPropertyType[/** Int array type. */ "IntArray"] = 9] = "IntArray";
    ShaderPropertyType[ShaderPropertyType[/** Texture array type. */ "TextureArray"] = 10] = "TextureArray";
})(ShaderPropertyType || (ShaderPropertyType = {}));

/**
 * Shader macroã€‚
 */ var ShaderMacro = /*#__PURE__*/ function() {
    function ShaderMacro(name, value, maskIndex, maskValue) {
        this.name = name;
        this._maskIndex = maskIndex;
        this._maskValue = maskValue;
        this.value = value;
        var macroNameIDMap = ShaderMacro._macroNameIdMap;
        var nameID = macroNameIDMap[name];
        if (macroNameIDMap[name] === undefined) {
            macroNameIDMap[name] = nameID = ShaderMacro._macroNameCounter++;
        }
        this._nameId = nameID;
    }
    ShaderMacro.getByName = function getByName(name, value) {
        var key = value ? name + " " + value : name;
        var macro = ShaderMacro._macroMap[key];
        if (!macro) {
            var maskMap = ShaderMacro._macroMaskMap;
            var counter = ShaderMacro._macroCounter;
            var index = Math.floor(counter / 32);
            var bit = counter % 32;
            macro = new ShaderMacro(name, value, index, 1 << bit);
            ShaderMacro._macroMap[key] = macro;
            if (index == maskMap.length) {
                maskMap.length++;
                maskMap[index] = new Array(32);
            }
            maskMap[index][bit] = key;
            ShaderMacro._macroCounter++;
        }
        return macro;
    };
    /**
   * @internal
   */ ShaderMacro._getNamesByMacros = function _getNamesByMacros(macros, out) {
        var maskMap = ShaderMacro._macroMaskMap;
        var mask = macros._mask;
        out.length = 0;
        for(var i = 0, n = macros._length; i < n; i++){
            var subMaskMap = maskMap[i];
            var subMask = mask[i];
            var m = subMask < 0 ? 32 : Math.floor(Math.log2(subMask)) + 1; // if is negative must contain 1 << 31.
            for(var j = 0; j < m; j++){
                if (subMask & 1 << j) {
                    out.push(subMaskMap[j]);
                }
            }
        }
    };
    return ShaderMacro;
}();
(function() {
    /** @internal */ ShaderMacro._macroMaskMap = [];
})();
(function() {
    /** @internal */ ShaderMacro._macroNameIdMap = Object.create(null);
})();
(function() {
    ShaderMacro._macroNameCounter = 0;
})();
(function() {
    ShaderMacro._macroCounter = 0;
})();
(function() {
    ShaderMacro._macroMap = Object.create(null);
})();

/**
 * Shader macro collection.
 * @internal
 */ var ShaderMacroCollection = /*#__PURE__*/ function() {
    function ShaderMacroCollection() {
        /** @internal */ this._mask = [];
        /** @internal */ this._length = 0;
    }
    var _proto = ShaderMacroCollection.prototype;
    /**
   * Enable one macro in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.enable = function enable(macro) {
        var index = macro._maskIndex;
        var size = index + 1;
        var mask = this._mask;
        var maskStart = this._length; // must from this._length because this._length maybe less than mask.length and have dirty data should clear.
        if (maskStart < size) {
            mask.length < size && (mask.length = size); // mask.length maybe small than size,maybe not.
            for(; maskStart < index; maskStart++){
                mask[maskStart] = 0;
            }
            mask[index] = macro._maskValue;
            this._length = size;
        } else {
            mask[index] |= macro._maskValue;
        }
    };
    /**
   * Disable one macro in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.disable = function disable(macro) {
        var index = macro._maskIndex;
        var mask = this._mask;
        var endIndex = this._length - 1;
        if (index > endIndex) {
            return;
        }
        var newValue = mask[index] & ~macro._maskValue;
        if (index == endIndex && newValue === 0) {
            this._length--;
        } else {
            mask[index] = newValue;
        }
    };
    /**
   * Union of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.unionCollection = function unionCollection(macroCollection) {
        var addMask = macroCollection._mask;
        var addSize = macroCollection._length;
        var mask = this._mask;
        var maskSize = this._length;
        if (maskSize < addSize) {
            mask.length < addSize && (mask.length = addSize);
            var i = 0;
            for(; i < maskSize; i++){
                mask[i] |= addMask[i];
            }
            for(; i < addSize; i++){
                mask[i] = addMask[i];
            }
            this._length = addSize;
        } else {
            for(var i1 = 0; i1 < addSize; i1++){
                mask[i1] |= addMask[i1];
            }
        }
    };
    /**
   * Complementarity of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.complementaryCollection = function complementaryCollection(macroCollection) {
        var removeMask = macroCollection._mask;
        var mask = this._mask;
        var endIndex = this._length - 1;
        var i = Math.min(macroCollection._length - 1, endIndex);
        for(; i >= 0; i--){
            var newValue = mask[i] & ~removeMask[i];
            if (i == endIndex && newValue === 0) {
                endIndex--;
                this._length--;
            } else {
                mask[i] = newValue;
            }
        }
    };
    /**
   * Intersection of this and other macro collection.
   * @param macroCollection - macro collection
   */ _proto.intersectionCollection = function intersectionCollection(macroCollection) {
        var unionMask = macroCollection._mask;
        var mask = this._mask;
        for(var i = this._length - 1; i >= 0; i--){
            var value = mask[i] & unionMask[i];
            if (value == 0 && i == this._length - 1) {
                this._length--;
            } else {
                mask[i] = value;
            }
        }
    };
    /**
   * Whether macro is enabled in this macro collection.
   * @param macro - ShaderMacro
   */ _proto.isEnable = function isEnable(macro) {
        var index = macro._maskIndex;
        if (index >= this._length) {
            return false;
        }
        return (this._mask[index] & macro._maskValue) !== 0;
    };
    /**
   * Clear this macro collection.
   */ _proto.clear = function clear() {
        this._length = 0;
    };
    /**
   * Union of two macro collection.
   * @param left - input macro collection
   * @param right - input macro collection
   * @param out - union output macro collection
   */ ShaderMacroCollection.unionCollection = function unionCollection(left, right, out) {
        var outMask = out._mask;
        var minSize, maxSize;
        var minMask, maxMask;
        if (left._length < right._length) {
            minSize = left._length;
            maxSize = right._length;
            minMask = left._mask;
            maxMask = right._mask;
        } else {
            minSize = right._length;
            maxSize = left._length;
            minMask = right._mask;
            maxMask = left._mask;
        }
        var i = 0;
        outMask.length < maxSize && (outMask.length = maxSize);
        for(; i < minSize; i++){
            outMask[i] = minMask[i] | maxMask[i];
        }
        for(; i < maxSize; i++){
            outMask[i] = maxMask[i];
        }
        out._length = maxSize;
    };
    return ShaderMacroCollection;
}();

/**
 * Shader data collection,Correspondence includes shader properties data and macros data.
 */ var ShaderData = /*#__PURE__*/ function() {
    function ShaderData(group) {
        /** @internal */ this._propertyValueMap = Object.create(null);
        /** @internal */ this._macroCollection = new ShaderMacroCollection();
        this._macroMap = Object.create(null);
        this._refCount = 0;
        this._group = group;
    }
    var _proto = ShaderData.prototype;
    _proto.getFloat = function getFloat(property) {
        return this.getPropertyValue(property);
    };
    _proto.setFloat = function setFloat(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Float, value);
    };
    _proto.getInt = function getInt(property) {
        return this.getPropertyValue(property);
    };
    _proto.setInt = function setInt(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Int, value);
    };
    _proto.getFloatArray = function getFloatArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setFloatArray = function setFloatArray(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.FloatArray, value);
    };
    _proto.getIntArray = function getIntArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setIntArray = function setIntArray(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.IntArray, value);
    };
    _proto.getVector2 = function getVector2(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector2 = function setVector2(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector2, value);
    };
    _proto.getVector3 = function getVector3(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector3 = function setVector3(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector3, value);
    };
    _proto.getVector4 = function getVector4(property) {
        return this.getPropertyValue(property);
    };
    _proto.setVector4 = function setVector4(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Vector4, value);
    };
    _proto.getMatrix = function getMatrix(property) {
        return this.getPropertyValue(property);
    };
    _proto.setMatrix = function setMatrix(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Matrix, value);
    };
    _proto.getColor = function getColor(property) {
        return this.getPropertyValue(property);
    };
    _proto.setColor = function setColor(property, value) {
        this._setPropertyValue(property, ShaderPropertyType.Color, value);
    };
    _proto.getTexture = function getTexture(property) {
        return this.getPropertyValue(property);
    };
    _proto.setTexture = function setTexture(property, value) {
        if (this._getReferCount() > 0) {
            var lastValue = this.getPropertyValue(property);
            lastValue && lastValue._addReferCount(-1);
            value && value._addReferCount(1);
        }
        this._setPropertyValue(property, ShaderPropertyType.Texture, value);
    };
    _proto.getTextureArray = function getTextureArray(property) {
        return this.getPropertyValue(property);
    };
    _proto.setTextureArray = function setTextureArray(property, value) {
        if (this._getReferCount() > 0) {
            var lastValue = this.getPropertyValue(property);
            if (lastValue) {
                for(var i = 0, n = lastValue.length; i < n; i++){
                    lastValue[i]._addReferCount(-1);
                }
            }
            if (value) {
                for(var i1 = 0, n1 = value.length; i1 < n1; i1++){
                    value[i1]._addReferCount(1);
                }
            }
        }
        this._setPropertyValue(property, ShaderPropertyType.TextureArray, value);
    };
    /**
   * Get shader property value set on this shaderData.
   * @param property - Shader property
   * @returns Property value
   */ _proto.getPropertyValue = function getPropertyValue(property) {
        if (typeof property === "string") {
            property = ShaderProperty.getByName(property);
        }
        return this._propertyValueMap[property._uniqueId];
    };
    _proto.enableMacro = function enableMacro(macro, value) {
        if (typeof macro === "string") {
            macro = ShaderMacro.getByName(macro, value);
        }
        var nameID = macro._nameId;
        var lastMacro = this._macroMap[nameID];
        if (lastMacro !== macro) {
            var macroCollection = this._macroCollection;
            lastMacro && macroCollection.disable(lastMacro);
            macroCollection.enable(macro);
            this._macroMap[nameID] = macro;
        }
    };
    _proto.disableMacro = function disableMacro(macro) {
        var nameID;
        if (typeof macro === "string") {
            nameID = ShaderMacro._macroNameIdMap[macro];
            if (nameID === undefined) {
                return;
            }
        } else {
            nameID = macro._nameId;
        }
        var currentMacro = this._macroMap[nameID];
        if (currentMacro) {
            this._macroCollection.disable(currentMacro);
            delete this._macroMap[nameID];
        }
    };
    _proto.getMacros = function getMacros(out) {
        if (out) {
            var macroMap = this._macroMap;
            out.length = 0;
            for(var key in macroMap){
                out.push(macroMap[key]);
            }
        } else {
            return Object.values(this._macroMap);
        }
    };
    _proto.getProperties = function getProperties(out) {
        var properties;
        if (out) {
            out.length = 0;
            properties = out;
        } else {
            properties = [];
        }
        var propertyValueMap = this._propertyValueMap;
        var propertyIdMap = ShaderProperty._propertyIdMap;
        for(var key in propertyValueMap){
            properties.push(propertyIdMap[key]);
        }
        if (!out) {
            return properties;
        }
    };
    _proto.clone = function clone() {
        var shaderData = new ShaderData(this._group);
        this.cloneTo(shaderData);
        return shaderData;
    };
    _proto.cloneTo = function cloneTo(target) {
        CloneManager.deepCloneObject(this._macroCollection, target._macroCollection);
        Object.assign(target._macroMap, this._macroMap);
        var referCount = target._getReferCount();
        var propertyValueMap = this._propertyValueMap;
        var targetPropertyValueMap = target._propertyValueMap;
        var keys = Object.keys(propertyValueMap);
        for(var i = 0, n = keys.length; i < n; i++){
            var k = keys[i];
            var property = propertyValueMap[k];
            if (property != null) {
                if (typeof property === "number") {
                    targetPropertyValueMap[k] = property;
                } else if (_instanceof$2(property, Texture)) {
                    targetPropertyValueMap[k] = property;
                    referCount > 0 && property._addReferCount(referCount);
                } else if (_instanceof$2(property, Array) || _instanceof$2(property, Float32Array) || _instanceof$2(property, Int32Array)) {
                    targetPropertyValueMap[k] = property.slice();
                } else {
                    var targetProperty = targetPropertyValueMap[k];
                    if (targetProperty) {
                        targetProperty.copyFrom(property);
                    } else {
                        targetPropertyValueMap[k] = property.clone();
                    }
                }
            } else {
                targetPropertyValueMap[k] = property;
            }
        }
    };
    /**
   * @internal
   */ _proto._setPropertyValue = function _setPropertyValue(property, type, value) {
        if (typeof property === "string") {
            property = ShaderProperty.getByName(property);
        }
        if (property._group !== this._group) {
            if (property._group === undefined) {
                property._group = this._group;
            } else {
                throw "Shader property " + property.name + " has been used as " + ShaderDataGroup[property._group] + " group.";
            }
        }
        if (property._type !== type) {
            if (property._type === undefined) {
                property._type = type;
            } else {
                throw "Shader property " + property.name + " has been used as " + ShaderPropertyType[property._type] + " type.";
            }
        }
        this._propertyValueMap[property._uniqueId] = value;
    };
    /**
   * @internal
   */ _proto._getReferCount = function _getReferCount() {
        return this._refCount;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        this._refCount += value;
        var properties = this._propertyValueMap;
        for(var k in properties){
            var property = properties[k];
            // @todo: Separate array to speed performance.
            if (property && _instanceof$2(property, Texture)) {
                property._addReferCount(value);
            }
        }
    };
    return ShaderData;
}();

/**
 * Render queue type.
 */ var RenderQueueType;
(function(RenderQueueType) {
    RenderQueueType[RenderQueueType[/** Opaque queue. */ "Opaque"] = 0] = "Opaque";
    RenderQueueType[RenderQueueType[/** Opaque queue, alpha cutoff. */ "AlphaTest"] = 1] = "AlphaTest";
    RenderQueueType[RenderQueueType[/** Transparent queue, rendering from back to front to ensure correct rendering of transparent objects. */ "Transparent"] = 2] = "Transparent";
})(RenderQueueType || (RenderQueueType = {}));

/**
 * Blend factor.
 * @remarks defines which function is used for blending pixel arithmetic
 */ var BlendFactor;
(function(BlendFactor) {
    BlendFactor[BlendFactor[/** (0, 0, 0, 0)*/ "Zero"] = 0] = "Zero";
    BlendFactor[BlendFactor[/** (1, 1, 1, 1)*/ "One"] = 1] = "One";
    BlendFactor[BlendFactor[/** (Rs, Gs, Bs, As) */ "SourceColor"] = 2] = "SourceColor";
    BlendFactor[BlendFactor[/** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/ "OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
    BlendFactor[BlendFactor[/** (Rd, Gd, Bd, Ad)*/ "DestinationColor"] = 4] = "DestinationColor";
    BlendFactor[BlendFactor[/** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/ "OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
    BlendFactor[BlendFactor[/** (As, As, As, As)*/ "SourceAlpha"] = 6] = "SourceAlpha";
    BlendFactor[BlendFactor[/** (1 - As, 1 - As, 1 - As, 1 - As)*/ "OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
    BlendFactor[BlendFactor[/** (Ad, Ad, Ad, Ad)*/ "DestinationAlpha"] = 8] = "DestinationAlpha";
    BlendFactor[BlendFactor[/** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/ "OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
    BlendFactor[BlendFactor[/** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/ "SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
    BlendFactor[BlendFactor[/** (Rc, Gc, Bc, Ac)*/ "BlendColor"] = 11] = "BlendColor";
    BlendFactor[BlendFactor[/** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/ "OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
})(BlendFactor || (BlendFactor = {}));

/**
 * Blend operation function.
 * @remarks defines how a new pixel is combined with a pixel.
 */ var BlendOperation;
(function(BlendOperation) {
    BlendOperation[BlendOperation[/** src + dst. */ "Add"] = 0] = "Add";
    BlendOperation[BlendOperation[/** src - dst. */ "Subtract"] = 1] = "Subtract";
    BlendOperation[BlendOperation[/** dst - src. */ "ReverseSubtract"] = 2] = "ReverseSubtract";
    BlendOperation[BlendOperation[/** Minimum of source and destination. */ "Min"] = 3] = "Min";
    BlendOperation[BlendOperation[/** Maximum of source and destination. */ "Max"] = 4] = "Max";
})(BlendOperation || (BlendOperation = {}));

/**
 * Set which color channels can be rendered to frame buffer.
 * @remarks enumeration can be combined using bit operations.
 */ var ColorWriteMask;
(function(ColorWriteMask) {
    ColorWriteMask[ColorWriteMask[/** Do not write to any channel. */ "None"] = 0] = "None";
    ColorWriteMask[ColorWriteMask[/** Write to the red channel. */ "Red"] = 0x1] = "Red";
    ColorWriteMask[ColorWriteMask[/** Write to the green channel. */ "Green"] = 0x2] = "Green";
    ColorWriteMask[ColorWriteMask[/** Write to the blue channel. */ "Blue"] = 0x4] = "Blue";
    ColorWriteMask[ColorWriteMask[/** Write to the alpha channel. */ "Alpha"] = 0x8] = "Alpha";
    ColorWriteMask[ColorWriteMask[/** Write to all channel. */ "All"] = 0xf] = "All";
})(ColorWriteMask || (ColorWriteMask = {}));

/**
 * The blend state of the render target.
 */ var RenderTargetBlendState = function RenderTargetBlendState() {
    /** Whether to enable blend. */ this.enabled = false;
    /** color (RGB) blend operation. */ this.colorBlendOperation = BlendOperation.Add;
    /** alpha (A) blend operation. */ this.alphaBlendOperation = BlendOperation.Add;
    /** color blend factor (RGB) for source. */ this.sourceColorBlendFactor = BlendFactor.One;
    /** alpha blend factor (A) for source. */ this.sourceAlphaBlendFactor = BlendFactor.One;
    /** color blend factor (RGB) for destination. */ this.destinationColorBlendFactor = BlendFactor.Zero;
    /** alpha blend factor (A) for destination. */ this.destinationAlphaBlendFactor = BlendFactor.Zero;
    /** color mask. */ this.colorWriteMask = ColorWriteMask.All;
};

/**
 * Blend state.
 */ var BlendState = /*#__PURE__*/ function() {
    function BlendState() {
        /** The blend state of the render target. */ this.targetBlendState = new RenderTargetBlendState();
        /** Constant blend color. */ this.blendColor = new Color$1(0, 0, 0, 0);
        /** Whether to use (Alpha-to-Coverage) technology. */ this.alphaToCoverage = false;
    }
    var _proto = BlendState.prototype;
    /**
   * @internal
   * Apply the current blend state by comparing with the last blend state.
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.blendState);
    };
    _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var lastTargetBlendState = lastState.targetBlendState;
        var _this_targetBlendState = this.targetBlendState, enabled = _this_targetBlendState.enabled, colorBlendOperation = _this_targetBlendState.colorBlendOperation, alphaBlendOperation = _this_targetBlendState.alphaBlendOperation, sourceColorBlendFactor = _this_targetBlendState.sourceColorBlendFactor, destinationColorBlendFactor = _this_targetBlendState.destinationColorBlendFactor, sourceAlphaBlendFactor = _this_targetBlendState.sourceAlphaBlendFactor, destinationAlphaBlendFactor = _this_targetBlendState.destinationAlphaBlendFactor, colorWriteMask = _this_targetBlendState.colorWriteMask;
        if (enabled !== lastTargetBlendState.enabled) {
            if (enabled) {
                gl.enable(gl.BLEND);
            } else {
                gl.disable(gl.BLEND);
            }
            lastTargetBlendState.enabled = enabled;
        }
        if (enabled) {
            // apply blend factor.
            if (sourceColorBlendFactor !== lastTargetBlendState.sourceColorBlendFactor || destinationColorBlendFactor !== lastTargetBlendState.destinationColorBlendFactor || sourceAlphaBlendFactor !== lastTargetBlendState.sourceAlphaBlendFactor || destinationAlphaBlendFactor !== lastTargetBlendState.destinationAlphaBlendFactor) {
                gl.blendFuncSeparate(BlendState._getGLBlendFactor(rhi, sourceColorBlendFactor), BlendState._getGLBlendFactor(rhi, destinationColorBlendFactor), BlendState._getGLBlendFactor(rhi, sourceAlphaBlendFactor), BlendState._getGLBlendFactor(rhi, destinationAlphaBlendFactor));
                lastTargetBlendState.sourceColorBlendFactor = sourceColorBlendFactor;
                lastTargetBlendState.destinationColorBlendFactor = destinationColorBlendFactor;
                lastTargetBlendState.sourceAlphaBlendFactor = sourceAlphaBlendFactor;
                lastTargetBlendState.destinationAlphaBlendFactor = destinationAlphaBlendFactor;
            }
            // apply blend operation.
            if (colorBlendOperation !== lastTargetBlendState.colorBlendOperation || alphaBlendOperation !== lastTargetBlendState.alphaBlendOperation) {
                gl.blendEquationSeparate(BlendState._getGLBlendOperation(rhi, colorBlendOperation), BlendState._getGLBlendOperation(rhi, alphaBlendOperation));
                lastTargetBlendState.colorBlendOperation = colorBlendOperation;
                lastTargetBlendState.alphaBlendOperation = alphaBlendOperation;
            }
            // apply blend color.
            var blendColor = this.blendColor;
            if (!Color$1.equals(lastState.blendColor, blendColor)) {
                gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
                lastState.blendColor.copyFrom(blendColor);
            }
        }
        // apply color mask.
        if (colorWriteMask !== lastTargetBlendState.colorWriteMask) {
            gl.colorMask((colorWriteMask & ColorWriteMask.Red) !== 0, (colorWriteMask & ColorWriteMask.Green) !== 0, (colorWriteMask & ColorWriteMask.Blue) !== 0, (colorWriteMask & ColorWriteMask.Alpha) !== 0);
            lastTargetBlendState.colorWriteMask = colorWriteMask;
        }
        // apply alpha to coverage.
        var alphaToCoverage = this.alphaToCoverage;
        if (alphaToCoverage !== lastState.alphaToCoverage) {
            if (alphaToCoverage) {
                gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            } else {
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            }
            lastState.alphaToCoverage = alphaToCoverage;
        }
    };
    BlendState._getGLBlendFactor = function _getGLBlendFactor(rhi, blendFactor) {
        var gl = rhi.gl;
        switch(blendFactor){
            case BlendFactor.Zero:
                return gl.ZERO;
            case BlendFactor.One:
                return gl.ONE;
            case BlendFactor.SourceColor:
                return gl.SRC_COLOR;
            case BlendFactor.OneMinusSourceColor:
                return gl.ONE_MINUS_SRC_COLOR;
            case BlendFactor.DestinationColor:
                return gl.DST_COLOR;
            case BlendFactor.OneMinusDestinationColor:
                return gl.ONE_MINUS_DST_COLOR;
            case BlendFactor.SourceAlpha:
                return gl.SRC_ALPHA;
            case BlendFactor.OneMinusSourceAlpha:
                return gl.ONE_MINUS_SRC_ALPHA;
            case BlendFactor.DestinationAlpha:
                return gl.DST_ALPHA;
            case BlendFactor.OneMinusDestinationAlpha:
                return gl.ONE_MINUS_DST_ALPHA;
            case BlendFactor.SourceAlphaSaturate:
                return gl.SRC_ALPHA_SATURATE;
            case BlendFactor.BlendColor:
                return gl.CONSTANT_COLOR;
            case BlendFactor.OneMinusBlendColor:
                return gl.ONE_MINUS_CONSTANT_COLOR;
        }
    };
    BlendState._getGLBlendOperation = function _getGLBlendOperation(rhi, blendOperation) {
        var gl = rhi.gl;
        switch(blendOperation){
            case BlendOperation.Add:
                return gl.FUNC_ADD;
            case BlendOperation.Subtract:
                return gl.FUNC_SUBTRACT;
            case BlendOperation.ReverseSubtract:
                return gl.FUNC_REVERSE_SUBTRACT;
            case BlendOperation.Min:
                if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
                    throw new Error("BlendOperation.Min is not supported in this context");
                }
                return gl.MIN; // in webgl1.0 is an extension
            case BlendOperation.Max:
                if (!rhi.canIUse(GLCapabilityType.blendMinMax)) {
                    throw new Error("BlendOperation.Max is not supported in this context");
                }
                return gl.MAX; // in webgl1.0 is an extension
        }
    };
    return BlendState;
}();

/**
 * Depth/Stencil comparison function.
 * @remarks Specifies a function that compares incoming pixel depth/stencil to the current depth/stencil buffer value.
 */ var CompareFunction;
(function(CompareFunction) {
    CompareFunction[CompareFunction[/** never pass. */ "Never"] = 0] = "Never";
    CompareFunction[CompareFunction[/** pass if the incoming value is less than the depth/stencil buffer value. */ "Less"] = 1] = "Less";
    CompareFunction[CompareFunction[/** pass if the incoming value equals the depth/stencil buffer value. */ "Equal"] = 2] = "Equal";
    CompareFunction[CompareFunction[/** pass if the incoming value is less than or equal to the depth/stencil buffer value. */ "LessEqual"] = 3] = "LessEqual";
    CompareFunction[CompareFunction[/** pass if the incoming value is greater than the depth/stencil buffer value. */ "Greater"] = 4] = "Greater";
    CompareFunction[CompareFunction[/** pass if the incoming value is not equal to the depth/stencil buffer value. */ "NotEqual"] = 5] = "NotEqual";
    CompareFunction[CompareFunction[/** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */ "GreaterEqual"] = 6] = "GreaterEqual";
    CompareFunction[CompareFunction[/** always pass. */ "Always"] = 7] = "Always";
})(CompareFunction || (CompareFunction = {}));

/**
 * Depth state.
 */ var DepthState = /*#__PURE__*/ function() {
    function DepthState() {
        /** Whether to enable the depth test. */ this.enabled = true;
        /** Whether the depth value can be written.*/ this.writeEnabled = true;
        /** Depth comparison function. */ this.compareFunction = CompareFunction.Less;
    }
    var _proto = DepthState.prototype;
    /**
   * @internal
   * Apply the current depth state by comparing with the last depth state.
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.depthState);
    };
    _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var _this = this, enabled = _this.enabled, compareFunction = _this.compareFunction, writeEnabled = _this.writeEnabled;
        if (enabled != lastState.enabled) {
            if (enabled) {
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
            lastState.enabled = enabled;
        }
        if (enabled) {
            // apply compare func.
            if (compareFunction != lastState.compareFunction) {
                gl.depthFunc(DepthState._getGLCompareFunction(rhi, compareFunction));
                lastState.compareFunction = compareFunction;
            }
            // apply write enabled.
            if (writeEnabled != lastState.writeEnabled) {
                gl.depthMask(writeEnabled);
                lastState.writeEnabled = writeEnabled;
            }
        }
    };
    DepthState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case CompareFunction.Never:
                return gl.NEVER;
            case CompareFunction.Less:
                return gl.LESS;
            case CompareFunction.Equal:
                return gl.EQUAL;
            case CompareFunction.LessEqual:
                return gl.LEQUAL;
            case CompareFunction.Greater:
                return gl.GREATER;
            case CompareFunction.NotEqual:
                return gl.NOTEQUAL;
            case CompareFunction.GreaterEqual:
                return gl.GEQUAL;
            case CompareFunction.Always:
                return gl.ALWAYS;
        }
    };
    return DepthState;
}();

/**
 * Culling mode.
 * @remarks specifies whether or not front- and/or back-facing polygons can be culled.
 */ var CullMode;
(function(CullMode) {
    CullMode[CullMode[/** Disable culling. */ "Off"] = 0] = "Off";
    CullMode[CullMode[/** cut the front-face of the polygons. */ "Front"] = 1] = "Front";
    CullMode[CullMode[/** cut the back-face of the polygons. */ "Back"] = 2] = "Back";
})(CullMode || (CullMode = {}));

/**
 * Raster state.
 */ var RasterState = /*#__PURE__*/ function() {
    function RasterState() {
        /** Specifies whether or not front- and/or back-facing polygons can be culled. */ this.cullMode = CullMode.Back;
        /** The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset. */ this.depthBias = 0;
        /** The scale factor for the variable depth offset for each polygon. */ this.slopeScaledDepthBias = 0;
        /** @internal */ this._cullFaceEnable = true;
        /** @internal */ this._frontFaceInvert = false;
    }
    var _proto = RasterState.prototype;
    /**
   * @internal
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState, frontFaceInvert) {
        this._platformApply(hardwareRenderer, lastRenderState.rasterState, frontFaceInvert);
    };
    _proto._platformApply = function _platformApply(rhi, lastState, frontFaceInvert) {
        var gl = rhi.gl;
        var _this = this, cullMode = _this.cullMode, depthBias = _this.depthBias, slopeScaledDepthBias = _this.slopeScaledDepthBias;
        var cullFaceEnable = cullMode !== CullMode.Off;
        if (cullFaceEnable !== lastState._cullFaceEnable) {
            if (cullFaceEnable) {
                gl.enable(gl.CULL_FACE);
            } else {
                gl.disable(gl.CULL_FACE);
            }
            lastState._cullFaceEnable = cullFaceEnable;
        }
        // apply front face.
        if (cullFaceEnable) {
            if (cullMode !== lastState.cullMode) {
                if (cullMode == CullMode.Back) {
                    gl.cullFace(gl.BACK);
                } else {
                    gl.cullFace(gl.FRONT);
                }
                lastState.cullMode = cullMode;
            }
        }
        if (frontFaceInvert !== lastState._frontFaceInvert) {
            if (frontFaceInvert) {
                gl.frontFace(gl.CW);
            } else {
                gl.frontFace(gl.CCW);
            }
            lastState._frontFaceInvert = frontFaceInvert;
        }
        // apply polygonOffset.
        if (!rhi._enableGlobalDepthBias) {
            if (depthBias !== lastState.depthBias || slopeScaledDepthBias !== lastState.slopeScaledDepthBias) {
                if (depthBias !== 0 || slopeScaledDepthBias !== 0) {
                    gl.enable(gl.POLYGON_OFFSET_FILL);
                    gl.polygonOffset(slopeScaledDepthBias, depthBias);
                } else {
                    gl.disable(gl.POLYGON_OFFSET_FILL);
                }
                lastState.depthBias = depthBias;
                lastState.slopeScaledDepthBias = slopeScaledDepthBias;
            }
        }
    };
    return RasterState;
}();

/**
 * Stencil operation mode.
 * @remarks sets the front and/or back-facing stencil test actions.
 */ var StencilOperation;
(function(StencilOperation) {
    StencilOperation[StencilOperation[/** Keeps the current value. */ "Keep"] = 0] = "Keep";
    StencilOperation[StencilOperation[/** Sets the stencil buffer value to 0. */ "Zero"] = 1] = "Zero";
    StencilOperation[StencilOperation[/** Sets the stencil buffer value to the reference value. */ "Replace"] = 2] = "Replace";
    StencilOperation[StencilOperation[/** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */ "IncrementSaturate"] = 3] = "IncrementSaturate";
    StencilOperation[StencilOperation[/** Decrements the current stencil buffer value. Clamps to 0. */ "DecrementSaturate"] = 4] = "DecrementSaturate";
    StencilOperation[StencilOperation[/** Inverts the current stencil buffer value bitwise. */ "Invert"] = 5] = "Invert";
    StencilOperation[StencilOperation[/** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */ "IncrementWrap"] = 6] = "IncrementWrap";
    StencilOperation[StencilOperation[/** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */ "DecrementWrap"] = 7] = "DecrementWrap";
})(StencilOperation || (StencilOperation = {}));

/**
 * Stencil state.
 */ var StencilState = /*#__PURE__*/ function() {
    function StencilState() {
        /** Whether to enable stencil test. */ this.enabled = false;
        /** Write the reference value of the stencil buffer. */ this.referenceValue = 0;
        /** Specifying a bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done. */ this.mask = 0xff;
        /** Specifying a bit mask to enable or disable writing of individual bits in the stencil planes. */ this.writeMask = 0xff;
        /** The comparison function of the reference value of the front face of the geometry and the current buffer storage value. */ this.compareFunctionFront = CompareFunction.Always;
        /** The comparison function of the reference value of the back of the geometry and the current buffer storage value. */ this.compareFunctionBack = CompareFunction.Always;
        /** specifying the function to use for front face when both the stencil test and the depth test pass. */ this.passOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when both the stencil test and the depth test pass. */ this.passOperationBack = StencilOperation.Keep;
        /** specifying the function to use for front face when the stencil test fails. */ this.failOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when the stencil test fails. */ this.failOperationBack = StencilOperation.Keep;
        /** specifying the function to use for front face when the stencil test passes, but the depth test fails. */ this.zFailOperationFront = StencilOperation.Keep;
        /** specifying the function to use for back face when the stencil test passes, but the depth test fails. */ this.zFailOperationBack = StencilOperation.Keep;
    }
    var _proto = StencilState.prototype;
    /**
   * @internal
   */ _proto._apply = function _apply(hardwareRenderer, lastRenderState) {
        this._platformApply(hardwareRenderer, lastRenderState.stencilState);
    };
    _proto._platformApply = function _platformApply(rhi, lastState) {
        var gl = rhi.gl;
        var _this = this, enabled = _this.enabled, referenceValue = _this.referenceValue, mask = _this.mask, compareFunctionFront = _this.compareFunctionFront, compareFunctionBack = _this.compareFunctionBack, failOperationFront = _this.failOperationFront, zFailOperationFront = _this.zFailOperationFront, passOperationFront = _this.passOperationFront, failOperationBack = _this.failOperationBack, zFailOperationBack = _this.zFailOperationBack, passOperationBack = _this.passOperationBack, writeMask = _this.writeMask;
        if (enabled != lastState.enabled) {
            if (enabled) {
                gl.enable(gl.STENCIL_TEST);
            } else {
                gl.disable(gl.STENCIL_TEST);
            }
            lastState.enabled = enabled;
        }
        if (enabled) {
            // apply stencil func.
            var referenceOrMaskChange = referenceValue !== lastState.referenceValue || mask !== lastState.mask;
            if (referenceOrMaskChange || compareFunctionFront !== lastState.compareFunctionFront) {
                gl.stencilFuncSeparate(gl.FRONT, StencilState._getGLCompareFunction(rhi, compareFunctionFront), referenceValue, mask);
                lastState.compareFunctionFront = compareFunctionFront;
            }
            if (referenceOrMaskChange || compareFunctionBack !== lastState.compareFunctionBack) {
                gl.stencilFuncSeparate(gl.BACK, StencilState._getGLCompareFunction(rhi, compareFunctionBack), referenceValue, mask);
                lastState.compareFunctionBack = this.compareFunctionBack;
            }
            if (referenceOrMaskChange) {
                lastState.referenceValue = this.referenceValue;
                lastState.mask = this.mask;
            }
            // apply stencil operation.
            if (failOperationFront !== lastState.failOperationFront || zFailOperationFront !== lastState.zFailOperationFront || passOperationFront !== lastState.passOperationFront) {
                gl.stencilOpSeparate(gl.FRONT, StencilState._getGLStencilOperation(rhi, failOperationFront), StencilState._getGLStencilOperation(rhi, zFailOperationFront), StencilState._getGLStencilOperation(rhi, passOperationFront));
                lastState.failOperationFront = failOperationFront;
                lastState.zFailOperationFront = zFailOperationFront;
                lastState.passOperationFront = passOperationFront;
            }
            if (failOperationBack !== lastState.failOperationBack || zFailOperationBack !== lastState.zFailOperationBack || passOperationBack !== lastState.passOperationBack) {
                gl.stencilOpSeparate(gl.BACK, StencilState._getGLStencilOperation(rhi, failOperationBack), StencilState._getGLStencilOperation(rhi, zFailOperationBack), StencilState._getGLStencilOperation(rhi, passOperationBack));
                lastState.failOperationBack = failOperationBack;
                lastState.zFailOperationBack = zFailOperationBack;
                lastState.passOperationBack = passOperationBack;
            }
            // apply write mask.
            if (writeMask !== lastState.writeMask) {
                gl.stencilMask(writeMask);
                lastState.writeMask = writeMask;
            }
        }
    };
    StencilState._getGLCompareFunction = function _getGLCompareFunction(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case CompareFunction.Never:
                return gl.NEVER;
            case CompareFunction.Less:
                return gl.LESS;
            case CompareFunction.Equal:
                return gl.EQUAL;
            case CompareFunction.LessEqual:
                return gl.LEQUAL;
            case CompareFunction.Greater:
                return gl.GREATER;
            case CompareFunction.NotEqual:
                return gl.NOTEQUAL;
            case CompareFunction.GreaterEqual:
                return gl.GEQUAL;
            case CompareFunction.Always:
                return gl.ALWAYS;
        }
    };
    StencilState._getGLStencilOperation = function _getGLStencilOperation(rhi, compareFunction) {
        var gl = rhi.gl;
        switch(compareFunction){
            case StencilOperation.Keep:
                return gl.KEEP;
            case StencilOperation.Zero:
                return gl.ZERO;
            case StencilOperation.Replace:
                return gl.REPLACE;
            case StencilOperation.IncrementSaturate:
                return gl.INCR;
            case StencilOperation.DecrementSaturate:
                return gl.DECR;
            case StencilOperation.Invert:
                return gl.INVERT;
            case StencilOperation.IncrementWrap:
                return gl.INCR_WRAP;
            case StencilOperation.DecrementWrap:
                return gl.DECR_WRAP;
        }
    };
    return StencilState;
}();

/**
 * Render state.
 */ var RenderState = /*#__PURE__*/ function() {
    function RenderState() {
        /** Blend state. */ this.blendState = new BlendState();
        /** Depth state. */ this.depthState = new DepthState();
        /** Stencil state. */ this.stencilState = new StencilState();
        /** Raster state. */ this.rasterState = new RasterState();
        /** Render queue type. */ this.renderQueueType = RenderQueueType.Opaque;
    }
    var _proto = RenderState.prototype;
    /**
   * @internal
   */ _proto._apply = function _apply(engine, frontFaceInvert) {
        var hardwareRenderer = engine._hardwareRenderer;
        var lastRenderState = engine._lastRenderState;
        this.blendState._apply(hardwareRenderer, lastRenderState);
        this.depthState._apply(hardwareRenderer, lastRenderState);
        this.stencilState._apply(hardwareRenderer, lastRenderState);
        this.rasterState._apply(hardwareRenderer, lastRenderState, frontFaceInvert);
    };
    return RenderState;
}();

/**
 * Material.
 */ var Material = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Material, ReferResource);
    function Material(engine, shader) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        /** @internal */ _this._renderStates = [] // todo: later will as a part of shaderData when shader effect frame is OK, that is more powerful and flexible.
        ;
        _this._shaderData = new ShaderData(ShaderDataGroup.Material);
        _this.shader = shader;
        return _this;
    }
    var _proto = Material.prototype;
    /**
   * Clone and return the instance.
   */ _proto.clone = function clone() {
        var dest = new Material(this._engine, this.shader);
        this.cloneTo(dest);
        return dest;
    };
    /**
   * Clone to the target material.
   * @param target - target material
   */ _proto.cloneTo = function cloneTo(target) {
        target.shader = this.shader;
        this.shaderData.cloneTo(target.shaderData);
        CloneManager.deepCloneObject(this.renderStates, target.renderStates);
    };
    _proto._addReferCount = function _addReferCount(value) {
        ReferResource.prototype._addReferCount.call(this, value);
        this.shaderData._addReferCount(value);
    };
    /**
   * @override
   */ _proto._onDestroy = function _onDestroy() {
        this._shader = null;
        this._shaderData = null;
        this._renderStates.length = 0;
        this._renderStates = null;
    };
    _create_class$3(Material, [
        {
            key: "shaderData",
            get: /**
   *  Shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "shader",
            get: /**
   * Shader used by the material.
   */ function get() {
                return this._shader;
            },
            set: function set(value) {
                this._shader = value;
                var renderStates = this._renderStates;
                var lastStatesCount = renderStates.length;
                var maxPassCount = 0;
                var subShaders = value.subShaders;
                for(var i = 0; i < subShaders.length; i++){
                    maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
                }
                if (lastStatesCount < maxPassCount) {
                    for(var i1 = lastStatesCount; i1 < maxPassCount; i1++){
                        renderStates.push(new RenderState());
                    }
                } else {
                    renderStates.length = maxPassCount;
                }
            }
        },
        {
            key: "renderState",
            get: /**
   * First Render state.
   */ function get() {
                return this._renderStates[0];
            }
        },
        {
            key: "renderStates",
            get: /**
   * Render states.
   */ function get() {
                return this._renderStates;
            }
        }
    ]);
    return Material;
}(ReferResource);

/**
 * Class pool utils.
 */ var ClassPool = /*#__PURE__*/ function() {
    function ClassPool(type) {
        this._elementPoolIndex = 0;
        this._elementPool = [];
        this._type = type;
    }
    var _proto = ClassPool.prototype;
    /**
   * Get element from pool.
   */ _proto.getFromPool = function getFromPool() {
        var _this = this, index = _this._elementPoolIndex, pool = _this._elementPool;
        this._elementPoolIndex++;
        if (pool.length === index) {
            var element = new this._type();
            pool.push(element);
            return element;
        } else {
            return pool[index];
        }
    };
    /**
   * Reset pool.
   */ _proto.resetPool = function resetPool() {
        this._elementPoolIndex = 0;
    };
    _proto.garbageCollection = function garbageCollection() {
        var _this = this, pool = _this._elementPool;
        for(var i = pool.length - 1; i >= 0; i--){
            pool[i].dispose && pool[i].dispose();
        }
    };
    return ClassPool;
}();

var RenderData = function RenderData() {
};

/**
 * Render element.
 */ var MeshRenderData = /*#__PURE__*/ function(RenderData) {
    _inherits$2(MeshRenderData, RenderData);
    function MeshRenderData() {
        return RenderData.apply(this, arguments);
    }
    var _proto = MeshRenderData.prototype;
    _proto.set = function set(component, material, mesh, subMesh) {
        this.component = component;
        this.material = material;
        this.mesh = mesh;
        this.subMesh = subMesh;
    };
    _proto.dispose = function dispose() {
        this.component = this.material = this.mesh = this.subMesh = null;
    };
    return MeshRenderData;
}(RenderData);

/**
 * Pipeline stage.
 */ var PipelineStage;
(function(PipelineStage) {
    PipelineStage[/** Shadow caster stage. */ "ShadowCaster"] = "ShadowCaster";
    PipelineStage[/** Forward shading stage. */ "Forward"] = "Forward";
})(PipelineStage || (PipelineStage = {}));

function _extends$2() {
    _extends$2 = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends$2.apply(this, arguments);
}

var camera_declare = "#define GLSLIFY 1\nuniform vec3 camera_Position;"; // eslint-disable-line

var common = "#define GLSLIFY 1\n#define PI 3.14159265359\n#define RECIPROCAL_PI 0.31830988618\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate( a ) clamp( a, 0.0, 1.0 )\nfloat pow2(float x){return x*x;}vec4 RGBMToLinear(vec4 value,float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 gammaToLinear(vec4 srgbIn){return vec4(pow(srgbIn.rgb,vec3(2.2)),srgbIn.a);}vec4 linearToGamma(vec4 linearIn){return vec4(pow(linearIn.rgb,vec3(1.0/2.2)),linearIn.a);}\n#ifdef GRAPHICS_API_WEBGL2\n#define INVERSE_MAT(mat) inverse(mat)\n#else\nmat2 inverseMat(mat2 m){return mat2(m[1][1],-m[0][1],-m[1][0],m[0][0])/(m[0][0]*m[1][1]-m[0][1]*m[1][0]);}mat3 inverseMat(mat3 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2];float a10=m[1][0],a11=m[1][1],a12=m[1][2];float a20=m[2][0],a21=m[2][1],a22=m[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}mat4 inverseMat(mat4 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return mat4(a11*b11-a12*b10+a13*b09,a02*b10-a01*b11-a03*b09,a31*b05-a32*b04+a33*b03,a22*b04-a21*b05-a23*b03,a12*b08-a10*b11-a13*b07,a00*b11-a02*b08+a03*b07,a32*b02-a30*b05-a33*b01,a20*b05-a22*b02+a23*b01,a10*b10-a11*b08+a13*b06,a01*b08-a00*b10-a03*b06,a30*b04-a31*b02+a33*b00,a21*b02-a20*b04-a23*b00,a11*b07-a10*b09-a12*b06,a00*b09-a01*b07+a02*b06,a31*b01-a30*b03-a32*b00,a20*b03-a21*b01+a22*b00)/det;}\n#define INVERSE_MAT(mat) inverseMat(mat)\n#endif\n"; // eslint-disable-line

var common_vert = "#define GLSLIFY 1\nattribute vec3 POSITION;\n#ifdef RENDERER_HAS_UV\nattribute vec2 TEXCOORD_0;\n#endif\n#ifdef RENDERER_HAS_UV1\nattribute vec2 TEXCOORD_1;\n#endif\n#ifdef RENDERER_HAS_SKIN\nattribute vec4 JOINTS_0;attribute vec4 WEIGHTS_0;\n#ifdef RENDERER_USE_JOINT_TEXTURE\nuniform sampler2D renderer_JointSampler;uniform float renderer_JointCount;mat4 getJointMatrix(sampler2D smp,float index){float base=index/renderer_JointCount;float hf=0.5/renderer_JointCount;float v=base+hf;vec4 m0=texture2D(smp,vec2(0.125,v));vec4 m1=texture2D(smp,vec2(0.375,v));vec4 m2=texture2D(smp,vec2(0.625,v));vec4 m3=texture2D(smp,vec2(0.875,v));return mat4(m0,m1,m2,m3);}\n#else\nuniform mat4 renderer_JointMatrix[RENDERER_JOINTS_NUM];\n#endif\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nattribute vec4 COLOR_0;\n#endif\n#include <transform_declare>\n#include <camera_declare>\nuniform vec4 material_TilingOffset;\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nattribute vec3 NORMAL;\n#endif\n#ifdef RENDERER_HAS_TANGENT\nattribute vec4 TANGENT;\n#endif\n#endif\n"; // eslint-disable-line

var transform_declare = "#define GLSLIFY 1\nuniform mat4 renderer_LocalMat;uniform mat4 renderer_ModelMat;uniform mat4 camera_ViewMat;uniform mat4 camera_ProjMat;uniform mat4 renderer_MVMat;uniform mat4 renderer_MVPMat;uniform mat4 renderer_NormalMat;"; // eslint-disable-line

var color_share = "#define GLSLIFY 1\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nvarying vec4 v_color;\n#endif\n"; // eslint-disable-line

var FogFragmentDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvarying vec3 v_positionVS;uniform vec4 scene_FogColor;uniform vec4 scene_FogParams;float ComputeFogIntensity(float fogDepth){\n#if SCENE_FOG_MODE == 1\nreturn clamp(fogDepth*scene_FogParams.x+scene_FogParams.y,0.0,1.0);\n#elif SCENE_FOG_MODE == 2\nreturn clamp(exp2(-fogDepth*scene_FogParams.z),0.0,1.0);\n#elif SCENE_FOG_MODE == 3\nfloat factor=fogDepth*scene_FogParams.w;return clamp(exp2(-factor*factor),0.0,1.0);\n#endif\n}\n#endif\n"; // eslint-disable-line

var FogVertexDeclaration = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvarying vec3 v_positionVS;\n#endif\n"; // eslint-disable-line

var normal_share = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvarying vec3 v_normal;\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvarying mat3 v_TBN;\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var uv_share = "#define GLSLIFY 1\nvarying vec2 v_uv;\n#ifdef RENDERER_HAS_UV1\nvarying vec2 v_uv1;\n#endif\n"; // eslint-disable-line

var worldpos_share = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvarying vec3 v_pos;\n#endif\n"; // eslint-disable-line

var begin_normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvec3 normal=vec3(NORMAL);\n#endif\n#ifdef RENDERER_HAS_TANGENT\nvec4 tangent=vec4(TANGENT);\n#endif\n#endif\n"; // eslint-disable-line

var begin_position_vert = "#define GLSLIFY 1\nvec4 position=vec4(POSITION,1.0);"; // eslint-disable-line

var blendShape_input = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nuniform mediump sampler2DArray renderer_BlendShapeTexture;uniform ivec3 renderer_BlendShapeTextureInfo;uniform float renderer_BlendShapeWeights[RENDERER_BLENDSHAPE_COUNT];\n#else\nattribute vec3 POSITION_BS0;attribute vec3 POSITION_BS1;\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;uniform float renderer_BlendShapeWeights[2];\n#else\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\nattribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;\n#ifdef RENDERER_BLENDSHAPE_HAS_NORMAL\nattribute vec3 NORMAL_BS0;attribute vec3 NORMAL_BS1;attribute vec3 NORMAL_BS2;attribute vec3 NORMAL_BS3;\n#endif\n#ifdef RENDERER_BLENDSHAPE_HAS_TANGENT\nattribute vec3 TANGENT_BS0;attribute vec3 TANGENT_BS1;attribute vec3 TANGENT_BS2;attribute vec3 TANGENT_BS3;\n#endif\nuniform float renderer_BlendShapeWeights[4];\n#else\nattribute vec3 POSITION_BS2;attribute vec3 POSITION_BS3;attribute vec3 POSITION_BS4;attribute vec3 POSITION_BS5;attribute vec3 POSITION_BS6;attribute vec3 POSITION_BS7;uniform float renderer_BlendShapeWeights[8];\n#endif\n#endif\n#endif\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nvec3 getBlendShapeVertexElement(int blendShapeIndex,int vertexElementIndex){int y=vertexElementIndex/renderer_BlendShapeTextureInfo.y;int x=vertexElementIndex-y*renderer_BlendShapeTextureInfo.y;ivec3 uv=ivec3(x,y,blendShapeIndex);return texelFetch(renderer_BlendShapeTexture,uv,0).xyz;}\n#endif\n#endif\n"; // eslint-disable-line

var blendShape_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_BLENDSHAPE\n#ifdef RENDERER_BLENDSHAPE_USE_TEXTURE\nint vertexOffset=gl_VertexID*renderer_BlendShapeTextureInfo.x;for(int i=0;i<RENDERER_BLENDSHAPE_COUNT;i++){int vertexElementOffset=vertexOffset;float weight=renderer_BlendShapeWeights[i];position.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#ifndef MATERIAL_OMIT_NORMAL\n#if defined( RENDERER_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_NORMAL )\nvertexElementOffset+=1;normal+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#if defined( RENDERER_HAS_TANGENT ) && defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvertexElementOffset+=1;tangent.xyz+=getBlendShapeVertexElement(i,vertexElementOffset)*weight;\n#endif\n#endif\n}\n#else\nposition.xyz+=POSITION_BS0*renderer_BlendShapeWeights[0];position.xyz+=POSITION_BS1*renderer_BlendShapeWeights[1];\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nnormal+=NORMAL_BS0*renderer_BlendShapeWeights[0];normal+=NORMAL_BS1*renderer_BlendShapeWeights[1];\n#endif\n#if defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz+=TANGENT_BS0*renderer_BlendShapeWeights[0];tangent.xyz+=TANGENT_BS1*renderer_BlendShapeWeights[1];\n#endif\n#endif\n#else\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) || defined( RENDERER_BLENDSHAPE_HAS_TANGENT )\n#ifndef MATERIAL_OMIT_NORMAL\nposition.xyz+=POSITION_BS2*renderer_BlendShapeWeights[2];position.xyz+=POSITION_BS3*renderer_BlendShapeWeights[3];\n#if defined( RENDERER_BLENDSHAPE_HAS_NORMAL ) && defined( RENDERER_HAS_NORMAL )\nnormal+=NORMAL_BS0*renderer_BlendShapeWeights[0];normal+=NORMAL_BS1*renderer_BlendShapeWeights[1];normal+=NORMAL_BS2*renderer_BlendShapeWeights[2];normal+=NORMAL_BS3*renderer_BlendShapeWeights[3];\n#endif\n#if defined(RENDERER_BLENDSHAPE_HAS_TANGENT) && defined( RENDERER_HAS_TANGENT ) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz+=TANGENT_BS0*renderer_BlendShapeWeights[0];tangent.xyz+=TANGENT_BS1*renderer_BlendShapeWeights[1];tangent.xyz+=TANGENT_BS2*renderer_BlendShapeWeights[2];tangent.xyz+=TANGENT_BS3*renderer_BlendShapeWeights[3];\n#endif\n#endif\n#else\nposition.xyz+=POSITION_BS2*renderer_BlendShapeWeights[2];position.xyz+=POSITION_BS3*renderer_BlendShapeWeights[3];position.xyz+=POSITION_BS4*renderer_BlendShapeWeights[4];position.xyz+=POSITION_BS5*renderer_BlendShapeWeights[5];position.xyz+=POSITION_BS6*renderer_BlendShapeWeights[6];position.xyz+=POSITION_BS7*renderer_BlendShapeWeights[7];\n#endif\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var color_vert = "#define GLSLIFY 1\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nv_color=COLOR_0;\n#endif\n"; // eslint-disable-line

var FogVertex = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nvec4 positionVS=renderer_MVMat*position;v_positionVS=positionVS.xyz/positionVS.w;\n#endif\n"; // eslint-disable-line

var normal_vert = "#define GLSLIFY 1\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nv_normal=normalize(mat3(renderer_NormalMat)*normal);\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nvec3 normalW=normalize(mat3(renderer_NormalMat)*normal.xyz);vec3 tangentW=normalize(mat3(renderer_NormalMat)*tangent.xyz);vec3 bitangentW=cross(normalW,tangentW)*tangent.w;v_TBN=mat3(tangentW,bitangentW,normalW);\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var position_vert = "#define GLSLIFY 1\ngl_Position=renderer_MVPMat*position;"; // eslint-disable-line

var skinning_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_SKIN\n#ifdef RENDERER_USE_JOINT_TEXTURE\nmat4 skinMatrix=WEIGHTS_0.x*getJointMatrix(renderer_JointSampler,JOINTS_0.x)+WEIGHTS_0.y*getJointMatrix(renderer_JointSampler,JOINTS_0.y)+WEIGHTS_0.z*getJointMatrix(renderer_JointSampler,JOINTS_0.z)+WEIGHTS_0.w*getJointMatrix(renderer_JointSampler,JOINTS_0.w);\n#else\nmat4 skinMatrix=WEIGHTS_0.x*renderer_JointMatrix[int(JOINTS_0.x)]+WEIGHTS_0.y*renderer_JointMatrix[int(JOINTS_0.y)]+WEIGHTS_0.z*renderer_JointMatrix[int(JOINTS_0.z)]+WEIGHTS_0.w*renderer_JointMatrix[int(JOINTS_0.w)];\n#endif\nposition=skinMatrix*position;\n#if defined(RENDERER_HAS_NORMAL) && !defined(MATERIAL_OMIT_NORMAL)\nmat3 skinNormalMatrix=INVERSE_MAT(mat3(skinMatrix));normal=normal*skinNormalMatrix;\n#if defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\ntangent.xyz=tangent.xyz*skinNormalMatrix;\n#endif\n#endif\n#endif\n"; // eslint-disable-line

var uv_vert = "#define GLSLIFY 1\n#ifdef RENDERER_HAS_UV\nv_uv=TEXCOORD_0;\n#else\nv_uv=vec2(0.,0.);\n#endif\n#ifdef RENDERER_HAS_UV1\nv_uv1=TEXCOORD_1;\n#endif\n#ifdef MATERIAL_NEED_TILING_OFFSET\nv_uv=v_uv*material_TilingOffset.xy+material_TilingOffset.zw;\n#endif\n"; // eslint-disable-line

var worldpos_vert = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvec4 temp_pos=renderer_ModelMat*position;v_pos=temp_pos.xyz/temp_pos.w;\n#endif\n"; // eslint-disable-line

var FogFragment = "#define GLSLIFY 1\n#if SCENE_FOG_MODE != 0\nfloat fogIntensity=ComputeFogIntensity(length(v_positionVS));gl_FragColor.rgb=mix(scene_FogColor.rgb,gl_FragColor.rgb,fogIntensity);\n#endif\n"; // eslint-disable-line

var light_frag_define = "#define GLSLIFY 1\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nstruct DirectLight{vec3 color;vec3 direction;};uniform ivec2 scene_DirectLightCullingMask[SCENE_DIRECT_LIGHT_COUNT];uniform vec3 scene_DirectLightColor[SCENE_DIRECT_LIGHT_COUNT];uniform vec3 scene_DirectLightDirection[SCENE_DIRECT_LIGHT_COUNT];\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nstruct PointLight{vec3 color;vec3 position;float distance;};uniform ivec2 scene_PointLightCullingMask[SCENE_POINT_LIGHT_COUNT];uniform vec3 scene_PointLightColor[SCENE_POINT_LIGHT_COUNT];uniform vec3 scene_PointLightPosition[SCENE_POINT_LIGHT_COUNT];uniform float scene_PointLightDistance[SCENE_POINT_LIGHT_COUNT];\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nstruct SpotLight{vec3 color;vec3 position;vec3 direction;float distance;float angleCos;float penumbraCos;};uniform ivec2 scene_SpotLightCullingMask[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightColor[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightPosition[SCENE_SPOT_LIGHT_COUNT];uniform vec3 scene_SpotLightDirection[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightDistance[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightAngleCos[SCENE_SPOT_LIGHT_COUNT];uniform float scene_SpotLightPenumbraCos[SCENE_SPOT_LIGHT_COUNT];\n#endif\nstruct EnvMapLight{vec3 diffuse;float mipMapLevel;float diffuseIntensity;float specularIntensity;};uniform EnvMapLight scene_EnvMapLight;uniform ivec4 renderer_Layer;\n#ifdef SCENE_USE_SH\nuniform vec3 scene_EnvSH[9];\n#endif\n#ifdef SCENE_USE_SPECULAR_ENV\nuniform samplerCube scene_EnvSpecularSampler;\n#endif\n#ifndef GRAPHICS_API_WEBGL2\nbool isBitSet(float value,float mask,float bitIndex){return mod(floor(value/pow(2.0,bitIndex)),2.0)==1.0&&mod(floor(mask/pow(2.0,bitIndex)),2.0)==1.0;}\n#endif\nbool isRendererCulledByLight(ivec2 rendererLayer,ivec2 lightCullingMask){\n#ifdef GRAPHICS_API_WEBGL2\nreturn!((rendererLayer.x&lightCullingMask.x)!=0||(rendererLayer.y&lightCullingMask.y)!=0);\n#else\nfor(int i=0;i<16;i++){if(isBitSet(float(rendererLayer.x),float(lightCullingMask.x),float(i))||isBitSet(float(rendererLayer.y),float(lightCullingMask.y),float(i))){return false;}}return true;\n#endif\n}"; // eslint-disable-line

var mobile_material_frag = "#define GLSLIFY 1\nuniform vec4 material_EmissiveColor;uniform vec4 material_BaseColor;uniform vec4 material_SpecularColor;uniform float material_Shininess;uniform float material_NormalIntensity;uniform float material_AlphaCutoff;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nuniform sampler2D material_EmissiveTexture;\n#endif\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_TEXTURE\nuniform sampler2D material_SpecularTexture;\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nuniform sampler2D material_NormalTexture;\n#endif\n"; // eslint-disable-line

var begin_mobile_frag = "#define GLSLIFY 1\nvec4 ambient=vec4(0.0);vec4 emission=material_EmissiveColor;vec4 diffuse=material_BaseColor;vec4 specular=material_SpecularColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nvec4 emissiveTextureColor=texture2D(material_EmissiveTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nemissiveTextureColor=gammaToLinear(emissiveTextureColor);\n#endif\nemission*=emissiveTextureColor;\n#endif\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 diffuseTextureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ndiffuseTextureColor=gammaToLinear(diffuseTextureColor);\n#endif\ndiffuse*=diffuseTextureColor;\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\ndiffuse*=v_color;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_TEXTURE\nvec4 specularTextureColor=texture2D(material_SpecularTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nspecularTextureColor=gammaToLinear(specularTextureColor);\n#endif\nspecular*=specularTextureColor;\n#endif\nambient=vec4(scene_EnvMapLight.diffuse*scene_EnvMapLight.diffuseIntensity,1.0)*diffuse;"; // eslint-disable-line

var begin_viewdir_frag = "#define GLSLIFY 1\n#ifdef MATERIAL_NEED_WORLD_POS\nvec3 V=normalize(camera_Position-v_pos);\n#endif\n"; // eslint-disable-line

var mobile_blinnphong_frag = "#define GLSLIFY 1\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nmat3 tbn=getTBN(gl_FrontFacing);vec3 N=getNormalByNormalTexture(tbn,material_NormalTexture,material_NormalIntensity,v_uv,gl_FrontFacing);\n#else\nvec3 N=getNormal(gl_FrontFacing);\n#endif\nvec3 lightDiffuse=vec3(0.0,0.0,0.0);vec3 lightSpecular=vec3(0.0,0.0,0.0);float shadowAttenuation=1.0;\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nshadowAttenuation=1.0;\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nshadowAttenuation*=sampleShadowMap();int sunIndex=int(scene_ShadowInfo.z);\n#endif\nDirectLight directionalLight;for(int i=0;i<SCENE_DIRECT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_DirectLightCullingMask[i]))continue;directionalLight.color=scene_DirectLightColor[i];\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nif(i==sunIndex){directionalLight.color*=shadowAttenuation;}\n#endif\ndirectionalLight.direction=scene_DirectLightDirection[i];float d=max(dot(N,-directionalLight.direction),0.0);lightDiffuse+=directionalLight.color*d;vec3 halfDir=normalize(V-directionalLight.direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess);lightSpecular+=directionalLight.color*s;}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<SCENE_POINT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_PointLightCullingMask[i]))continue;pointLight.color=scene_PointLightColor[i];pointLight.position=scene_PointLightPosition[i];pointLight.distance=scene_PointLightDistance[i];vec3 direction=v_pos-pointLight.position;float dist=length(direction);direction/=dist;float decay=clamp(1.0-pow(dist/pointLight.distance,4.0),0.0,1.0);float d=max(dot(N,-direction),0.0)*decay;lightDiffuse+=pointLight.color*d;vec3 halfDir=normalize(V-direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess)*decay;lightSpecular+=pointLight.color*s;}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<SCENE_SPOT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_SpotLightCullingMask[i]))continue;spotLight.color=scene_SpotLightColor[i];spotLight.position=scene_SpotLightPosition[i];spotLight.direction=scene_SpotLightDirection[i];spotLight.distance=scene_SpotLightDistance[i];spotLight.angleCos=scene_SpotLightAngleCos[i];spotLight.penumbraCos=scene_SpotLightPenumbraCos[i];vec3 direction=spotLight.position-v_pos;float lightDistance=length(direction);direction/=lightDistance;float angleCos=dot(direction,-spotLight.direction);float decay=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayTotal=decay*spotEffect;float d=max(dot(N,direction),0.0)*decayTotal;lightDiffuse+=spotLight.color*d;vec3 halfDir=normalize(V+direction);float s=pow(clamp(dot(N,halfDir),0.0,1.0),material_Shininess)*decayTotal;lightSpecular+=spotLight.color*s;}\n#endif\ndiffuse*=vec4(lightDiffuse,1.0);specular*=vec4(lightSpecular,1.0);\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(diffuse.a<material_AlphaCutoff){discard;}\n#endif\n"; // eslint-disable-line

var noise_cellular = "#define GLSLIFY 1\n#include <noise_cellular_2D>\n#include <noise_cellular_3D>\n#include <noise_cellular_2x2>\n#include <noise_cellular_2x2x2>\n"; // eslint-disable-line

var noise_cellular_2D = "#define GLSLIFY 1\nvec2 cellular(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec3 oi=vec3(-1.0,0.0,1.0);vec3 of=vec3(-0.5,0.5,1.5);vec3 px=permute(Pi.x+oi);vec3 p=permute(px.x+Pi.y+oi);vec3 ox=fract(p*K)-Ko;vec3 oy=mod7(floor(p*K))*K-Ko;vec3 dx=Pf.x+0.5+jitter*ox;vec3 dy=Pf.y-of+jitter*oy;vec3 d1=dx*dx+dy*dy;p=permute(px.y+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-0.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d2=dx*dx+dy*dy;p=permute(px.z+Pi.y+oi);ox=fract(p*K)-Ko;oy=mod7(floor(p*K))*K-Ko;dx=Pf.x-1.5+jitter*ox;dy=Pf.y-of+jitter*oy;vec3 d3=dx*dx+dy*dy;vec3 d1a=min(d1,d2);d2=max(d1,d2);d2=min(d2,d3);d1=min(d1a,d2);d2=max(d1a,d2);d1.xy=(d1.x<d1.y)? d1.xy : d1.yx;d1.xz=(d1.x<d1.z)? d1.xz : d1.zx;d1.yz=min(d1.yz,d2.yz);d1.y=min(d1.y,d1.z);d1.y=min(d1.y,d2.x);return sqrt(d1.xy);}"; // eslint-disable-line

var noise_cellular_2x2 = "#define GLSLIFY 1\nvec2 cellular2x2(vec2 P){vec2 Pi=mod289(floor(P));vec2 Pf=fract(P);vec4 Pfx=Pf.x+vec4(-0.5,-1.5,-0.5,-1.5);vec4 Pfy=Pf.y+vec4(-0.5,-0.5,-1.5,-1.5);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 ox=mod7(p)*K+Kd2;vec4 oy=mod7(floor(p*K))*K+Kd2;vec4 dx=Pfx+jitter1*ox;vec4 dy=Pfy+jitter1*oy;vec4 d=dx*dx+dy*dy;d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.y=min(d.y,d.z);d.y=min(d.y,d.w);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_2x2x2 = "#define GLSLIFY 1\nvec2 cellular2x2x2(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P);vec4 Pfx=Pf.x+vec4(0.0,-1.0,0.0,-1.0);vec4 Pfy=Pf.y+vec4(0.0,0.0,-1.0,-1.0);vec4 p=permute(Pi.x+vec4(0.0,1.0,0.0,1.0));p=permute(p+Pi.y+vec4(0.0,0.0,1.0,1.0));vec4 p1=permute(p+Pi.z);vec4 p2=permute(p+Pi.z+vec4(1.0));vec4 ox1=fract(p1*K)-Ko;vec4 oy1=mod7(floor(p1*K))*K-Ko;vec4 oz1=floor(p1*K2)*Kz-Kzo;vec4 ox2=fract(p2*K)-Ko;vec4 oy2=mod7(floor(p2*K))*K-Ko;vec4 oz2=floor(p2*K2)*Kz-Kzo;vec4 dx1=Pfx+jitter1*ox1;vec4 dy1=Pfy+jitter1*oy1;vec4 dz1=Pf.z+jitter1*oz1;vec4 dx2=Pfx+jitter1*ox2;vec4 dy2=Pfy+jitter1*oy2;vec4 dz2=Pf.z-1.0+jitter1*oz2;vec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;vec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;vec4 d=min(d1,d2);d2=max(d1,d2);d.xy=(d.x<d.y)? d.xy : d.yx;d.xz=(d.x<d.z)? d.xz : d.zx;d.xw=(d.x<d.w)? d.xw : d.wx;d.yzw=min(d.yzw,d2.yzw);d.y=min(d.y,d.z);d.y=min(d.y,d.w);d.y=min(d.y,d2.x);return sqrt(d.xy);}"; // eslint-disable-line

var noise_cellular_3D = "#define GLSLIFY 1\nvec2 cellular(vec3 P){vec3 Pi=mod289(floor(P));vec3 Pf=fract(P)-0.5;vec3 Pfx=Pf.x+vec3(1.0,0.0,-1.0);vec3 Pfy=Pf.y+vec3(1.0,0.0,-1.0);vec3 Pfz=Pf.z+vec3(1.0,0.0,-1.0);vec3 p=permute(Pi.x+vec3(-1.0,0.0,1.0));vec3 p1=permute(p+Pi.y-1.0);vec3 p2=permute(p+Pi.y);vec3 p3=permute(p+Pi.y+1.0);vec3 p11=permute(p1+Pi.z-1.0);vec3 p12=permute(p1+Pi.z);vec3 p13=permute(p1+Pi.z+1.0);vec3 p21=permute(p2+Pi.z-1.0);vec3 p22=permute(p2+Pi.z);vec3 p23=permute(p2+Pi.z+1.0);vec3 p31=permute(p3+Pi.z-1.0);vec3 p32=permute(p3+Pi.z);vec3 p33=permute(p3+Pi.z+1.0);vec3 ox11=fract(p11*K)-Ko;vec3 oy11=mod7(floor(p11*K))*K-Ko;vec3 oz11=floor(p11*K2)*Kz-Kzo;vec3 ox12=fract(p12*K)-Ko;vec3 oy12=mod7(floor(p12*K))*K-Ko;vec3 oz12=floor(p12*K2)*Kz-Kzo;vec3 ox13=fract(p13*K)-Ko;vec3 oy13=mod7(floor(p13*K))*K-Ko;vec3 oz13=floor(p13*K2)*Kz-Kzo;vec3 ox21=fract(p21*K)-Ko;vec3 oy21=mod7(floor(p21*K))*K-Ko;vec3 oz21=floor(p21*K2)*Kz-Kzo;vec3 ox22=fract(p22*K)-Ko;vec3 oy22=mod7(floor(p22*K))*K-Ko;vec3 oz22=floor(p22*K2)*Kz-Kzo;vec3 ox23=fract(p23*K)-Ko;vec3 oy23=mod7(floor(p23*K))*K-Ko;vec3 oz23=floor(p23*K2)*Kz-Kzo;vec3 ox31=fract(p31*K)-Ko;vec3 oy31=mod7(floor(p31*K))*K-Ko;vec3 oz31=floor(p31*K2)*Kz-Kzo;vec3 ox32=fract(p32*K)-Ko;vec3 oy32=mod7(floor(p32*K))*K-Ko;vec3 oz32=floor(p32*K2)*Kz-Kzo;vec3 ox33=fract(p33*K)-Ko;vec3 oy33=mod7(floor(p33*K))*K-Ko;vec3 oz33=floor(p33*K2)*Kz-Kzo;vec3 dx11=Pfx+jitter*ox11;vec3 dy11=Pfy.x+jitter*oy11;vec3 dz11=Pfz.x+jitter*oz11;vec3 dx12=Pfx+jitter*ox12;vec3 dy12=Pfy.x+jitter*oy12;vec3 dz12=Pfz.y+jitter*oz12;vec3 dx13=Pfx+jitter*ox13;vec3 dy13=Pfy.x+jitter*oy13;vec3 dz13=Pfz.z+jitter*oz13;vec3 dx21=Pfx+jitter*ox21;vec3 dy21=Pfy.y+jitter*oy21;vec3 dz21=Pfz.x+jitter*oz21;vec3 dx22=Pfx+jitter*ox22;vec3 dy22=Pfy.y+jitter*oy22;vec3 dz22=Pfz.y+jitter*oz22;vec3 dx23=Pfx+jitter*ox23;vec3 dy23=Pfy.y+jitter*oy23;vec3 dz23=Pfz.z+jitter*oz23;vec3 dx31=Pfx+jitter*ox31;vec3 dy31=Pfy.z+jitter*oy31;vec3 dz31=Pfz.x+jitter*oz31;vec3 dx32=Pfx+jitter*ox32;vec3 dy32=Pfy.z+jitter*oy32;vec3 dz32=Pfz.y+jitter*oz32;vec3 dx33=Pfx+jitter*ox33;vec3 dy33=Pfy.z+jitter*oy33;vec3 dz33=Pfz.z+jitter*oz33;vec3 d11=dx11*dx11+dy11*dy11+dz11*dz11;vec3 d12=dx12*dx12+dy12*dy12+dz12*dz12;vec3 d13=dx13*dx13+dy13*dy13+dz13*dz13;vec3 d21=dx21*dx21+dy21*dy21+dz21*dz21;vec3 d22=dx22*dx22+dy22*dy22+dz22*dz22;vec3 d23=dx23*dx23+dy23*dy23+dz23*dz23;vec3 d31=dx31*dx31+dy31*dy31+dz31*dz31;vec3 d32=dx32*dx32+dy32*dy32+dz32*dz32;vec3 d33=dx33*dx33+dy33*dy33+dz33*dz33;vec3 d1a=min(d11,d12);d12=max(d11,d12);d11=min(d1a,d13);d13=max(d1a,d13);d12=min(d12,d13);vec3 d2a=min(d21,d22);d22=max(d21,d22);d21=min(d2a,d23);d23=max(d2a,d23);d22=min(d22,d23);vec3 d3a=min(d31,d32);d32=max(d31,d32);d31=min(d3a,d33);d33=max(d3a,d33);d32=min(d32,d33);vec3 da=min(d11,d21);d21=max(d11,d21);d11=min(da,d31);d31=max(da,d31);d11.xy=(d11.x<d11.y)? d11.xy : d11.yx;d11.xz=(d11.x<d11.z)? d11.xz : d11.zx;d12=min(d12,d21);d12=min(d12,d22);d12=min(d12,d31);d12=min(d12,d32);d11.yz=min(d11.yz,d12.xy);d11.y=min(d11.y,d12.z);d11.y=min(d11.y,d11.z);return sqrt(d11.xy);}"; // eslint-disable-line

var noise_common = "#define GLSLIFY 1\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec2 mod289(vec2 x){return x-floor(x*(1.0/289.0))*289.0;}float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod7(vec4 x){return x-floor(x*(1.0/7.0))*7.0;}vec3 mod7(vec3 x){return x-floor(x*(1.0/7.0))*7.0;}vec4 permute(vec4 x){return mod289((34.0*x+1.0)*x);}vec3 permute(vec3 x){return mod289((34.0*x+1.0)*x);}float permute(float x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float taylorInvSqrt(float r){return 1.79284291400159-0.85373472095314*r;}vec4 fade(vec4 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}vec2 fade(vec2 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}\n#define K 0.142857142857\n#define Ko 0.428571428571\n#define K2 0.020408163265306\n#define Kd2 0.0714285714285\n#define Kz 0.166666666667\n#define Kzo 0.416666666667\n#define jitter 1.0\n#define jitter1 0.8\n"; // eslint-disable-line

var noise_perlin = "#define GLSLIFY 1\n#include <noise_perlin_2D>\n#include <noise_perlin_3D>\n#include <noise_perlin_4D>\n"; // eslint-disable-line

var noise_perlin_2D = "#define GLSLIFY 1\nfloat perlin(vec2 P){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}float perlin(vec2 P,vec2 rep){vec4 Pi=floor(P.xyxy)+vec4(0.0,0.0,1.0,1.0);vec4 Pf=fract(P.xyxy)-vec4(0.0,0.0,1.0,1.0);Pi=mod(Pi,rep.xyxy);Pi=mod289(Pi);vec4 ix=Pi.xzxz;vec4 iy=Pi.yyww;vec4 fx=Pf.xzxz;vec4 fy=Pf.yyww;vec4 i=permute(permute(ix)+iy);vec4 gx=fract(i*(1.0/41.0))*2.0-1.0;vec4 gy=abs(gx)-0.5;vec4 tx=floor(gx+0.5);gx=gx-tx;vec2 g00=vec2(gx.x,gy.x);vec2 g10=vec2(gx.y,gy.y);vec2 g01=vec2(gx.z,gy.z);vec2 g11=vec2(gx.w,gy.w);vec4 norm=taylorInvSqrt(vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11)));g00*=norm.x;g01*=norm.y;g10*=norm.z;g11*=norm.w;float n00=dot(g00,vec2(fx.x,fy.x));float n10=dot(g10,vec2(fx.y,fy.y));float n01=dot(g01,vec2(fx.z,fy.z));float n11=dot(g11,vec2(fx.w,fy.w));vec2 fade_xy=fade(Pf.xy);vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);float n_xy=mix(n_x.x,n_x.y,fade_xy.y);return 2.3*n_xy;}"; // eslint-disable-line

var noise_perlin_3D = "#define GLSLIFY 1\nfloat perlin(vec3 P){vec3 Pi0=floor(P);vec3 Pi1=Pi0+vec3(1.0);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}float perlin(vec3 P,vec3 rep){vec3 Pi0=mod(floor(P),rep);vec3 Pi1=mod(Pi0+vec3(1.0),rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P);vec3 Pf1=Pf0-vec3(1.0);vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}"; // eslint-disable-line

var noise_perlin_4D = "#define GLSLIFY 1\nfloat perlin(vec4 P){vec4 Pi0=floor(P);vec4 Pi1=Pi0+1.0;Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}float perlin(vec4 P,vec4 rep){vec4 Pi0=mod(floor(P),rep);vec4 Pi1=mod(Pi0+1.0,rep);Pi0=mod289(Pi0);Pi1=mod289(Pi1);vec4 Pf0=fract(P);vec4 Pf1=Pf0-1.0;vec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=vec4(Pi0.zzzz);vec4 iz1=vec4(Pi1.zzzz);vec4 iw0=vec4(Pi0.wwww);vec4 iw1=vec4(Pi1.wwww);vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 ixy00=permute(ixy0+iw0);vec4 ixy01=permute(ixy0+iw1);vec4 ixy10=permute(ixy1+iw0);vec4 ixy11=permute(ixy1+iw1);vec4 gx00=ixy00*(1.0/7.0);vec4 gy00=floor(gx00)*(1.0/7.0);vec4 gz00=floor(gy00)*(1.0/6.0);gx00=fract(gx00)-0.5;gy00=fract(gy00)-0.5;gz00=fract(gz00)-0.5;vec4 gw00=vec4(0.75)-abs(gx00)-abs(gy00)-abs(gz00);vec4 sw00=step(gw00,vec4(0.0));gx00-=sw00*(step(0.0,gx00)-0.5);gy00-=sw00*(step(0.0,gy00)-0.5);vec4 gx01=ixy01*(1.0/7.0);vec4 gy01=floor(gx01)*(1.0/7.0);vec4 gz01=floor(gy01)*(1.0/6.0);gx01=fract(gx01)-0.5;gy01=fract(gy01)-0.5;gz01=fract(gz01)-0.5;vec4 gw01=vec4(0.75)-abs(gx01)-abs(gy01)-abs(gz01);vec4 sw01=step(gw01,vec4(0.0));gx01-=sw01*(step(0.0,gx01)-0.5);gy01-=sw01*(step(0.0,gy01)-0.5);vec4 gx10=ixy10*(1.0/7.0);vec4 gy10=floor(gx10)*(1.0/7.0);vec4 gz10=floor(gy10)*(1.0/6.0);gx10=fract(gx10)-0.5;gy10=fract(gy10)-0.5;gz10=fract(gz10)-0.5;vec4 gw10=vec4(0.75)-abs(gx10)-abs(gy10)-abs(gz10);vec4 sw10=step(gw10,vec4(0.0));gx10-=sw10*(step(0.0,gx10)-0.5);gy10-=sw10*(step(0.0,gy10)-0.5);vec4 gx11=ixy11*(1.0/7.0);vec4 gy11=floor(gx11)*(1.0/7.0);vec4 gz11=floor(gy11)*(1.0/6.0);gx11=fract(gx11)-0.5;gy11=fract(gy11)-0.5;gz11=fract(gz11)-0.5;vec4 gw11=vec4(0.75)-abs(gx11)-abs(gy11)-abs(gz11);vec4 sw11=step(gw11,vec4(0.0));gx11-=sw11*(step(0.0,gx11)-0.5);gy11-=sw11*(step(0.0,gy11)-0.5);vec4 g0000=vec4(gx00.x,gy00.x,gz00.x,gw00.x);vec4 g1000=vec4(gx00.y,gy00.y,gz00.y,gw00.y);vec4 g0100=vec4(gx00.z,gy00.z,gz00.z,gw00.z);vec4 g1100=vec4(gx00.w,gy00.w,gz00.w,gw00.w);vec4 g0010=vec4(gx10.x,gy10.x,gz10.x,gw10.x);vec4 g1010=vec4(gx10.y,gy10.y,gz10.y,gw10.y);vec4 g0110=vec4(gx10.z,gy10.z,gz10.z,gw10.z);vec4 g1110=vec4(gx10.w,gy10.w,gz10.w,gw10.w);vec4 g0001=vec4(gx01.x,gy01.x,gz01.x,gw01.x);vec4 g1001=vec4(gx01.y,gy01.y,gz01.y,gw01.y);vec4 g0101=vec4(gx01.z,gy01.z,gz01.z,gw01.z);vec4 g1101=vec4(gx01.w,gy01.w,gz01.w,gw01.w);vec4 g0011=vec4(gx11.x,gy11.x,gz11.x,gw11.x);vec4 g1011=vec4(gx11.y,gy11.y,gz11.y,gw11.y);vec4 g0111=vec4(gx11.z,gy11.z,gz11.z,gw11.z);vec4 g1111=vec4(gx11.w,gy11.w,gz11.w,gw11.w);vec4 norm00=taylorInvSqrt(vec4(dot(g0000,g0000),dot(g0100,g0100),dot(g1000,g1000),dot(g1100,g1100)));g0000*=norm00.x;g0100*=norm00.y;g1000*=norm00.z;g1100*=norm00.w;vec4 norm01=taylorInvSqrt(vec4(dot(g0001,g0001),dot(g0101,g0101),dot(g1001,g1001),dot(g1101,g1101)));g0001*=norm01.x;g0101*=norm01.y;g1001*=norm01.z;g1101*=norm01.w;vec4 norm10=taylorInvSqrt(vec4(dot(g0010,g0010),dot(g0110,g0110),dot(g1010,g1010),dot(g1110,g1110)));g0010*=norm10.x;g0110*=norm10.y;g1010*=norm10.z;g1110*=norm10.w;vec4 norm11=taylorInvSqrt(vec4(dot(g0011,g0011),dot(g0111,g0111),dot(g1011,g1011),dot(g1111,g1111)));g0011*=norm11.x;g0111*=norm11.y;g1011*=norm11.z;g1111*=norm11.w;float n0000=dot(g0000,Pf0);float n1000=dot(g1000,vec4(Pf1.x,Pf0.yzw));float n0100=dot(g0100,vec4(Pf0.x,Pf1.y,Pf0.zw));float n1100=dot(g1100,vec4(Pf1.xy,Pf0.zw));float n0010=dot(g0010,vec4(Pf0.xy,Pf1.z,Pf0.w));float n1010=dot(g1010,vec4(Pf1.x,Pf0.y,Pf1.z,Pf0.w));float n0110=dot(g0110,vec4(Pf0.x,Pf1.yz,Pf0.w));float n1110=dot(g1110,vec4(Pf1.xyz,Pf0.w));float n0001=dot(g0001,vec4(Pf0.xyz,Pf1.w));float n1001=dot(g1001,vec4(Pf1.x,Pf0.yz,Pf1.w));float n0101=dot(g0101,vec4(Pf0.x,Pf1.y,Pf0.z,Pf1.w));float n1101=dot(g1101,vec4(Pf1.xy,Pf0.z,Pf1.w));float n0011=dot(g0011,vec4(Pf0.xy,Pf1.zw));float n1011=dot(g1011,vec4(Pf1.x,Pf0.y,Pf1.zw));float n0111=dot(g0111,vec4(Pf0.x,Pf1.yzw));float n1111=dot(g1111,Pf1);vec4 fade_xyzw=fade(Pf0);vec4 n_0w=mix(vec4(n0000,n1000,n0100,n1100),vec4(n0001,n1001,n0101,n1101),fade_xyzw.w);vec4 n_1w=mix(vec4(n0010,n1010,n0110,n1110),vec4(n0011,n1011,n0111,n1111),fade_xyzw.w);vec4 n_zw=mix(n_0w,n_1w,fade_xyzw.z);vec2 n_yzw=mix(n_zw.xy,n_zw.zw,fade_xyzw.y);float n_xyzw=mix(n_yzw.x,n_yzw.y,fade_xyzw.x);return 2.2*n_xyzw;}"; // eslint-disable-line

var noise_psrd_2D = "#define GLSLIFY 1\nvec2 rgrad2(vec2 p,float rot){float u=permute(permute(p.x)+p.y)*0.0243902439+rot;u=fract(u)*6.28318530718;return vec2(cos(u),sin(u));}vec3 psrdnoise(vec2 pos,vec2 per,float rot){pos.y+=0.01;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 psdnoise(vec2 pos,vec2 per){return psrdnoise(pos,per,0.0);}float psrnoise(vec2 pos,vec2 per,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 xw=mod(vec3(p0.x,p1.x,p2.x),per.x);vec3 yw=mod(vec3(p0.y,p1.y,p2.y),per.y);vec3 iuw=xw+0.5*yw;vec3 ivw=yw;vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float psnoise(vec2 pos,vec2 per){return psrnoise(pos,per,0.0);}vec3 srdnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));vec3 dtdx=-2.0*vec3(d0.x,d1.x,d2.x);vec3 dtdy=-2.0*vec3(d0.y,d1.y,d2.y);if(t.x<0.0){dtdx.x=0.0;dtdy.x=0.0;t.x=0.0;}if(t.y<0.0){dtdx.y=0.0;dtdy.y=0.0;t.y=0.0;}if(t.z<0.0){dtdx.z=0.0;dtdy.z=0.0;t.z=0.0;}vec3 t2=t*t;vec3 t4=t2*t2;vec3 t3=t2*t;float n=dot(t4,w);vec2 dt0=vec2(dtdx.x,dtdy.x)*4.0*t3.x;vec2 dn0=t4.x*g0+dt0*w.x;vec2 dt1=vec2(dtdx.y,dtdy.y)*4.0*t3.y;vec2 dn1=t4.y*g1+dt1*w.y;vec2 dt2=vec2(dtdx.z,dtdy.z)*4.0*t3.z;vec2 dn2=t4.z*g2+dt2*w.z;return 11.0*vec3(n,dn0+dn1+dn2);}vec3 sdnoise(vec2 pos){return srdnoise(pos,0.0);}float srnoise(vec2 pos,float rot){pos.y+=0.001;vec2 uv=vec2(pos.x+pos.y*0.5,pos.y);vec2 i0=floor(uv);vec2 f0=fract(uv);vec2 i1=(f0.x>f0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec2 p0=vec2(i0.x-i0.y*0.5,i0.y);vec2 p1=vec2(p0.x+i1.x-i1.y*0.5,p0.y+i1.y);vec2 p2=vec2(p0.x+0.5,p0.y+1.0);i1=i0+i1;vec2 i2=i0+vec2(1.0,1.0);vec2 d0=pos-p0;vec2 d1=pos-p1;vec2 d2=pos-p2;vec3 x=vec3(p0.x,p1.x,p2.x);vec3 y=vec3(p0.y,p1.y,p2.y);vec3 iuw=x+0.5*y;vec3 ivw=y;iuw=mod289(iuw);ivw=mod289(ivw);vec2 g0=rgrad2(vec2(iuw.x,ivw.x),rot);vec2 g1=rgrad2(vec2(iuw.y,ivw.y),rot);vec2 g2=rgrad2(vec2(iuw.z,ivw.z),rot);vec3 w=vec3(dot(g0,d0),dot(g1,d1),dot(g2,d2));vec3 t=0.8-vec3(dot(d0,d0),dot(d1,d1),dot(d2,d2));t=max(t,0.0);vec3 t2=t*t;vec3 t4=t2*t2;float n=dot(t4,w);return 11.0*n;}float snoise(vec2 pos){return srnoise(pos,0.0);}"; // eslint-disable-line

var noise_simplex = "#define GLSLIFY 1\n#include <noise_simplex_2D>\n#include <noise_simplex_3D>\n#include <noise_simplex_3D_grad>\n#include <noise_simplex_4D>\n"; // eslint-disable-line

var noise_simplex_2D = "#define GLSLIFY 1\nfloat simplex(vec2 v){const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);vec2 i=floor(v+dot(v,C.yy));vec2 x0=v-i+dot(i,C.xx);vec2 i1;i1=(x0.x>x0.y)? vec2(1.0,0.0): vec2(0.0,1.0);vec4 x12=x0.xyxy+C.xxzz;x12.xy-=i1;i=mod289(i);vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);m=m*m;m=m*m;vec3 x=2.0*fract(p*C.www)-1.0;vec3 h=abs(x)-0.5;vec3 ox=floor(x+0.5);vec3 a0=x-ox;m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);vec3 g;g.x=a0.x*x0.x+h.x*x0.y;g.yz=a0.yz*x12.xz+h.yz*x12.yw;return 130.0*dot(m,g);}"; // eslint-disable-line

var noise_simplex_3D = "#define GLSLIFY 1\nfloat simplex(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

var noise_simplex_3D_grad = "#define GLSLIFY 1\nfloat simplex(vec3 v,out vec3 gradient){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);vec4 m2=m*m;vec4 m4=m2*m2;vec4 pdotx=vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3));vec4 temp=m2*m*pdotx;gradient=-8.0*(temp.x*x0+temp.y*x1+temp.z*x2+temp.w*x3);gradient+=m4.x*p0+m4.y*p1+m4.z*p2+m4.w*p3;gradient*=42.0;return 42.0*dot(m4,pdotx);}"; // eslint-disable-line

var noise_simplex_4D = "#define GLSLIFY 1\nvec4 grad4(float j,vec4 ip){const vec4 ones=vec4(1.0,1.0,1.0,-1.0);vec4 p,s;p.xyz=floor(fract(vec3(j)*ip.xyz)*7.0)*ip.z-1.0;p.w=1.5-dot(abs(p.xyz),ones.xyz);s=vec4(lessThan(p,vec4(0.0)));p.xyz=p.xyz+(s.xyz*2.0-1.0)*s.www;return p;}\n#define F4 0.309016994374947451\nfloat simplex(vec4 v){const vec4 C=vec4(0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);vec4 i=floor(v+dot(v,vec4(F4)));vec4 x0=v-i+dot(i,C.xxxx);vec4 i0;vec3 isX=step(x0.yzw,x0.xxx);vec3 isYZ=step(x0.zww,x0.yyz);i0.x=isX.x+isX.y+isX.z;i0.yzw=1.0-isX;i0.y+=isYZ.x+isYZ.y;i0.zw+=1.0-isYZ.xy;i0.z+=isYZ.z;i0.w+=1.0-isYZ.z;vec4 i3=clamp(i0,0.0,1.0);vec4 i2=clamp(i0-1.0,0.0,1.0);vec4 i1=clamp(i0-2.0,0.0,1.0);vec4 x1=x0-i1+C.xxxx;vec4 x2=x0-i2+C.yyyy;vec4 x3=x0-i3+C.zzzz;vec4 x4=x0+C.wwww;i=mod289(i);float j0=permute(permute(permute(permute(i.w)+i.z)+i.y)+i.x);vec4 j1=permute(permute(permute(permute(i.w+vec4(i1.w,i2.w,i3.w,1.0))+i.z+vec4(i1.z,i2.z,i3.z,1.0))+i.y+vec4(i1.y,i2.y,i3.y,1.0))+i.x+vec4(i1.x,i2.x,i3.x,1.0));vec4 ip=vec4(1.0/294.0,1.0/49.0,1.0/7.0,0.0);vec4 p0=grad4(j0,ip);vec4 p1=grad4(j1.x,ip);vec4 p2=grad4(j1.y,ip);vec4 p3=grad4(j1.z,ip);vec4 p4=grad4(j1.w,ip);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;p4*=taylorInvSqrt(dot(p4,p4));vec3 m0=max(0.6-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0);vec2 m1=max(0.6-vec2(dot(x3,x3),dot(x4,x4)),0.0);m0=m0*m0;m1=m1*m1;return 49.0*(dot(m0*m0,vec3(dot(p0,x0),dot(p1,x1),dot(p2,x2)))+dot(m1*m1,vec2(dot(p3,x3),dot(p4,x4))));}"; // eslint-disable-line

var pbr_frag_define = "#define GLSLIFY 1\nuniform float material_AlphaCutoff;uniform vec4 material_BaseColor;uniform float material_Metal;uniform float material_Roughness;uniform float material_IOR;uniform vec3 material_PBRSpecularColor;uniform float material_Glossiness;uniform vec3 material_EmissiveColor;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nuniform float material_ClearCoat;uniform float material_ClearCoatRoughness;\n#endif\nuniform float material_NormalIntensity;uniform float material_OcclusionIntensity;uniform float material_OcclusionTextureCoord;\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\nuniform sampler2D material_NormalTexture;\n#endif\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nuniform sampler2D material_EmissiveTexture;\n#endif\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\nuniform sampler2D material_RoughnessMetallicTexture;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\nuniform sampler2D material_SpecularGlossinessTexture;\n#endif\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\nuniform sampler2D material_OcclusionTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\nuniform sampler2D material_ClearCoatTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\nuniform sampler2D material_ClearCoatRoughnessTexture;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\nuniform sampler2D material_ClearCoatNormalTexture;\n#endif\nstruct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct Geometry{vec3 position;vec3 normal;vec3 viewDir;float dotNV;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nvec3 clearCoatNormal;float clearCoatDotNV;\n#endif\n};struct Material{vec3 diffuseColor;float roughness;vec3 specularColor;float opacity;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nfloat clearCoat;float clearCoatRoughness;\n#endif\n};"; // eslint-disable-line

var pbr_helper = "#define GLSLIFY 1\n#include <normal_get>\nfloat computeSpecularOcclusion(float ambientOcclusion,float roughness,float dotNV){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}float getAARoughnessFactor(vec3 normal){\n#ifdef HAS_DERIVATIVES\nvec3 dxy=max(abs(dFdx(normal)),abs(dFdy(normal)));return 0.04+max(max(dxy.x,dxy.y),dxy.z);\n#else\nreturn 0.04;\n#endif\n}void initGeometry(out Geometry geometry,bool isFrontFacing){geometry.position=v_pos;geometry.viewDir=normalize(camera_Position-v_pos);\n#if defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE)\nmat3 tbn=getTBN(isFrontFacing);\n#endif\n#ifdef MATERIAL_HAS_NORMALTEXTURE\ngeometry.normal=getNormalByNormalTexture(tbn,material_NormalTexture,material_NormalIntensity,v_uv,isFrontFacing);\n#else\ngeometry.normal=getNormal(isFrontFacing);\n#endif\ngeometry.dotNV=saturate(dot(geometry.normal,geometry.viewDir));\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\n#ifdef MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE\ngeometry.clearCoatNormal=getNormalByNormalTexture(tbn,material_ClearCoatNormalTexture,material_NormalIntensity,v_uv,isFrontFacing);\n#else\ngeometry.clearCoatNormal=getNormal(isFrontFacing);\n#endif\ngeometry.clearCoatDotNV=saturate(dot(geometry.clearCoatNormal,geometry.viewDir));\n#endif\n}void initMaterial(out Material material,const in Geometry geometry){vec4 baseColor=material_BaseColor;float metal=material_Metal;float roughness=material_Roughness;vec3 specularColor=material_PBRSpecularColor;float glossiness=material_Glossiness;float alphaCutoff=material_AlphaCutoff;float F0=pow2((material_IOR-1.0)/(material_IOR+1.0));\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 baseTextureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nbaseTextureColor=gammaToLinear(baseTextureColor);\n#endif\nbaseColor*=baseTextureColor;\n#endif\n#ifdef RENDERER_ENABLE_VERTEXCOLOR\nbaseColor*=v_color;\n#endif\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(baseColor.a<alphaCutoff){discard;}\n#endif\n#ifdef MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE\nvec4 metalRoughMapColor=texture2D(material_RoughnessMetallicTexture,v_uv);roughness*=metalRoughMapColor.g;metal*=metalRoughMapColor.b;\n#endif\n#ifdef MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE\nvec4 specularGlossinessColor=texture2D(material_SpecularGlossinessTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nspecularGlossinessColor=gammaToLinear(specularGlossinessColor);\n#endif\nspecularColor*=specularGlossinessColor.rgb;glossiness*=specularGlossinessColor.a;\n#endif\n#ifdef IS_METALLIC_WORKFLOW\nmaterial.diffuseColor=baseColor.rgb*(1.0-metal);material.specularColor=mix(vec3(F0),baseColor.rgb,metal);material.roughness=roughness;\n#else\nfloat specularStrength=max(max(specularColor.r,specularColor.g),specularColor.b);material.diffuseColor=baseColor.rgb*(1.0-specularStrength);material.specularColor=specularColor;material.roughness=1.0-glossiness;\n#endif\nmaterial.roughness=max(material.roughness,getAARoughnessFactor(geometry.normal));\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nmaterial.clearCoat=material_ClearCoat;material.clearCoatRoughness=material_ClearCoatRoughness;\n#ifdef MATERIAL_HAS_CLEAR_COAT_TEXTURE\nmaterial.clearCoat*=texture2D(material_ClearCoatTexture,v_uv).r;\n#endif\n#ifdef MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE\nmaterial.clearCoatRoughness*=texture2D(material_ClearCoatRoughnessTexture,v_uv).g;\n#endif\nmaterial.clearCoat=saturate(material.clearCoat);material.clearCoatRoughness=max(material.clearCoatRoughness,getAARoughnessFactor(geometry.clearCoatNormal));\n#endif\n#ifdef MATERIAL_IS_TRANSPARENT\nmaterial.opacity=baseColor.a;\n#else\nmaterial.opacity=1.0;\n#endif\n}\n#include <brdf>\n#include <direct_irradiance_frag_define>\n#include <ibl_frag_define>\n"; // eslint-disable-line

var brdf = "#define GLSLIFY 1\nfloat F_Schlick(float dotLH){return 0.04+0.96*(pow(1.0-dotLH,5.0));}vec3 F_Schlick(vec3 specularColor,float dotLH){float fresnel=exp2((-5.55473*dotLH-6.98316)*dotLH);return(1.0-specularColor)*fresnel+specularColor;}float G_GGX_SmithCorrelated(float alpha,float dotNL,float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(float alpha,float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_Specular_GGX(vec3 incidentDirection,vec3 viewDir,vec3 normal,vec3 specularColor,float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(incidentDirection+viewDir);float dotNL=saturate(dot(normal,incidentDirection));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotLH=saturate(dot(incidentDirection,halfDir));vec3 F=F_Schlick(specularColor,dotLH);float G=G_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(G*D);}vec3 BRDF_Diffuse_Lambert(vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}"; // eslint-disable-line

var direct_irradiance_frag_define = "#define GLSLIFY 1\n#include <ShadowFragmentDeclaration>\nvoid addDirectRadiance(vec3 incidentDirection,vec3 color,Geometry geometry,Material material,inout ReflectedLight reflectedLight){float attenuation=1.0;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nfloat clearCoatDotNL=saturate(dot(geometry.clearCoatNormal,incidentDirection));vec3 clearCoatIrradiance=clearCoatDotNL*color;reflectedLight.directSpecular+=material.clearCoat*clearCoatIrradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.clearCoatNormal,vec3(0.04),material.clearCoatRoughness);attenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nfloat dotNL=saturate(dot(geometry.normal,incidentDirection));vec3 irradiance=dotNL*color*PI;reflectedLight.directSpecular+=attenuation*irradiance*BRDF_Specular_GGX(incidentDirection,geometry.viewDir,geometry.normal,material.specularColor,material.roughness);reflectedLight.directDiffuse+=attenuation*irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);}\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nvoid addDirectionalDirectLightRadiance(DirectLight directionalLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 color=directionalLight.color;vec3 direction=-directionalLight.direction;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nvoid addPointDirectLightRadiance(PointLight pointLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=pointLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);vec3 color=pointLight.color;color*=clamp(1.0-pow(lightDistance/pointLight.distance,4.0),0.0,1.0);addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nvoid addSpotDirectLightRadiance(SpotLight spotLight,Geometry geometry,Material material,inout ReflectedLight reflectedLight){vec3 lVector=spotLight.position-geometry.position;vec3 direction=normalize(lVector);float lightDistance=length(lVector);float angleCos=dot(direction,-spotLight.direction);float spotEffect=smoothstep(spotLight.penumbraCos,spotLight.angleCos,angleCos);float decayEffect=clamp(1.0-pow(lightDistance/spotLight.distance,4.0),0.0,1.0);vec3 color=spotLight.color;color*=spotEffect*decayEffect;addDirectRadiance(direction,color,geometry,material,reflectedLight);}\n#endif\nvoid addTotalDirectRadiance(Geometry geometry,Material material,inout ReflectedLight reflectedLight){float shadowAttenuation=1.0;\n#ifdef SCENE_DIRECT_LIGHT_COUNT\nshadowAttenuation=1.0;\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nshadowAttenuation*=sampleShadowMap();int sunIndex=int(scene_ShadowInfo.z);\n#endif\nDirectLight directionalLight;for(int i=0;i<SCENE_DIRECT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_DirectLightCullingMask[i]))continue;directionalLight.color=scene_DirectLightColor[i];\n#ifdef SCENE_IS_CALCULATE_SHADOWS\nif(i==sunIndex){directionalLight.color*=shadowAttenuation;}\n#endif\ndirectionalLight.direction=scene_DirectLightDirection[i];addDirectionalDirectLightRadiance(directionalLight,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_POINT_LIGHT_COUNT\nPointLight pointLight;for(int i=0;i<SCENE_POINT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_PointLightCullingMask[i]))continue;pointLight.color=scene_PointLightColor[i];pointLight.position=scene_PointLightPosition[i];pointLight.distance=scene_PointLightDistance[i];addPointDirectLightRadiance(pointLight,geometry,material,reflectedLight);}\n#endif\n#ifdef SCENE_SPOT_LIGHT_COUNT\nSpotLight spotLight;for(int i=0;i<SCENE_SPOT_LIGHT_COUNT;i++){if(isRendererCulledByLight(renderer_Layer.xy,scene_SpotLightCullingMask[i]))continue;spotLight.color=scene_SpotLightColor[i];spotLight.position=scene_SpotLightPosition[i];spotLight.direction=scene_SpotLightDirection[i];spotLight.distance=scene_SpotLightDistance[i];spotLight.angleCos=scene_SpotLightAngleCos[i];spotLight.penumbraCos=scene_SpotLightPenumbraCos[i];addSpotDirectLightRadiance(spotLight,geometry,material,reflectedLight);}\n#endif\n}"; // eslint-disable-line

var ibl_frag_define = "#define GLSLIFY 1\nvec3 getLightProbeIrradiance(vec3 sh[9],vec3 normal){normal.x=-normal.x;vec3 result=sh[0]+sh[1]*(normal.y)+sh[2]*(normal.z)+sh[3]*(normal.x)+sh[4]*(normal.y*normal.x)+sh[5]*(normal.y*normal.z)+sh[6]*(3.0*normal.z*normal.z-1.0)+sh[7]*(normal.z*normal.x)+sh[8]*(normal.x*normal.x-normal.y*normal.y);return max(result,vec3(0.0));}vec3 envBRDFApprox(vec3 specularColor,float roughness,float dotNV){const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}float getSpecularMIPLevel(float roughness,int maxMIPLevel){return roughness*float(maxMIPLevel);}vec3 getLightProbeRadiance(vec3 viewDir,vec3 normal,float roughness,int maxMIPLevel,float specularIntensity){\n#ifndef SCENE_USE_SPECULAR_ENV\nreturn vec3(0);\n#else\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec.x=-reflectVec.x;float specularMIPLevel=getSpecularMIPLevel(roughness,maxMIPLevel);\n#ifdef HAS_TEX_LOD\nvec4 envMapColor=textureCubeLodEXT(scene_EnvSpecularSampler,reflectVec,specularMIPLevel);\n#else\nvec4 envMapColor=textureCube(scene_EnvSpecularSampler,reflectVec,specularMIPLevel);\n#endif\n#ifdef SCENE_IS_DECODE_ENV_RGBM\nenvMapColor.rgb=RGBMToLinear(envMapColor,5.0).rgb;\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\nenvMapColor=linearToGamma(envMapColor);\n#endif\n#else\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nenvMapColor=gammaToLinear(envMapColor);\n#endif\n#endif\nreturn envMapColor.rgb*specularIntensity;\n#endif\n}"; // eslint-disable-line

var pbr_frag = "#define GLSLIFY 1\nGeometry geometry;Material material;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));initGeometry(geometry,gl_FrontFacing);initMaterial(material,geometry);addTotalDirectRadiance(geometry,material,reflectedLight);\n#ifdef SCENE_USE_SH\nvec3 irradiance=getLightProbeIrradiance(scene_EnvSH,geometry.normal);\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\nirradiance=linearToGamma(vec4(irradiance,1.0)).rgb;\n#endif\nirradiance*=scene_EnvMapLight.diffuseIntensity;\n#else\nvec3 irradiance=scene_EnvMapLight.diffuse*scene_EnvMapLight.diffuseIntensity;irradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=irradiance*BRDF_Diffuse_Lambert(material.diffuseColor);vec3 radiance=getLightProbeRadiance(geometry.viewDir,geometry.normal,material.roughness,int(scene_EnvMapLight.mipMapLevel),scene_EnvMapLight.specularIntensity);float radianceAttenuation=1.0;\n#ifdef MATERIAL_ENABLE_CLEAR_COAT\nvec3 clearCoatRadiance=getLightProbeRadiance(geometry.viewDir,geometry.clearCoatNormal,material.clearCoatRoughness,int(scene_EnvMapLight.mipMapLevel),scene_EnvMapLight.specularIntensity);reflectedLight.indirectSpecular+=clearCoatRadiance*material.clearCoat*envBRDFApprox(vec3(0.04),material.clearCoatRoughness,geometry.clearCoatDotNV);radianceAttenuation-=material.clearCoat*F_Schlick(geometry.clearCoatDotNV);\n#endif\nreflectedLight.indirectSpecular+=radianceAttenuation*radiance*envBRDFApprox(material.specularColor,material.roughness,geometry.dotNV);\n#ifdef MATERIAL_HAS_OCCLUSION_TEXTURE\nvec2 aoUV=v_uv;\n#ifdef RENDERER_HAS_UV1\nif(material_OcclusionTextureCoord==1.0){aoUV=v_uv1;}\n#endif\nfloat ambientOcclusion=(texture2D(material_OcclusionTexture,aoUV).r-1.0)*material_OcclusionIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#ifdef SCENE_USE_SPECULAR_ENV\nreflectedLight.indirectSpecular*=computeSpecularOcclusion(ambientOcclusion,material.roughness,geometry.dotNV);\n#endif\n#endif\nvec3 emissiveRadiance=material_EmissiveColor;\n#ifdef MATERIAL_HAS_EMISSIVETEXTURE\nvec4 emissiveColor=texture2D(material_EmissiveTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\nemissiveColor=gammaToLinear(emissiveColor);\n#endif\nemissiveRadiance*=emissiveColor.rgb;\n#endif\nvec3 totalRadiance=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+emissiveRadiance;vec4 targetColor=vec4(totalRadiance,material.opacity);gl_FragColor=targetColor;"; // eslint-disable-line

var PBRShaderLib = {
    pbr_frag_define: pbr_frag_define,
    pbr_helper: pbr_helper,
    brdf: brdf,
    direct_irradiance_frag_define: direct_irradiance_frag_define,
    ibl_frag_define: ibl_frag_define,
    pbr_frag: pbr_frag
};

var ShadowCoord = "#define GLSLIFY 1\nuniform mat4 scene_ShadowMatrices[SCENE_SHADOW_CASCADED_COUNT+1];uniform vec4 scene_ShadowSplitSpheres[4];mediump int computeCascadeIndex(vec3 positionWS){vec3 fromCenter0=positionWS-scene_ShadowSplitSpheres[0].xyz;vec3 fromCenter1=positionWS-scene_ShadowSplitSpheres[1].xyz;vec3 fromCenter2=positionWS-scene_ShadowSplitSpheres[2].xyz;vec3 fromCenter3=positionWS-scene_ShadowSplitSpheres[3].xyz;mediump vec4 comparison=vec4(dot(fromCenter0,fromCenter0)<scene_ShadowSplitSpheres[0].w,dot(fromCenter1,fromCenter1)<scene_ShadowSplitSpheres[1].w,dot(fromCenter2,fromCenter2)<scene_ShadowSplitSpheres[2].w,dot(fromCenter3,fromCenter3)<scene_ShadowSplitSpheres[3].w);comparison.yzw=clamp(comparison.yzw-comparison.xyz,0.0,1.0);mediump vec4 indexCoefficient=vec4(4.0,3.0,2.0,1.0);mediump int index=4-int(dot(comparison,indexCoefficient));return index;}vec3 getShadowCoord(){\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nmediump int cascadeIndex=0;\n#else\nmediump int cascadeIndex=computeCascadeIndex(v_pos);\n#endif\n#ifdef GRAPHICS_API_WEBGL2\nmat4 shadowMatrix=scene_ShadowMatrices[cascadeIndex];\n#else\nmat4 shadowMatrix;\n#if SCENE_SHADOW_CASCADED_COUNT == 4\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else if(cascadeIndex==1){shadowMatrix=scene_ShadowMatrices[1];}else if(cascadeIndex==2){shadowMatrix=scene_ShadowMatrices[2];}else if(cascadeIndex==3){shadowMatrix=scene_ShadowMatrices[3];}else{shadowMatrix=scene_ShadowMatrices[4];}\n#endif\n#if SCENE_SHADOW_CASCADED_COUNT == 2\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else if(cascadeIndex==1){shadowMatrix=scene_ShadowMatrices[1];}else{shadowMatrix=scene_ShadowMatrices[2];}\n#endif\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nif(cascadeIndex==0){shadowMatrix=scene_ShadowMatrices[0];}else{shadowMatrix=scene_ShadowMatrices[1];}\n#endif\n#endif\nvec4 shadowCoord=shadowMatrix*vec4(v_pos,1.0);return shadowCoord.xyz;}"; // eslint-disable-line

var ShadowFragmentDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n#define SCENE_IS_CALCULATE_SHADOWS\n#endif\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nvarying vec3 v_shadowCoord;\n#else\n#include <ShadowCoord>\n#endif\nuniform vec3 scene_ShadowInfo;uniform vec4 scene_ShadowMapSize;\n#ifdef GRAPHICS_API_WEBGL2\nuniform mediump sampler2DShadow scene_ShadowMap;\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3 , 0.0)\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n#else\nuniform sampler2D scene_ShadowMap;\n#ifdef ENGINE_NO_DEPTH_TEXTURE\nconst vec4 bitShift=vec4(1.0,1.0/256.0,1.0/(256.0*256.0),1.0/(256.0*256.0*256.0));float unpack(const in vec4 rgbaDepth){return dot(rgbaDepth,bitShift);}\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (unpack(texture2D(textureName, coord3.xy)) < coord3.z ? 0.0 : 1.0)\n#else\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName, coord3.xy).r < coord3.z ? 0.0 : 1.0)\n#endif\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n#endif\n#if SCENE_SHADOW_TYPE == 2\nfloat sampleShadowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize){float attenuation;vec4 attenuation4;vec2 offset=shadowMapSize.xy/2.0;vec3 shadowCoord0=shadowCoord+vec3(-offset,0.0);vec3 shadowCoord1=shadowCoord+vec3(offset.x,-offset.y,0.0);vec3 shadowCoord2=shadowCoord+vec3(-offset.x,offset.y,0.0);vec3 shadowCoord3=shadowCoord+vec3(offset,0.0);attenuation4.x=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord0);attenuation4.y=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord1);attenuation4.z=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord2);attenuation4.w=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord3);attenuation=dot(attenuation4,vec4(0.25));return attenuation;}\n#endif\n#if SCENE_SHADOW_TYPE == 3\n#include <shadow_sample_tent>\nfloat sampleShadowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize){float attenuation;float fetchesWeights[9];vec2 fetchesUV[9];sampleShadowComputeSamplesTent5x5(shadowmapSize,shadowCoord.xy,fetchesWeights,fetchesUV);attenuation=fetchesWeights[0]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[0].xy,shadowCoord.z));attenuation+=fetchesWeights[1]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[1].xy,shadowCoord.z));attenuation+=fetchesWeights[2]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[2].xy,shadowCoord.z));attenuation+=fetchesWeights[3]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[3].xy,shadowCoord.z));attenuation+=fetchesWeights[4]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[4].xy,shadowCoord.z));attenuation+=fetchesWeights[5]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[5].xy,shadowCoord.z));attenuation+=fetchesWeights[6]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[6].xy,shadowCoord.z));attenuation+=fetchesWeights[7]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[7].xy,shadowCoord.z));attenuation+=fetchesWeights[8]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[8].xy,shadowCoord.z));return attenuation;}\n#endif\nfloat sampleShadowMap(){\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nvec3 shadowCoord=v_shadowCoord;\n#else\nvec3 shadowCoord=getShadowCoord();\n#endif\nfloat attenuation=1.0;if(shadowCoord.z>0.0&&shadowCoord.z<1.0){\n#if SCENE_SHADOW_TYPE == 1\nattenuation=SAMPLE_TEXTURE2D_SHADOW(scene_ShadowMap,shadowCoord);\n#endif\n#if SCENE_SHADOW_TYPE == 2\nattenuation=sampleShadowMapFiltered4(scene_ShadowMap,shadowCoord,scene_ShadowMapSize);\n#endif\n#if SCENE_SHADOW_TYPE == 3\nattenuation=sampleShadowMapFiltered9(scene_ShadowMap,shadowCoord,scene_ShadowMapSize);\n#endif\nattenuation=mix(1.0,attenuation,scene_ShadowInfo.x);}return attenuation;}\n#endif\n"; // eslint-disable-line

var shadow_sample_tent = "#define GLSLIFY 1\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight){return triangleHeight-0.5;}void sampleShadowGetTexelAreasTent3x3(float offset,out vec4 computedArea,out vec4 computedAreaUncut){float a=offset+0.5;float offsetSquaredHalved=a*a*0.5;computedAreaUncut.x=computedArea.x=offsetSquaredHalved-offset;computedAreaUncut.w=computedArea.w=offsetSquaredHalved;computedAreaUncut.y=sampleShadowGetIRTriangleTexelArea(1.5-offset);float clampedOffsetLeft=min(offset,0.0);float areaOfSmallLeftTriangle=clampedOffsetLeft*clampedOffsetLeft;computedArea.y=computedAreaUncut.y-areaOfSmallLeftTriangle;computedAreaUncut.z=sampleShadowGetIRTriangleTexelArea(1.5+offset);float clampedOffsetRight=max(offset,0.0);float areaOfSmallRightTriangle=clampedOffsetRight*clampedOffsetRight;computedArea.z=computedAreaUncut.z-areaOfSmallRightTriangle;}void sampleShadowGetTexelWeightsTent5x5(float offset,out vec3 texelsWeightsA,out vec3 texelsWeightsB){vec4 areaFrom3texelTriangle;vec4 areaUncutFrom3texelTriangle;sampleShadowGetTexelAreasTent3x3(offset,areaFrom3texelTriangle,areaUncutFrom3texelTriangle);texelsWeightsA.x=0.16*(areaFrom3texelTriangle.x);texelsWeightsA.y=0.16*(areaUncutFrom3texelTriangle.y);texelsWeightsA.z=0.16*(areaFrom3texelTriangle.y+1.0);texelsWeightsB.x=0.16*(areaFrom3texelTriangle.z+1.0);texelsWeightsB.y=0.16*(areaUncutFrom3texelTriangle.z);texelsWeightsB.z=0.16*(areaFrom3texelTriangle.w);}void sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize,vec2 coord,out float fetchesWeights[9],out vec2 fetchesUV[9]){vec2 tentCenterInTexelSpace=coord.xy*shadowMapTextureTexelSize.zw;vec2 centerOfFetchesInTexelSpace=floor(tentCenterInTexelSpace+0.5);vec2 offsetFromTentCenterToCenterOfFetches=tentCenterInTexelSpace-centerOfFetchesInTexelSpace;vec3 texelsWeightsUA,texelsWeightsUB;vec3 texelsWeightsVA,texelsWeightsVB;sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x,texelsWeightsUA,texelsWeightsUB);sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y,texelsWeightsVA,texelsWeightsVB);vec3 fetchesWeightsU=vec3(texelsWeightsUA.xz,texelsWeightsUB.y)+vec3(texelsWeightsUA.y,texelsWeightsUB.xz);vec3 fetchesWeightsV=vec3(texelsWeightsVA.xz,texelsWeightsVB.y)+vec3(texelsWeightsVA.y,texelsWeightsVB.xz);vec3 fetchesOffsetsU=vec3(texelsWeightsUA.y,texelsWeightsUB.xz)/fetchesWeightsU.xyz+vec3(-2.5,-0.5,1.5);vec3 fetchesOffsetsV=vec3(texelsWeightsVA.y,texelsWeightsVB.xz)/fetchesWeightsV.xyz+vec3(-2.5,-0.5,1.5);fetchesOffsetsU*=shadowMapTextureTexelSize.xxx;fetchesOffsetsV*=shadowMapTextureTexelSize.yyy;vec2 bilinearFetchOrigin=centerOfFetchesInTexelSpace*shadowMapTextureTexelSize.xy;fetchesUV[0]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.x);fetchesUV[1]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.x);fetchesUV[2]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.x);fetchesUV[3]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.y);fetchesUV[4]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.y);fetchesUV[5]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.y);fetchesUV[6]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.z);fetchesUV[7]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.z);fetchesUV[8]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.z);fetchesWeights[0]=fetchesWeightsU.x*fetchesWeightsV.x;fetchesWeights[1]=fetchesWeightsU.y*fetchesWeightsV.x;fetchesWeights[2]=fetchesWeightsU.z*fetchesWeightsV.x;fetchesWeights[3]=fetchesWeightsU.x*fetchesWeightsV.y;fetchesWeights[4]=fetchesWeightsU.y*fetchesWeightsV.y;fetchesWeights[5]=fetchesWeightsU.z*fetchesWeightsV.y;fetchesWeights[6]=fetchesWeightsU.x*fetchesWeightsV.z;fetchesWeights[7]=fetchesWeightsU.y*fetchesWeightsV.z;fetchesWeights[8]=fetchesWeightsU.z*fetchesWeightsV.z;}"; // eslint-disable-line

var ShadowVertexDeclaration = "#define GLSLIFY 1\n#if defined(SCENE_SHADOW_TYPE) && defined(RENDERER_IS_RECEIVE_SHADOWS)\n#define SCENE_IS_CALCULATE_SHADOWS\n#endif\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT==1\n#include <ShadowCoord>\nvarying vec3 v_shadowCoord;\n#endif\n#endif\n"; // eslint-disable-line

var ShadowVertex = "#define GLSLIFY 1\n#ifdef SCENE_IS_CALCULATE_SHADOWS\n#if SCENE_SHADOW_CASCADED_COUNT == 1\nv_shadowCoord=getShadowCoord();\n#endif\n#endif\n"; // eslint-disable-line

var ShadowLib = {
    ShadowCoord: ShadowCoord,
    ShadowFragmentDeclaration: ShadowFragmentDeclaration,
    shadow_sample_tent: shadow_sample_tent,
    ShadowVertexDeclaration: ShadowVertexDeclaration,
    ShadowVertex: ShadowVertex
};

var normal_get = "#define GLSLIFY 1\nvec3 getNormal(bool isFrontFacing){\n#ifdef RENDERER_HAS_NORMAL\nvec3 normal=normalize(v_normal);\n#elif defined(HAS_DERIVATIVES)\nvec3 pos_dx=dFdx(v_pos);vec3 pos_dy=dFdy(v_pos);vec3 normal=normalize(cross(pos_dx,pos_dy));\n#else\nvec3 normal=vec3(0,0,1);\n#endif\nnormal*=float(isFrontFacing)*2.0-1.0;return normal;}vec3 getNormalByNormalTexture(mat3 tbn,sampler2D normalTexture,float normalIntensity,vec2 uv,bool isFrontFacing){vec3 normal=texture2D(normalTexture,uv).rgb;normal=normalize(tbn*((2.0*normal-1.0)*vec3(normalIntensity,normalIntensity,1.0)));normal*=float(isFrontFacing)*2.0-1.0;return normal;}mat3 getTBN(bool isFrontFacing){\n#if defined(RENDERER_HAS_NORMAL) && defined(RENDERER_HAS_TANGENT) && ( defined(MATERIAL_HAS_NORMALTEXTURE) || defined(MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE) )\nmat3 tbn=v_TBN;\n#else\nvec3 normal=getNormal(isFrontFacing);vec3 position=v_pos;vec2 uv=isFrontFacing? v_uv:-v_uv;\n#ifdef HAS_DERIVATIVES\nvec3 dp1=dFdx(position);vec3 dp2=dFdy(position);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));mat3 tbn=mat3(tangent*invmax,binormal*invmax,normal);\n#else\nmat3 tbn=mat3(vec3(0.0),vec3(0.0),normal);\n#endif\n#endif\nreturn tbn;}"; // eslint-disable-line

var ShaderLib = _extends$2({
    common: common,
    common_vert: common_vert,
    transform_declare: transform_declare,
    camera_declare: camera_declare,
    color_share: color_share,
    normal_share: normal_share,
    uv_share: uv_share,
    worldpos_share: worldpos_share,
    FogVertexDeclaration: FogVertexDeclaration,
    FogFragmentDeclaration: FogFragmentDeclaration,
    begin_normal_vert: begin_normal_vert,
    begin_position_vert: begin_position_vert,
    position_vert: position_vert,
    color_vert: color_vert,
    normal_vert: normal_vert,
    skinning_vert: skinning_vert,
    blendShape_input: blendShape_input,
    blendShape_vert: blendShape_vert,
    uv_vert: uv_vert,
    worldpos_vert: worldpos_vert,
    FogVertex: FogVertex,
    light_frag_define: light_frag_define,
    mobile_material_frag: mobile_material_frag,
    FogFragment: FogFragment,
    begin_mobile_frag: begin_mobile_frag,
    begin_viewdir_frag: begin_viewdir_frag,
    mobile_blinnphong_frag: mobile_blinnphong_frag,
    noise_common: noise_common,
    noise_cellular_2D: noise_cellular_2D,
    noise_cellular_2x2: noise_cellular_2x2,
    noise_cellular_2x2x2: noise_cellular_2x2x2,
    noise_cellular_3D: noise_cellular_3D,
    noise_cellular: noise_cellular,
    noise_perlin_2D: noise_perlin_2D,
    noise_perlin_3D: noise_perlin_3D,
    noise_perlin_4D: noise_perlin_4D,
    noise_perlin: noise_perlin,
    noise_psrd_2D: noise_psrd_2D,
    noise_simplex_2D: noise_simplex_2D,
    noise_simplex_3D_grad: noise_simplex_3D_grad,
    noise_simplex_3D: noise_simplex_3D,
    noise_simplex_4D: noise_simplex_4D,
    noise_simplex: noise_simplex
}, ShadowLib, PBRShaderLib, {
    normal_get: normal_get
});

var ShaderFactory = /*#__PURE__*/ function() {
    function ShaderFactory() {}
    ShaderFactory.parseCustomMacros = function parseCustomMacros(macros) {
        return macros.map(function(m) {
            return "#define " + m + "\n";
        }).join("");
    };
    ShaderFactory.parseIncludes = function parseIncludes(src) {
        var replace = function replace(match, slice) {
            var replace = ShaderLib[slice];
            if (replace === undefined) {
                Logger.error('Shader slice "' + match.trim() + '" not founded.');
                return "";
            }
            return ShaderFactory.parseIncludes(replace);
        };
        var regex = /^[ \t]*#include +<([\w\d.]+)>/gm;
        return src.replace(regex, replace);
    };
    /**
   * GLSL extension.
   * @param extensions - such as ["GL_EXT_shader_texture_lod"]
   * */ ShaderFactory.parseExtension = function parseExtension(extensions) {
        return extensions.map(function(e) {
            return "#extension " + e + " : enable\n";
        }).join("");
    };
    /**
   * Convert lower GLSL version to GLSL 300 es.
   * @param shader - code
   * @param isFrag - Whether it is a fragment shader.
   * */ ShaderFactory.convertTo300 = function convertTo300(shader, isFrag) {
        /** replace attribute and in */ shader = shader.replace(/\battribute\b/g, "in");
        shader = shader.replace(/\bvarying\b/g, isFrag ? "in" : "out");
        /** replace api */ shader = shader.replace(/\btexture(2D|Cube)\b/g, "texture");
        shader = shader.replace(/\btexture(2D|Cube)LodEXT\b/g, "textureLod");
        if (isFrag) {
            var isMRT = /\bgl_FragData\[.+?\]/g.test(shader);
            if (isMRT) {
                shader = shader.replace(/\bgl_FragColor\b/g, "gl_FragData[0]");
                var result = shader.match(/\bgl_FragData\[.+?\]/g);
                shader = this._replaceMRTShader(shader, result);
            } else {
                shader = shader.replace(/void\s+?main\s*\(/g, "out vec4 glFragColor;\nvoid main(");
                shader = shader.replace(/\bgl_FragColor\b/g, "glFragColor");
            }
        }
        return shader;
    };
    ShaderFactory._replaceMRTShader = function _replaceMRTShader(shader, result) {
        var declaration = "";
        var mrtIndexSet = new Set();
        for(var i = 0; i < result.length; i++){
            var res = result[i].match(/\bgl_FragData\[(.+?)\]/);
            mrtIndexSet.add(res[1]);
        }
        mrtIndexSet.forEach(function(index) {
            declaration += "layout(location=" + index + ") out vec4 fragOutColor" + index + ";\n";
        });
        declaration += "void main(";
        shader = shader.replace(/\bgl_FragData\[(.+?)\]/g, "fragOutColor$1");
        shader = shader.replace(/void\s+?main\s*\(/g, declaration);
        return shader;
    };
    return ShaderFactory;
}();

/**
 * Shader tag key.
 */ var ShaderTagKey = /*#__PURE__*/ function() {
    function ShaderTagKey(name) {
        this.name = name;
        this._uniqueId = ShaderTagKey._nameCounter++;
    }
    /**
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ ShaderTagKey.getByName = function getByName(name) {
        var _nameMap, _name;
        var nameMap = ShaderTagKey._nameMap;
        return (_nameMap = nameMap)[_name = name] || (_nameMap[_name] = new ShaderTagKey(name));
    };
    return ShaderTagKey;
}();
(function() {
    ShaderTagKey._nameCounter = 0;
})();
(function() {
    ShaderTagKey._nameMap = Object.create(null);
})();

/**
 * Base class for shader structure.
 */ var ShaderPart = /*#__PURE__*/ function() {
    function ShaderPart() {
        this._tagsMap = Object.create(null);
    }
    var _proto = ShaderPart.prototype;
    _proto.setTag = function setTag(keyOrKeyName, value) {
        var key = typeof keyOrKeyName === "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName;
        var tags = this._tagsMap;
        if (tags[key._uniqueId] !== undefined) {
            Logger.warn('The value of tag named "' + key.name + '" is being replaced.');
        }
        tags[key._uniqueId] = value;
    };
    _proto.deleteTag = function deleteTag(keyOrKeyName) {
        delete this._tagsMap[(typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName) : keyOrKeyName)._uniqueId];
    };
    _proto.getTagValue = function getTagValue(keyOrKeyName) {
        return this._tagsMap[typeof keyOrKeyName == "string" ? ShaderTagKey.getByName(keyOrKeyName)._uniqueId : keyOrKeyName._uniqueId];
    };
    return ShaderPart;
}();

/**
 * Shader uniformã€‚
 * @internal
 */ var ShaderUniform = /*#__PURE__*/ function() {
    function ShaderUniform(engine) {
        this.textureUseCompareMode = false;
        var rhi = engine._hardwareRenderer;
        this._rhi = rhi;
        this._gl = rhi.gl;
        this._colorSpace = engine.settings.colorSpace;
    }
    var _proto = ShaderUniform.prototype;
    _proto.upload1f = function upload1f(shaderUniform, value) {
        if (this.cacheValue !== value) {
            this._gl.uniform1f(shaderUniform.location, value);
            this.cacheValue = value;
        }
    };
    _proto.upload1fv = function upload1fv(shaderUniform, value) {
        this._gl.uniform1fv(shaderUniform.location, value);
    };
    _proto.upload2f = function upload2f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
                if (this._colorSpace === ColorSpace.Linear) {
                    this._gl.uniform2f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g));
                } else {
                    this._gl.uniform2f(shaderUniform.location, value.r, value.g);
                }
                cacheValue.x = value.r;
                cacheValue.y = value.g;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
                this._gl.uniform2f(shaderUniform.location, value.x, value.y);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
            }
        }
    };
    _proto.upload2fv = function upload2fv(shaderUniform, value) {
        this._gl.uniform2fv(shaderUniform.location, value);
    };
    _proto.upload3f = function upload3f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
                if (this._colorSpace === ColorSpace.Linear) {
                    this._gl.uniform3f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g), Color$1.gammaToLinearSpace(value.b));
                } else {
                    this._gl.uniform3f(shaderUniform.location, value.r, value.g, value.b);
                }
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
                this._gl.uniform3f(shaderUniform.location, value.x, value.y, value.z);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
            }
        }
    };
    _proto.upload3fv = function upload3fv(shaderUniform, value) {
        this._gl.uniform3fv(shaderUniform.location, value);
    };
    _proto.upload4f = function upload4f(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
                if (this._colorSpace === ColorSpace.Linear) {
                    this._gl.uniform4f(shaderUniform.location, Color$1.gammaToLinearSpace(value.r), Color$1.gammaToLinearSpace(value.g), Color$1.gammaToLinearSpace(value.b), value.a);
                } else {
                    this._gl.uniform4f(shaderUniform.location, value.r, value.g, value.b, value.a);
                }
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
                cacheValue.w = value.a;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
                this._gl.uniform4f(shaderUniform.location, value.x, value.y, value.z, value.w);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
                cacheValue.w = value.w;
            }
        }
    };
    _proto.upload4fv = function upload4fv(shaderUniform, value) {
        this._gl.uniform4fv(shaderUniform.location, value);
    };
    _proto.upload1i = function upload1i(shaderUniform, value) {
        if (this.cacheValue !== value) {
            this._gl.uniform1i(shaderUniform.location, value);
            this.cacheValue = value;
        }
    };
    _proto.upload1iv = function upload1iv(shaderUniform, value) {
        this._gl.uniform1iv(shaderUniform.location, value);
    };
    _proto.upload2i = function upload2i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g) {
                this._gl.uniform2i(shaderUniform.location, value.r, value.g);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y) {
                this._gl.uniform2i(shaderUniform.location, value.x, value.y);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
            }
        }
    };
    _proto.upload2iv = function upload2iv(shaderUniform, value) {
        this._gl.uniform2iv(shaderUniform.location, value);
    };
    _proto.upload3i = function upload3i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b) {
                this._gl.uniform3i(shaderUniform.location, value.r, value.g, value.b);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z) {
                this._gl.uniform3i(shaderUniform.location, value.x, value.y, value.z);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
            }
        }
    };
    _proto.upload3iv = function upload3iv(shaderUniform, value) {
        this._gl.uniform3iv(shaderUniform.location, value);
    };
    _proto.upload4i = function upload4i(shaderUniform, value) {
        var cacheValue = this.cacheValue;
        if (value.r !== undefined) {
            if (cacheValue.x !== value.r || cacheValue.y !== value.g || cacheValue.z !== value.b || cacheValue.w !== value.a) {
                this._gl.uniform4i(shaderUniform.location, value.r, value.g, value.b, value.a);
                cacheValue.x = value.r;
                cacheValue.y = value.g;
                cacheValue.z = value.b;
                cacheValue.w = value.a;
            }
        } else {
            if (cacheValue.x !== value.x || cacheValue.y !== value.y || cacheValue.z !== value.z || cacheValue.w !== value.w) {
                this._gl.uniform4i(shaderUniform.location, value.x, value.y, value.z, value.w);
                cacheValue.x = value.x;
                cacheValue.y = value.y;
                cacheValue.z = value.z;
                cacheValue.w = value.w;
            }
        }
    };
    _proto.upload4iv = function upload4iv(shaderUniform, value) {
        this._gl.uniform4iv(shaderUniform.location, value);
    };
    _proto.uploadMat4 = function uploadMat4(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value.elements);
    };
    _proto.uploadMat4v = function uploadMat4v(shaderUniform, value) {
        this._gl.uniformMatrix4fv(shaderUniform.location, false, value);
    };
    _proto.uploadTexture = function uploadTexture(shaderUniform, value) {
        var rhi = this._rhi;
        rhi.activeTexture(shaderUniform.textureIndex);
        rhi.bindTexture(value._platformTexture);
        value._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
    };
    _proto.uploadTextureArray = function uploadTextureArray(shaderUniform, value) {
        var rhi = this._rhi;
        var textureIndices = shaderUniform.textureIndex;
        for(var i = 0; i < value.length; i++){
            var texture = value[i];
            rhi.activeTexture(textureIndices[i]);
            rhi.bindTexture(texture._platformTexture);
            texture._setUseDepthCompareMode(shaderUniform.textureUseCompareMode);
        }
    };
    return ShaderUniform;
}();

/**
 * Shader uniform block.
 * @internal
 */ var ShaderUniformBlock = function ShaderUniformBlock() {
    this.constUniforms = [];
    this.textureUniforms = [];
};

/**
 * Shader program, corresponding to the GPU shader program.
 * @internal
 */ var ShaderProgram = /*#__PURE__*/ function() {
    function ShaderProgram(engine, vertexSource, fragmentSource) {
        this.sceneUniformBlock = new ShaderUniformBlock();
        this.cameraUniformBlock = new ShaderUniformBlock();
        this.rendererUniformBlock = new ShaderUniformBlock();
        this.materialUniformBlock = new ShaderUniformBlock();
        this.otherUniformBlock = new ShaderUniformBlock();
        /** @internal */ this._uploadRenderCount = -1;
        this.attributeLocation = Object.create(null);
        this._activeTextureUint = 0;
        this._engine = engine;
        this._gl = engine._hardwareRenderer.gl;
        this._glProgram = this._createProgram(vertexSource, fragmentSource);
        if (this._glProgram) {
            this._isValid = true;
            this._recordLocation();
        } else {
            this._isValid = false;
        }
        this.id = ShaderProgram._counter++;
    }
    var _proto = ShaderProgram.prototype;
    /**
   * Upload all shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadAll = function uploadAll(uniformBlock, shaderData) {
        this.uploadUniforms(uniformBlock, shaderData);
        this.uploadTextures(uniformBlock, shaderData);
    };
    /**
   * Upload constant shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadUniforms = function uploadUniforms(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var constUniforms = uniformBlock.constUniforms;
        for(var i = 0, n = constUniforms.length; i < n; i++){
            var uniform = constUniforms[i];
            var data = propertyValueMap[uniform.propertyId];
            data != null && uniform.applyFunc(uniform, data);
        }
    };
    /**
   * Upload texture shader data in shader uniform block.
   * @param uniformBlock - shader Uniform block
   * @param shaderData - shader data
   */ _proto.uploadTextures = function uploadTextures(uniformBlock, shaderData) {
        var propertyValueMap = shaderData._propertyValueMap;
        var textureUniforms = uniformBlock.textureUniforms;
        // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
        if (textureUniforms) {
            for(var i = 0, n = textureUniforms.length; i < n; i++){
                var uniform = textureUniforms[i];
                var texture = propertyValueMap[uniform.propertyId];
                if (texture && !texture.destroyed) {
                    uniform.applyFunc(uniform, texture);
                } else {
                    uniform.applyFunc(uniform, uniform.textureDefault);
                }
            }
        }
    };
    /**
   * Upload ungroup texture shader data in shader uniform block.
   */ _proto.uploadUnGroupTextures = function uploadUnGroupTextures() {
        var textureUniforms = this.otherUniformBlock.textureUniforms;
        // textureUniforms property maybe null if ShaderUniformBlock not contain any texture.
        if (textureUniforms) {
            for(var i = 0, n = textureUniforms.length; i < n; i++){
                var uniform = textureUniforms[i];
                uniform.applyFunc(uniform, uniform.textureDefault);
            }
        }
    };
    /**
   * Grouping other data.
   */ _proto.groupingOtherUniformBlock = function groupingOtherUniformBlock() {
        var _this_otherUniformBlock = this.otherUniformBlock, constUniforms = _this_otherUniformBlock.constUniforms, textureUniforms = _this_otherUniformBlock.textureUniforms;
        constUniforms.length > 0 && this._groupingSubOtherUniforms(constUniforms, false);
        textureUniforms.length > 0 && this._groupingSubOtherUniforms(textureUniforms, true);
    };
    /**
   * Bind this shader program.
   * @returns Whether the shader program is switched.
   */ _proto.bind = function bind() {
        var rhi = this._engine._hardwareRenderer;
        if (rhi._currentBindShaderProgram !== this) {
            this._gl.useProgram(this._glProgram);
            rhi._currentBindShaderProgram = this;
            return true;
        } else {
            return false;
        }
    };
    /**
   * Destroy this shader program.
   */ _proto.destroy = function destroy() {
        var gl = this._gl;
        this._glProgram && gl.deleteProgram(this._glProgram);
    };
    _proto._groupingSubOtherUniforms = function _groupingSubOtherUniforms(uniforms, isTexture) {
        for(var i = uniforms.length - 1; i >= 0; i--){
            var uniform = uniforms[i];
            var group = ShaderProperty._getShaderPropertyGroup(uniform.name);
            if (group !== undefined) {
                uniforms.splice(uniforms.indexOf(uniform), 1);
                this._groupingUniform(uniform, group, isTexture);
            }
        }
    };
    _proto._groupingUniform = function _groupingUniform(uniform, group, isTexture) {
        switch(group){
            case ShaderDataGroup.Scene:
                if (isTexture) {
                    this.sceneUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.sceneUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Camera:
                if (isTexture) {
                    this.cameraUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.cameraUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Renderer:
                if (isTexture) {
                    this.rendererUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.rendererUniformBlock.constUniforms.push(uniform);
                }
                break;
            case ShaderDataGroup.Material:
                if (isTexture) {
                    this.materialUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.materialUniformBlock.constUniforms.push(uniform);
                }
                break;
            default:
                if (isTexture) {
                    this.otherUniformBlock.textureUniforms.push(uniform);
                } else {
                    this.otherUniformBlock.constUniforms.push(uniform);
                }
        }
    };
    /**
   * Init and link program with shader.
   */ _proto._createProgram = function _createProgram(vertexSource, fragmentSource) {
        var gl = this._gl;
        // Create and compile shader
        var vertexShader = this._createShader(gl.VERTEX_SHADER, vertexSource);
        if (!vertexShader) {
            return null;
        }
        var fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentSource);
        if (!fragmentShader) {
            return null;
        }
        // Create program and link shader
        var program = gl.createProgram();
        if (!program) {
            console.warn("Context lost while create program.");
            return null;
        }
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.validateProgram(program);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (Logger.isEnabled && !gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
            Logger.error("Could not link WebGL program\n\n" + ("Shader error: " + gl.getError() + "\n\n") + ("Validate status: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\n") + ("Program information log: " + gl.getProgramInfoLog(program)));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    };
    _proto._createShader = function _createShader(shaderType, shaderSource) {
        var gl = this._gl;
        var shader = gl.createShader(shaderType);
        if (!shader) {
            console.warn("Context lost while create shader.");
            return null;
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (Logger.isEnabled && !gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
            console.warn("Could not compile WebGL shader\n\n" + ("Shader type: " + (shaderType == gl.VERTEX_SHADER ? "vertex" : "fragment") + "\n\n") + ("Shader information log:\n" + gl.getShaderInfoLog(shader) + "\n") + ("Shader source:\n" + ShaderProgram._addLineNum(shaderSource)));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    };
    /**
   * record the location of uniform/attribute.
   */ _proto._recordLocation = function _recordLocation() {
        var _this = this;
        var gl = this._gl;
        var program = this._glProgram;
        var uniformInfos = this._getUniformInfos();
        var attributeInfos = this._getAttributeInfos();
        uniformInfos.forEach(function(param) {
            var name = param.name, size = param.size, type = param.type;
            var shaderUniform = new ShaderUniform(_this._engine);
            var isArray = false;
            var isTexture = false;
            if (name.indexOf("[0]") > 0) {
                name = name.substr(0, name.length - 3);
                isArray = true;
            }
            var location = gl.getUniformLocation(program, name);
            shaderUniform.name = name;
            shaderUniform.propertyId = ShaderProperty.getByName(name)._uniqueId;
            shaderUniform.location = location;
            switch(type){
                case gl.FLOAT:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload1fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload1f;
                        shaderUniform.cacheValue = 0;
                    }
                    break;
                case gl.FLOAT_VEC2:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload2fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload2f;
                        shaderUniform.cacheValue = new Vector2(0, 0);
                    }
                    break;
                case gl.FLOAT_VEC3:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload3fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload3f;
                        shaderUniform.cacheValue = new Vector3(0, 0, 0);
                    }
                    break;
                case gl.FLOAT_VEC4:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload4fv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload4f;
                        shaderUniform.cacheValue = new Vector4(0, 0, 0, 0);
                    }
                    break;
                case gl.BOOL:
                case gl.INT:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload1iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload1i;
                        shaderUniform.cacheValue = 0;
                    }
                    break;
                case gl.BOOL_VEC2:
                case gl.INT_VEC2:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload2iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload2i;
                        shaderUniform.cacheValue = new Vector2(0, 0);
                    }
                    break;
                case gl.BOOL_VEC3:
                case gl.INT_VEC3:
                    shaderUniform.applyFunc = isArray ? shaderUniform.upload3iv : shaderUniform.upload3i;
                    shaderUniform.cacheValue = new Vector3(0, 0, 0);
                    break;
                case gl.BOOL_VEC4:
                case gl.INT_VEC4:
                    if (isArray) {
                        shaderUniform.applyFunc = shaderUniform.upload4iv;
                    } else {
                        shaderUniform.applyFunc = shaderUniform.upload4i;
                        shaderUniform.cacheValue = new Vector4(0, 0, 0);
                    }
                    break;
                case gl.FLOAT_MAT4:
                    shaderUniform.applyFunc = isArray ? shaderUniform.uploadMat4v : shaderUniform.uploadMat4;
                    break;
                case gl.SAMPLER_2D:
                case gl.SAMPLER_CUBE:
                case gl.SAMPLER_2D_ARRAY:
                case gl.SAMPLER_2D_SHADOW:
                    var defaultTexture;
                    switch(type){
                        case gl.SAMPLER_2D:
                            defaultTexture = _this._engine._magentaTexture2D;
                            break;
                        case gl.SAMPLER_CUBE:
                            defaultTexture = _this._engine._magentaTextureCube;
                            break;
                        case gl.SAMPLER_2D_ARRAY:
                            defaultTexture = _this._engine._magentaTexture2DArray;
                            break;
                        case gl.SAMPLER_2D_SHADOW:
                            defaultTexture = _this._engine._depthTexture2D;
                            shaderUniform.textureUseCompareMode = true;
                            break;
                    }
                    isTexture = true;
                    if (isArray) {
                        var defaultTextures = new Array(size);
                        var textureIndices = new Int32Array(size);
                        var glTextureIndices = new Array(size);
                        for(var i = 0; i < size; i++){
                            defaultTextures[i] = defaultTexture;
                            textureIndices[i] = _this._activeTextureUint;
                            glTextureIndices[i] = gl.TEXTURE0 + _this._activeTextureUint++;
                        }
                        shaderUniform.textureDefault = defaultTextures;
                        shaderUniform.textureIndex = glTextureIndices;
                        shaderUniform.applyFunc = shaderUniform.uploadTextureArray;
                        _this.bind();
                        gl.uniform1iv(location, textureIndices);
                    } else {
                        var glTextureIndex = gl.TEXTURE0 + _this._activeTextureUint;
                        shaderUniform.textureDefault = defaultTexture;
                        shaderUniform.textureIndex = glTextureIndex;
                        shaderUniform.applyFunc = shaderUniform.uploadTexture;
                        _this.bind();
                        gl.uniform1i(location, _this._activeTextureUint++);
                    }
                    break;
                default:
                    throw new Error("Unsupported uniform type");
            }
            var group = ShaderProperty._getShaderPropertyGroup(name);
            _this._groupingUniform(shaderUniform, group, isTexture);
        });
        attributeInfos.forEach(function(param) {
            var name = param.name;
            _this.attributeLocation[name] = gl.getAttribLocation(program, name);
        });
    };
    _proto._getUniformInfos = function _getUniformInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        var uniformInfos = new Array(uniformCount);
        for(var i = 0; i < uniformCount; ++i){
            var info = gl.getActiveUniform(program, i);
            uniformInfos[i] = info;
        }
        return uniformInfos;
    };
    _proto._getAttributeInfos = function _getAttributeInfos() {
        var gl = this._gl;
        var program = this._glProgram;
        var attributeInfos = new Array();
        var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for(var i = 0; i < attributeCount; ++i){
            var info = gl.getActiveAttrib(program, i);
            attributeInfos[i] = info;
        }
        return attributeInfos;
    };
    ShaderProgram._addLineNum = function _addLineNum(str) {
        var lines = str.split("\n");
        var limitLength = (lines.length + 1).toString().length + 6;
        var prefix;
        return lines.map(function(line, index) {
            prefix = "0:" + (index + 1);
            if (prefix.length >= limitLength) return prefix.substring(0, limitLength) + line;
            for(var i = 0; i < limitLength - prefix.length; i++)prefix += " ";
            return prefix + line;
        }).join("\n");
    };
    _create_class$3(ShaderProgram, [
        {
            key: "isValid",
            get: /**
   * Whether this shader program is valid.
   */ function get() {
                return this._isValid;
            }
        }
    ]);
    return ShaderProgram;
}();
(function() {
    ShaderProgram._counter = 0;
})();

/**
 * Shader pass containing vertex and fragment source.
 */ var ShaderPass = /*#__PURE__*/ function(ShaderPart) {
    _inherits$2(ShaderPass, ShaderPart);
    function ShaderPass(vertexSource, fragmentSource, tags) {
        if (tags === void 0) tags = {
            pipelineStage: PipelineStage.Forward
        };
        var _this;
        _this = ShaderPart.call(this) || this;
        /** @internal */ _this._shaderPassId = 0;
        _this._shaderPassId = ShaderPass._shaderPassCounter++;
        _this._vertexSource = vertexSource;
        _this._fragmentSource = fragmentSource;
        for(var key in tags){
            _this.setTag(key, tags[key]);
        }
        return _this;
    }
    var _proto = ShaderPass.prototype;
    /**
   * @internal
   */ _proto._getShaderProgram = function _getShaderProgram(engine, macroCollection) {
        var shaderProgramPool = engine._getShaderProgramPool(this);
        var shaderProgram = shaderProgramPool.get(macroCollection);
        if (shaderProgram) {
            return shaderProgram;
        }
        var isWebGL2 = engine._hardwareRenderer.isWebGL2;
        var macroNameList = [];
        ShaderMacro._getNamesByMacros(macroCollection, macroNameList);
        var macroNameStr = ShaderFactory.parseCustomMacros(macroNameList);
        var versionStr = isWebGL2 ? "#version 300 es" : "#version 100";
        var graphicAPI = isWebGL2 ? "#define GRAPHICS_API_WEBGL2" : "#define GRAPHICS_API_WEBGL1";
        var precisionStr = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      precision highp int;\n    #else\n      precision mediump float;\n      precision mediump int;\n    #endif\n    ";
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.shaderTextureLod)) {
            precisionStr += "#define HAS_TEX_LOD\n";
        }
        if (engine._hardwareRenderer.canIUse(GLCapabilityType.standardDerivatives)) {
            precisionStr += "#define HAS_DERIVATIVES\n";
        }
        var vertexSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._vertexSource);
        var fragmentSource = " " + versionStr + "\n        " + graphicAPI + "\n        " + (isWebGL2 ? "" : ShaderFactory.parseExtension(Shader._shaderExtension)) + "\n        " + precisionStr + "\n        " + macroNameStr + "\n      " + ShaderFactory.parseIncludes(this._fragmentSource);
        if (isWebGL2) {
            vertexSource = ShaderFactory.convertTo300(vertexSource);
            fragmentSource = ShaderFactory.convertTo300(fragmentSource, true);
        }
        shaderProgram = new ShaderProgram(engine, vertexSource, fragmentSource);
        shaderProgramPool.cache(shaderProgram);
        return shaderProgram;
    };
    return ShaderPass;
}(ShaderPart);
(function() {
    ShaderPass._shaderPassCounter = 0;
})();

/**
 * Sub shader.
 */ var SubShader = /*#__PURE__*/ function(ShaderPart) {
    _inherits$2(SubShader, ShaderPart);
    function SubShader(name, passes, tags) {
        var _this;
        _this = ShaderPart.call(this) || this;
        _this.name = name;
        var passCount = passes.length;
        if (passCount < 1) {
            throw " count must large than 0.";
        }
        _this._passes = passes.slice();
        for(var key in tags){
            _this.setTag(key, tags[key]);
        }
        return _this;
    }
    _create_class$3(SubShader, [
        {
            key: "passes",
            get: /**
   * Sub shader passes.
   */ function get() {
                return this._passes;
            }
        }
    ]);
    return SubShader;
}(ShaderPart);

/**
 * Shader for rendering.
 */ var Shader = /*#__PURE__*/ function() {
    function Shader(name, subShaders) {
        this.name = name;
        this.name = name;
        this._subShaders = subShaders;
    }
    var _proto = Shader.prototype;
    /**
   * Compile shader variant by macro name list.
   *
   * @remarks
   * Usually a shader contains some macros,any combination of macros is called shader variant.
   *
   * @param engine - Engine to which the shader variant belongs
   * @param macros - Macro name list
   * @returns Is the compiled shader variant valid
   */ _proto.compileVariant = function compileVariant(engine, macros) {
        var compileMacros = Shader._compileMacros;
        compileMacros.clear();
        for(var i = 0, n = macros.length; i < n; i++){
            compileMacros.enable(ShaderMacro.getByName(macros[i]));
        }
        var subShaders = this._subShaders;
        for(var i1 = 0, n1 = subShaders.length; i1 < n1; i1++){
            var isValid = void 0;
            var passes = subShaders[i1].passes;
            for(var j = 0, m = passes.length; j < m; j++){
                if (isValid === undefined) {
                    isValid = passes[j]._getShaderProgram(engine, compileMacros).isValid;
                } else {
                    isValid && (isValid = passes[j]._getShaderProgram(engine, compileMacros).isValid);
                }
            }
            if (isValid) return true;
        }
        return false;
    };
    Shader.create = function create(name, vertexSourceOrShaderPassesOrSubShaders, fragmentSource) {
        var shaderMap = Shader._shaderMap;
        if (shaderMap[name]) {
            throw 'Shader named "' + name + '" already exists.';
        }
        var shader;
        if (typeof vertexSourceOrShaderPassesOrSubShaders === "string") {
            var shaderPass = new ShaderPass(vertexSourceOrShaderPassesOrSubShaders, fragmentSource);
            shader = new Shader(name, [
                new SubShader("Default", [
                    shaderPass
                ])
            ]);
        } else {
            if (vertexSourceOrShaderPassesOrSubShaders.length > 0) {
                if (vertexSourceOrShaderPassesOrSubShaders[0].constructor === ShaderPass) {
                    shader = new Shader(name, [
                        new SubShader("Default", vertexSourceOrShaderPassesOrSubShaders)
                    ]);
                } else {
                    shader = new Shader(name, vertexSourceOrShaderPassesOrSubShaders.slice());
                }
            } else {
                throw "SubShader or ShaderPass count must large than 0.";
            }
        }
        shaderMap[name] = shader;
        return shader;
    };
    /**
   * Find a shader by name.
   * @param name - Name of the shader
   */ Shader.find = function find(name) {
        return Shader._shaderMap[name];
    };
    Shader.getMacroByName = function getMacroByName(name, value) {
        return ShaderMacro.getByName(name, value);
    };
    /**
   * @deprecated Please use `ShaderProperty.getByName` instead
   *
   * Get shader property by name.
   * @param name - Name of the shader property
   * @returns Shader property
   */ Shader.getPropertyByName = function getPropertyByName(name) {
        return ShaderProperty.getByName(name);
    };
    _create_class$3(Shader, [
        {
            key: "subShaders",
            get: /**
   * Sub shaders of the shader.
   */ function get() {
                return this._subShaders;
            }
        }
    ]);
    return Shader;
}();
(function() {
    /** @internal */ Shader._compileMacros = new ShaderMacroCollection();
})();
(function() {
    /** @internal */ Shader._shaderExtension = [
        "GL_EXT_shader_texture_lod",
        "GL_OES_standard_derivatives",
        "GL_EXT_draw_buffers"
    ];
})();
(function() {
    Shader._shaderMap = Object.create(null);
})();

/**
 * @internal
 * Rendering context.
 */ var RenderContext = /*#__PURE__*/ function() {
    function RenderContext() {}
    var _proto = RenderContext.prototype;
    _proto.applyVirtualCamera = function applyVirtualCamera(virtualCamera) {
        this.virtualCamera = virtualCamera;
        var shaderData = this.camera.shaderData;
        shaderData.setMatrix(RenderContext._viewMatrixProperty, virtualCamera.viewMatrix);
        shaderData.setMatrix(RenderContext._projectionMatrixProperty, virtualCamera.projectionMatrix);
        shaderData.setMatrix(RenderContext.vpMatrixProperty, virtualCamera.viewProjectionMatrix);
    };
    return RenderContext;
}();
(function() {
    RenderContext.vpMatrixProperty = ShaderProperty.getByName("camera_VPMat");
})();
(function() {
    RenderContext.pipelineStageKey = ShaderTagKey.getByName("pipelineStage");
})();
(function() {
    RenderContext._viewMatrixProperty = ShaderProperty.getByName("camera_ViewMat");
})();
(function() {
    RenderContext._projectionMatrixProperty = ShaderProperty.getByName("camera_ProjMat");
})();

var RenderElement = /*#__PURE__*/ function() {
    function RenderElement() {}
    var _proto = RenderElement.prototype;
    _proto.set = function set(data, shaderPass, renderState) {
        this.data = data;
        this.shaderPass = shaderPass;
        this.renderState = renderState;
    };
    _proto.dispose = function dispose() {
        this.data = this.shaderPass = this.renderState = null;
    };
    return RenderElement;
}();

/**
 * Sprite mask interaction.
 */ var SpriteMaskInteraction;
(function(SpriteMaskInteraction) {
    SpriteMaskInteraction[SpriteMaskInteraction[/** The sprite will not interact with the masking system. */ "None"] = 0] = "None";
    SpriteMaskInteraction[SpriteMaskInteraction[/** The sprite will be visible only in areas where a mask is present. */ "VisibleInsideMask"] = 1] = "VisibleInsideMask";
    SpriteMaskInteraction[SpriteMaskInteraction[/** The sprite will be visible only in areas where no mask is present. */ "VisibleOutsideMask"] = 2] = "VisibleOutsideMask";
})(SpriteMaskInteraction || (SpriteMaskInteraction = {}));

// @ts-ignore
var _Renderer;
var Renderer = (_Renderer = /*#__PURE__*/ function(Component) {
    _inherits$2(Renderer1, Component);
    function Renderer1(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        /** @internal */ _this._onUpdateIndex = -1;
        /** @internal */ _this._rendererIndex = -1;
        /** @internal */ _this._globalShaderMacro = new ShaderMacroCollection();
        /** @internal */ _this._bounds = new BoundingBox();
        _this._overrideUpdate = false;
        _this._materials = [];
        _this._dirtyUpdateFlag = 0;
        _this._shaderData = new ShaderData(ShaderDataGroup.Renderer);
        _this._mvMatrix = new Matrix();
        _this._mvpMatrix = new Matrix();
        _this._mvInvMatrix = new Matrix();
        _this._normalMatrix = new Matrix();
        _this._materialsInstanced = [];
        _this._priority = 0;
        _this._receiveShadows = true;
        _this._rendererLayer = new Vector4();
        /** Whether cast shadow. */ _this.castShadows = true;
        var prototype = Renderer.prototype;
        var shaderData = _this.shaderData;
        _this._overrideUpdate = _this.update !== prototype.update;
        shaderData._addReferCount(1);
        _this._onTransformChanged = _this._onTransformChanged.bind(_assert_this_initialized(_this));
        _this._registerEntityTransformListener();
        shaderData.enableMacro(Renderer._receiveShadowMacro);
        shaderData.setVector4(Renderer._rendererLayerProperty, _this._rendererLayer);
        return _this;
    }
    var _proto = Renderer1.prototype;
    _proto.getInstanceMaterial = function getInstanceMaterial(index) {
        if (index === void 0) index = 0;
        var materials = this._materials;
        if (materials.length > index) {
            var material = materials[index];
            if (material) {
                if (this._materialsInstanced[index]) {
                    return material;
                } else {
                    return this._createInstanceMaterial(material, index);
                }
            }
        }
        return null;
    };
    _proto.getMaterial = function getMaterial(index) {
        if (index === void 0) index = 0;
        return this._materials[index] || null;
    };
    _proto.setMaterial = function setMaterial(indexOrMaterial, material) {
        if (material === void 0) material = null;
        if (typeof indexOrMaterial === "number") {
            this._setMaterial(indexOrMaterial, material);
        } else {
            this._setMaterial(0, indexOrMaterial);
        }
    };
    /**
   * Get all instance materials.
   * @remarks Calling this function for the first time after the material is set will create an instance material to ensure that it is unique to the renderer.
   * @returns All instance materials
   */ _proto.getInstanceMaterials = function getInstanceMaterials() {
        var materials = this._materials;
        var materialsInstance = this._materialsInstanced;
        for(var i = 0, n = materials.length; i < n; i++){
            if (!materialsInstance[i]) {
                this._createInstanceMaterial(this._materials[i], i);
            }
        }
        return materials;
    };
    /**
   * Get all materials.
   * @returns All materials
   */ _proto.getMaterials = function getMaterials() {
        return this._materials;
    };
    /**
   * Set all materials.
   * @param materials - All materials
   */ _proto.setMaterials = function setMaterials(materials) {
        var count = materials.length;
        var internalMaterials = this._materials;
        var materialsInstanced = this._materialsInstanced;
        for(var i = count, n = internalMaterials.length; i < n; i++){
            var internalMaterial = internalMaterials[i];
            internalMaterial && internalMaterial._addReferCount(-1);
        }
        internalMaterials.length !== count && (internalMaterials.length = count);
        materialsInstanced.length !== 0 && (materialsInstanced.length = 0);
        for(var i1 = 0; i1 < count; i1++){
            var internalMaterial1 = internalMaterials[i1];
            var material = materials[i1];
            if (internalMaterial1 !== material) {
                internalMaterials[i1] = material;
                internalMaterial1 && internalMaterial1._addReferCount(-1);
                material && material._addReferCount(1);
            }
        }
    };
    _proto.update = function update(deltaTime) {};
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        var componentsManager = this.engine._componentsManager;
        if (this._overrideUpdate) {
            componentsManager.addOnUpdateRenderers(this);
        }
        componentsManager.addRenderer(this);
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        var componentsManager = this.engine._componentsManager;
        if (this._overrideUpdate) {
            componentsManager.removeOnUpdateRenderers(this);
        }
        componentsManager.removeRenderer(this);
    };
    /**
   * @internal
   */ _proto._prepareRender = function _prepareRender(context) {
        var virtualCamera = context.virtualCamera;
        var cameraPosition = virtualCamera.position;
        var boundsCenter = this.bounds.getCenter(Renderer._tempVector0);
        if (virtualCamera.isOrthographic) {
            Vector3.subtract(boundsCenter, cameraPosition, boundsCenter);
            this._distanceForSort = Vector3.dot(boundsCenter, virtualCamera.forward);
        } else {
            this._distanceForSort = Vector3.distanceSquared(boundsCenter, cameraPosition);
        }
        this._updateShaderData(context);
        this._render(context);
        // union camera global macro and renderer macro.
        ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        var materials = this._materials;
        for(var i = 0, n = materials.length; i < n; i++){
            target._setMaterial(i, materials[i]);
        }
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this.entity.transform._updateFlagManager.removeListener(this._onTransformChanged);
        this.shaderData._addReferCount(-1);
        var materials = this._materials;
        for(var i = 0, n = materials.length; i < n; i++){
            var _materials_i;
            (_materials_i = materials[i]) == null ? void 0 : _materials_i._addReferCount(-1);
        }
        this._entity = null;
        this._globalShaderMacro = null;
        this._bounds = null;
        this._materials = null;
        this._shaderData = null;
        this._mvMatrix = null;
        this._mvpMatrix = null;
        this._mvInvMatrix = null;
        this._normalMatrix = null;
        this._materialsInstanced = null;
        this._rendererLayer = null;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(context) {
        var entity = this.entity;
        var worldMatrix = entity.transform.worldMatrix;
        this._updateTransformShaderData(context, worldMatrix);
        var layer = entity.layer;
        this._rendererLayer.set(layer & 65535, layer >>> 16 & 65535, 0, 0);
    };
    /**
   * @internal
   */ _proto._updateTransformShaderData = function _updateTransformShaderData(context, worldMatrix) {
        var shaderData = this.shaderData;
        var virtualCamera = context.virtualCamera;
        var mvMatrix = this._mvMatrix;
        var mvpMatrix = this._mvpMatrix;
        var mvInvMatrix = this._mvInvMatrix;
        var normalMatrix = this._normalMatrix;
        Matrix.multiply(virtualCamera.viewMatrix, worldMatrix, mvMatrix);
        Matrix.multiply(virtualCamera.viewProjectionMatrix, worldMatrix, mvpMatrix);
        Matrix.invert(mvMatrix, mvInvMatrix);
        Matrix.invert(worldMatrix, normalMatrix);
        normalMatrix.transpose();
        shaderData.setMatrix(Renderer._localMatrixProperty, this.entity.transform.localMatrix);
        shaderData.setMatrix(Renderer._worldMatrixProperty, worldMatrix);
        shaderData.setMatrix(Renderer._mvMatrixProperty, mvMatrix);
        shaderData.setMatrix(Renderer._mvpMatrixProperty, mvpMatrix);
        shaderData.setMatrix(Renderer._mvInvMatrixProperty, mvInvMatrix);
        shaderData.setMatrix(Renderer._normalMatrixProperty, normalMatrix);
    };
    /**
   * @internal
   */ _proto._registerEntityTransformListener = function _registerEntityTransformListener() {
        this.entity.transform._updateFlagManager.addListener(this._onTransformChanged);
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {};
    /**
   * @internal
   */ _proto._render = function _render(context) {
        throw "not implement";
    };
    /**
   * @internal
   */ _proto._createInstanceMaterial = function _createInstanceMaterial(material, index) {
        var insMaterial = material.clone();
        insMaterial.name = insMaterial.name + "(Instance)";
        material._addReferCount(-1);
        insMaterial._addReferCount(1);
        this._materialsInstanced[index] = true;
        this._materials[index] = insMaterial;
        return insMaterial;
    };
    _proto._setMaterial = function _setMaterial(index, material) {
        var materials = this._materials;
        if (index >= materials.length) {
            materials.length = index + 1;
        }
        var internalMaterial = materials[index];
        if (internalMaterial !== material) {
            var materialsInstance = this._materialsInstanced;
            index < materialsInstance.length && (materialsInstance[index] = false);
            internalMaterial && internalMaterial._addReferCount(-1);
            material && material._addReferCount(1);
            materials[index] = material;
        }
    };
    /**
   * @internal
   */ _proto._onTransformChanged = function _onTransformChanged(type) {
        this._dirtyUpdateFlag |= 0x1;
    };
    _create_class$3(Renderer1, [
        {
            key: "shaderData",
            get: /**
   * ShaderData related to renderer.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "isCulled",
            get: /**
   * Whether it is culled in the current frame and does not participate in rendering.
   */ function get() {
                return !(this._renderFrameCount === undefined || this._renderFrameCount === this._engine.time.frameCount - 1);
            }
        },
        {
            key: "receiveShadows",
            get: /**
   * Whether receive shadow.
   */ function get() {
                return this._receiveShadows;
            },
            set: function set(value) {
                if (this._receiveShadows !== value) {
                    if (value) {
                        this.shaderData.enableMacro(Renderer._receiveShadowMacro);
                    } else {
                        this.shaderData.disableMacro(Renderer._receiveShadowMacro);
                    }
                    this._receiveShadows = value;
                }
            }
        },
        {
            key: "materialCount",
            get: /**
   * Material count.
   */ function get() {
                return this._materials.length;
            },
            set: function set(value) {
                var materials = this._materials;
                var materialsInstanced = this._materialsInstanced;
                materials.length !== value && (materials.length = value);
                materialsInstanced.length > value && (materialsInstanced.length = value);
            }
        },
        {
            key: "bounds",
            get: /**
   * The bounding volume of the renderer.
   */ function get() {
                if (this._dirtyUpdateFlag & 0x1) {
                    this._updateBounds(this._bounds);
                    this._dirtyUpdateFlag &= ~0x1;
                }
                return this._bounds;
            }
        },
        {
            key: "priority",
            get: /**
   * The render priority of the renderer, lower values are rendered first and higher values are rendered last.
   */ function get() {
                return this._priority;
            },
            set: function set(value) {
                this._priority = value;
            }
        }
    ]);
    return Renderer1;
}(Component), function() {
    _Renderer._tempVector0 = new Vector3();
}(), function() {
    _Renderer._receiveShadowMacro = ShaderMacro.getByName("RENDERER_IS_RECEIVE_SHADOWS");
}(), function() {
    _Renderer._localMatrixProperty = ShaderProperty.getByName("renderer_LocalMat");
}(), function() {
    _Renderer._worldMatrixProperty = ShaderProperty.getByName("renderer_ModelMat");
}(), function() {
    _Renderer._mvMatrixProperty = ShaderProperty.getByName("renderer_MVMat");
}(), function() {
    _Renderer._mvpMatrixProperty = ShaderProperty.getByName("renderer_MVPMat");
}(), function() {
    _Renderer._mvInvMatrixProperty = ShaderProperty.getByName("renderer_MVInvMat");
}(), function() {
    _Renderer._normalMatrixProperty = ShaderProperty.getByName("renderer_NormalMat");
}(), function() {
    _Renderer._rendererLayerProperty = ShaderProperty.getByName("renderer_Layer");
}(), _Renderer);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_distanceForSort", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_onUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_rendererIndex", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_globalShaderMacro", void 0);
__decorate$1([
    deepClone
], Renderer.prototype, "_bounds", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_renderFrameCount", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_overrideUpdate", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_materials", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_dirtyUpdateFlag", void 0);
__decorate$1([
    deepClone
], Renderer.prototype, "_shaderData", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvpMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_mvInvMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_normalMatrix", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_materialsInstanced", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_priority", void 0);
__decorate$1([
    assignmentClone
], Renderer.prototype, "_receiveShadows", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_rendererLayer", void 0);
__decorate$1([
    ignoreClone
], Renderer.prototype, "_onTransformChanged", null);
Renderer = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], Renderer);
var RendererUpdateFlags;
(function(RendererUpdateFlags) {
    RendererUpdateFlags[RendererUpdateFlags[/** Include world position and world bounds. */ "WorldVolume"] = 0x1] = "WorldVolume";
})(RendererUpdateFlags || (RendererUpdateFlags = {}));

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */ function StaticInterfaceImplement() {
    return function(constructor) {
    };
}

var _SimpleSpriteAssembler;
var SimpleSpriteAssembler = (_SimpleSpriteAssembler = /*#__PURE__*/ function() {
    function SimpleSpriteAssembler1() {}
    SimpleSpriteAssembler1.resetData = function resetData(renderer) {
        var verticesData = renderer._verticesData;
        var vertexCount = verticesData.vertexCount = 4;
        var positions = verticesData.positions, uvs = verticesData.uvs;
        if (positions.length < vertexCount) {
            for(var i = positions.length; i < vertexCount; i++){
                positions.push(new Vector3());
                uvs.push(new Vector2());
            }
        }
        verticesData.triangles = SimpleSpriteAssembler._rectangleTriangles;
    };
    SimpleSpriteAssembler1.updatePositions = function updatePositions(renderer) {
        var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
        var _sprite_pivot = sprite.pivot, pivotX = _sprite_pivot.x, pivotY = _sprite_pivot.y;
        // Renderer's worldMatrix;
        var worldMatrix = SimpleSpriteAssembler._worldMatrix;
        var wE = worldMatrix.elements;
        // Parent's worldMatrix.
        var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
        var sx = renderer.flipX ? -width : width;
        var sy = renderer.flipY ? -height : height;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - pivotX * wE[0] - pivotY * wE[4];
        wE[13] = pWE[13] - pivotX * wE[1] - pivotY * wE[5];
        wE[14] = pWE[14] - pivotX * wE[2] - pivotY * wE[6];
        // ---------------
        //  2 - 3
        //  |   |
        //  0 - 1
        // ---------------
        // Update positions.
        var spritePositions = sprite._getPositions();
        var positions = renderer._verticesData.positions;
        for(var i = 0; i < 4; i++){
            var _spritePositions_i = spritePositions[i], x = _spritePositions_i.x, y = _spritePositions_i.y;
            positions[i].set(wE[0] * x + wE[4] * y + wE[12], wE[1] * x + wE[5] * y + wE[13], wE[2] * x + wE[6] * y + wE[14]);
        }
        BoundingBox.transform(sprite._getBounds(), worldMatrix, renderer._bounds);
    };
    SimpleSpriteAssembler1.updateUVs = function updateUVs(renderer) {
        var spriteUVs = renderer.sprite._getUVs();
        var renderUVs = renderer._verticesData.uvs;
        var _spriteUVs_ = spriteUVs[0], left = _spriteUVs_.x, bottom = _spriteUVs_.y;
        var _spriteUVs_1 = spriteUVs[3], right = _spriteUVs_1.x, top = _spriteUVs_1.y;
        renderUVs[0].set(left, bottom);
        renderUVs[1].set(right, bottom);
        renderUVs[2].set(left, top);
        renderUVs[3].set(right, top);
    };
    return SimpleSpriteAssembler1;
}(), function() {
    _SimpleSpriteAssembler._rectangleTriangles = [
        0,
        1,
        2,
        2,
        1,
        3
    ];
}(), function() {
    _SimpleSpriteAssembler._worldMatrix = new Matrix();
}(), _SimpleSpriteAssembler);
SimpleSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], SimpleSpriteAssembler);

/**
 * @internal
 */ var VertexData2D = function VertexData2D(vertexCount, positions, uvs, triangles, color) {
    if (triangles === void 0) triangles = null;
    if (color === void 0) color = null;
    this.vertexCount = vertexCount;
    this.positions = positions;
    this.uvs = uvs;
    this.triangles = triangles;
    this.color = color;
};

/**
 * Sprite mask layer.
 */ var SpriteMaskLayer;
(function(SpriteMaskLayer) {
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 0. */ "Layer0"] = 0x1] = "Layer0";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 1. */ "Layer1"] = 0x2] = "Layer1";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 2. */ "Layer2"] = 0x4] = "Layer2";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 3. */ "Layer3"] = 0x8] = "Layer3";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 4. */ "Layer4"] = 0x10] = "Layer4";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 5. */ "Layer5"] = 0x20] = "Layer5";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 6. */ "Layer6"] = 0x40] = "Layer6";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 7. */ "Layer7"] = 0x80] = "Layer7";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 8. */ "Layer8"] = 0x100] = "Layer8";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 9. */ "Layer9"] = 0x200] = "Layer9";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 10. */ "Layer10"] = 0x400] = "Layer10";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 11. */ "Layer11"] = 0x800] = "Layer11";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 12. */ "Layer12"] = 0x1000] = "Layer12";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 13. */ "Layer13"] = 0x2000] = "Layer13";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 14. */ "Layer14"] = 0x4000] = "Layer14";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 15. */ "Layer15"] = 0x8000] = "Layer15";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 16. */ "Layer16"] = 0x10000] = "Layer16";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 17. */ "Layer17"] = 0x20000] = "Layer17";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 18. */ "Layer18"] = 0x40000] = "Layer18";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 19. */ "Layer19"] = 0x80000] = "Layer19";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 20. */ "Layer20"] = 0x100000] = "Layer20";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 21. */ "Layer21"] = 0x200000] = "Layer21";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 22. */ "Layer22"] = 0x400000] = "Layer22";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 23. */ "Layer23"] = 0x800000] = "Layer23";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 24. */ "Layer24"] = 0x1000000] = "Layer24";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 25. */ "Layer25"] = 0x2000000] = "Layer25";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 26. */ "Layer26"] = 0x4000000] = "Layer26";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 27. */ "Layer27"] = 0x8000000] = "Layer27";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 28. */ "Layer28"] = 0x10000000] = "Layer28";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 29. */ "Layer29"] = 0x20000000] = "Layer29";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 30. */ "Layer30"] = 0x40000000] = "Layer30";
    SpriteMaskLayer[SpriteMaskLayer[/** Mask layer 31. */ "Layer31"] = 0x80000000] = "Layer31";
    SpriteMaskLayer[SpriteMaskLayer[/** All mask layers. */ "Everything"] = 0xffffffff] = "Everything";
})(SpriteMaskLayer || (SpriteMaskLayer = {}));

/**
 * Sprite Property Dirty Flag.
 */ var SpriteModifyFlags;
(function(SpriteModifyFlags) {
    SpriteModifyFlags[SpriteModifyFlags["texture"] = 0x1] = "texture";
    SpriteModifyFlags[SpriteModifyFlags["size"] = 0x2] = "size";
    SpriteModifyFlags[SpriteModifyFlags["atlasRotate"] = 0x4] = "atlasRotate";
    SpriteModifyFlags[SpriteModifyFlags["atlasRegion"] = 0x8] = "atlasRegion";
    SpriteModifyFlags[SpriteModifyFlags["atlasRegionOffset"] = 0x10] = "atlasRegionOffset";
    SpriteModifyFlags[SpriteModifyFlags["region"] = 0x20] = "region";
    SpriteModifyFlags[SpriteModifyFlags["pivot"] = 0x40] = "pivot";
    SpriteModifyFlags[SpriteModifyFlags["border"] = 0x80] = "border";
})(SpriteModifyFlags || (SpriteModifyFlags = {}));

/**
 * A component for masking Sprites.
 */ var SpriteMask = /*#__PURE__*/ function(Renderer) {
    _inherits$2(SpriteMask, Renderer);
    function SpriteMask(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this;
        /** The mask layers the sprite mask influence to. */ _this.influenceLayers = SpriteMaskLayer.Everything;
        _this._sprite = null;
        _this._automaticWidth = 0;
        _this._automaticHeight = 0;
        _this._customWidth = undefined;
        _this._customHeight = undefined;
        _this._flipX = false;
        _this._flipY = false;
        _this._alphaCutoff = 0.5;
        _this._verticesData = new VertexData2D(4, [], []);
        SimpleSpriteAssembler.resetData(_assert_this_initialized(_this));
        _this.setMaterial(_this._engine._spriteMaskDefaultMaterial);
        _this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, _this._alphaCutoff);
        _this._onSpriteChange = _this._onSpriteChange.bind(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = SpriteMask.prototype;
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        Renderer.prototype._cloneTo.call(this, target);
        target.sprite = this._sprite;
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        if (this.sprite) {
            SimpleSpriteAssembler.updatePositions(this);
        } else {
            worldBounds.min.set(0, 0, 0);
            worldBounds.max.set(0, 0, 0);
        }
    };
    /**
   * @internal
   * @inheritdoc
   */ _proto._render = function _render(context) {
        var _this_sprite;
        if (!((_this_sprite = this.sprite) == null ? void 0 : _this_sprite.texture) || !this.width || !this.height) {
            return;
        }
        // Update position
        if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
            SimpleSpriteAssembler.updatePositions(this);
            this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
        }
        // Update uv
        if (this._dirtyUpdateFlag & 0x2) {
            SimpleSpriteAssembler.updateUVs(this);
            this._dirtyUpdateFlag &= ~0x2;
        }
        context.camera._renderPipeline._allSpriteMasks.add(this);
        var renderData = this._engine._spriteMaskRenderDataPool.getFromPool();
        var material = this.getMaterial();
        renderData.set(this, material, this._verticesData);
        var renderElement = this._engine._renderElementPool.getFromPool();
        renderElement.set(renderData, material.shader.subShaders[0].passes[0], material.renderStates[0]);
        this._maskElement = renderElement;
    };
    /**
   * @internal
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        Renderer.prototype._onDestroy.call(this);
        var sprite = this._sprite;
        if (sprite) {
            sprite._addReferCount(-1);
            sprite._updateFlagManager.removeListener(this._onSpriteChange);
        }
        this._entity = null;
        this._sprite = null;
        this._verticesData = null;
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        var sprite = this._sprite;
        if (sprite) {
            this._automaticWidth = sprite.width;
            this._automaticHeight = sprite.height;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= ~0x4;
    };
    _proto._onSpriteChange = function _onSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this.shaderData.setTexture(SpriteMask._textureProperty, this.sprite.texture);
                break;
            case SpriteModifyFlags.size:
                this._dirtyUpdateFlag |= 0x4;
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
                break;
            case SpriteModifyFlags.region:
            case SpriteModifyFlags.atlasRegionOffset:
                this._dirtyUpdateFlag |= 0x3;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 0x2;
                break;
            case SpriteModifyFlags.pivot:
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                break;
        }
    };
    _create_class$3(SpriteMask, [
        {
            key: "width",
            get: /**
   * Render width (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return `SpriteMask.sprite.width`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "height",
            get: /**
   * Render height (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return `SpriteMask.sprite.height`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipX",
            get: /**
   * Flips the sprite on the X axis.
   */ function get() {
                return this._flipX;
            },
            set: function set(value) {
                if (this._flipX !== value) {
                    this._flipX = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipY",
            get: /**
   * Flips the sprite on the Y axis.
   */ function get() {
                return this._flipY;
            },
            set: function set(value) {
                if (this._flipY !== value) {
                    this._flipY = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "sprite",
            get: /**
   * The Sprite to render.
   */ function get() {
                return this._sprite;
            },
            set: function set(value) {
                var lastSprite = this._sprite;
                if (lastSprite !== value) {
                    if (lastSprite) {
                        lastSprite._addReferCount(-1);
                        lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
                    }
                    this._dirtyUpdateFlag |= 0x7;
                    if (value) {
                        value._addReferCount(1);
                        value._updateFlagManager.addListener(this._onSpriteChange);
                        this.shaderData.setTexture(SpriteMask._textureProperty, value.texture);
                    } else {
                        this.shaderData.setTexture(SpriteMask._textureProperty, null);
                    }
                    this._sprite = value;
                }
            }
        },
        {
            key: "alphaCutoff",
            get: /**
   * The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite. Value between 0 and 1.
   */ function get() {
                return this._alphaCutoff;
            },
            set: function set(value) {
                if (this._alphaCutoff !== value) {
                    this._alphaCutoff = value;
                    this.shaderData.setFloat(SpriteMask._alphaCutoffProperty, value);
                }
            }
        }
    ]);
    return SpriteMask;
}(Renderer);
(function() {
    /** @internal */ SpriteMask._textureProperty = ShaderProperty.getByName("renderer_MaskTexture");
})();
(function() {
    /** @internal */ SpriteMask._alphaCutoffProperty = ShaderProperty.getByName("renderer_MaskAlphaCutoff");
})();
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "influenceLayers", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_sprite", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_automaticWidth", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_automaticHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_customWidth", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_customHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_flipX", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_flipY", void 0);
__decorate$1([
    assignmentClone
], SpriteMask.prototype, "_alphaCutoff", void 0);
__decorate$1([
    ignoreClone
], SpriteMask.prototype, "_onSpriteChange", null);
var /**
 * @remarks Extends `RendererUpdateFlag`.
 */ SpriteMaskUpdateFlags;
(function(SpriteMaskUpdateFlags) {
    SpriteMaskUpdateFlags[SpriteMaskUpdateFlags[/** UV. */ "UV"] = 0x2] = "UV";
    SpriteMaskUpdateFlags[SpriteMaskUpdateFlags[/** WorldVolume and UV . */ "RenderData"] = 0x3] = "RenderData";
    SpriteMaskUpdateFlags[SpriteMaskUpdateFlags[/** Automatic Size. */ "AutomaticSize"] = 0x4] = "AutomaticSize";
    SpriteMaskUpdateFlags[SpriteMaskUpdateFlags[/** All. */ "All"] = 0x7] = "All";
})(SpriteMaskUpdateFlags || (SpriteMaskUpdateFlags = {}));

/**
 * Vertex element format.
 */ var VertexElementFormat;
(function(VertexElementFormat) {
    VertexElementFormat[VertexElementFormat[/** 32-bit float */ "Float"] = 0] = "Float";
    VertexElementFormat[VertexElementFormat[/** Two-dimensional 32-bit float */ "Vector2"] = 1] = "Vector2";
    VertexElementFormat[VertexElementFormat[/** Three-dimensional 32-bit float */ "Vector3"] = 2] = "Vector3";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 32-bit float */ "Vector4"] = 3] = "Vector4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 8-bit integer,range is [-128,127] */ "Byte4"] = 4] = "Byte4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 8-bit Unsigned integer, range is [0,255] */ "UByte4"] = 5] = "UByte4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 8-bit Normalized integer, range is [-1,1] */ "NormalizedByte4"] = 6] = "NormalizedByte4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 8-bit Normalized unsigned integer, range is [0,1] */ "NormalizedUByte4"] = 7] = "NormalizedUByte4";
    VertexElementFormat[VertexElementFormat[/** Two-dimensional 16-bit integer, range is[-32768, 32767] */ "Short2"] = 8] = "Short2";
    VertexElementFormat[VertexElementFormat[/** Two-dimensional 16-bit Unsigned integer, range is [0, 65535] */ "UShort2"] = 9] = "UShort2";
    VertexElementFormat[VertexElementFormat[/** Two-dimensional 16-bit Unsigned integer, range is [-1, 1] */ "NormalizedShort2"] = 10] = "NormalizedShort2";
    VertexElementFormat[VertexElementFormat[/** Two-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */ "NormalizedUShort2"] = 11] = "NormalizedUShort2";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 16-bit integer, range is [-32768, 32767] */ "Short4"] = 12] = "Short4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 16-bit Unsigned integer, range is [0, 65535] */ "UShort4"] = 13] = "UShort4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 16-bit Normalized integer, range is[-1, 1] */ "NormalizedShort4"] = 14] = "NormalizedShort4";
    VertexElementFormat[VertexElementFormat[/** Four-dimensional 16-bit Normalized unsigned integer, range is [0, 1] */ "NormalizedUShort4"] = 15] = "NormalizedUShort4";
})(VertexElementFormat || (VertexElementFormat = {}));

/**
 * Index format.
 */ var IndexFormat;
(function(IndexFormat) {
    IndexFormat[IndexFormat[/** 8 bit */ "UInt8"] = 0] = "UInt8";
    IndexFormat[IndexFormat[/** 16 bit */ "UInt16"] = 1] = "UInt16";
    IndexFormat[IndexFormat[/** 32 bit */ "UInt32"] = 2] = "UInt32";
})(IndexFormat || (IndexFormat = {}));

var BufferUtil = /*#__PURE__*/ function() {
    function BufferUtil() {}
    BufferUtil._getGLIndexType = function _getGLIndexType(indexFormat) {
        switch(indexFormat){
            case IndexFormat.UInt8:
                return DataType.UNSIGNED_BYTE;
            case IndexFormat.UInt16:
                return DataType.UNSIGNED_SHORT;
            case IndexFormat.UInt32:
                return DataType.UNSIGNED_INT;
        }
    };
    BufferUtil._getGLIndexByteCount = function _getGLIndexByteCount(indexFormat) {
        switch(indexFormat){
            case IndexFormat.UInt8:
                return 1;
            case IndexFormat.UInt16:
                return 2;
            case IndexFormat.UInt32:
                return 4;
        }
    };
    /**
   * @internal
   */ BufferUtil._getElementInfo = function _getElementInfo(format) {
        var size;
        var type;
        var normalized = false;
        switch(format){
            case VertexElementFormat.Float:
                size = 1;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector2:
                size = 2;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector3:
                size = 3;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Vector4:
                size = 4;
                type = DataType.FLOAT;
                break;
            case VertexElementFormat.Byte4:
                size = 4;
                type = DataType.BYTE;
                break;
            case VertexElementFormat.UByte4:
                size = 4;
                type = DataType.UNSIGNED_BYTE;
                break;
            case VertexElementFormat.NormalizedByte4:
                size = 4;
                type = DataType.BYTE;
                normalized = true;
                break;
            case VertexElementFormat.NormalizedUByte4:
                size = 4;
                type = DataType.UNSIGNED_BYTE;
                normalized = true;
                break;
            case VertexElementFormat.Short2:
                size = 2;
                type = DataType.SHORT;
                break;
            case VertexElementFormat.UShort2:
                size = 2;
                type = DataType.UNSIGNED_SHORT;
                break;
            case VertexElementFormat.NormalizedShort2:
                size = 2;
                type = DataType.SHORT;
                normalized = true;
                break;
            case VertexElementFormat.NormalizedUShort2:
                size = 2;
                type = DataType.UNSIGNED_SHORT;
                normalized = true;
                break;
            case VertexElementFormat.Short4:
                size = 4;
                type = DataType.SHORT;
                break;
            case VertexElementFormat.UShort4:
                size = 4;
                type = DataType.UNSIGNED_SHORT;
                break;
            case VertexElementFormat.NormalizedShort4:
                size = 4;
                type = DataType.SHORT;
                normalized = true;
                break;
            case VertexElementFormat.NormalizedUShort4:
                size = 4;
                type = DataType.UNSIGNED_SHORT;
                normalized = true;
                break;
        }
        return {
            size: size,
            type: type,
            normalized: normalized
        };
    };
    return BufferUtil;
}();

/**
 * Vertex element.
 */ var VertexElement = /*#__PURE__*/ function() {
    function VertexElement(semantic, offset, format, bindingIndex, instanceStepRate) {
        if (instanceStepRate === void 0) instanceStepRate = 0;
        this._semantic = semantic;
        this._offset = offset;
        this._format = format;
        this._bindingIndex = bindingIndex;
        this._glElementInfo = BufferUtil._getElementInfo(this.format);
        this._instanceStepRate = Math.floor(instanceStepRate);
    }
    _create_class$3(VertexElement, [
        {
            key: "semantic",
            get: /**
   * Vertex semantic.
   */ function get() {
                return this._semantic;
            }
        },
        {
            key: "offset",
            get: /**
   * Vertex data byte offset.
   */ function get() {
                return this._offset;
            },
            set: function set(value) {
                this._offset = value;
            }
        },
        {
            key: "format",
            get: /**
   * Vertex data format.
   */ function get() {
                return this._format;
            }
        },
        {
            key: "bindingIndex",
            get: /**
   * Vertex buffer binding index.
   */ function get() {
                return this._bindingIndex;
            },
            set: function set(value) {
                this._bindingIndex = value;
            }
        },
        {
            key: "instanceStepRate",
            get: /**
   * Instance cadence, the number of instances drawn for each vertex in the buffer, non-instance elements must be 0.
   */ function get() {
                return this._instanceStepRate;
            }
        }
    ]);
    return VertexElement;
}();

/**
 * Buffer usage.
 */ var BufferUsage;
(function(BufferUsage) {
    BufferUsage[BufferUsage[/** The buffer content are intended to be specified once, and used many times */ "Static"] = 0] = "Static";
    BufferUsage[BufferUsage[/** The buffer contents are intended to be respecified repeatedly, and used many times */ "Dynamic"] = 1] = "Dynamic";
    BufferUsage[BufferUsage[/** The buffer contents are intended to be specified once, and used at most a few times */ "Stream"] = 2] = "Stream";
})(BufferUsage || (BufferUsage = {}));

/**
 * Define update strategy when call bufferData/bufferSubData func.
 */ var SetDataOptions;
(function(SetDataOptions) {
    SetDataOptions[SetDataOptions[/** Can overwrite part of used buffer data and ensure correct rendering */ "None"] = 0] = "None";
    SetDataOptions[SetDataOptions[/** Discard old buffer and create a new buffer, and won't affect the previous rendering */ "Discard"] = 1] = "Discard";
})(SetDataOptions || (SetDataOptions = {}));

/**
 * Buffer.
 */ var Buffer = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Buffer, GraphicsResource);
    function Buffer(engine, type, byteLengthOrData, bufferUsage) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        var _this;
        _this = GraphicsResource.call(this, engine) || this;
        _this._engine = engine;
        _this._type = type;
        _this._bufferUsage = bufferUsage;
        if (typeof byteLengthOrData === "number") {
            _this._byteLength = byteLengthOrData;
            _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLengthOrData, bufferUsage);
        } else {
            var byteLength = byteLengthOrData.byteLength;
            _this._byteLength = byteLength;
            _this._platformBuffer = engine._hardwareRenderer.createPlatformBuffer(type, byteLength, bufferUsage, byteLengthOrData);
        }
        return _this;
    }
    var _proto = Buffer.prototype;
    /**
   * Bind buffer.
   */ _proto.bind = function bind() {
        this._platformBuffer.bind();
    };
    _proto.setData = function setData(data, bufferByteOffset, dataOffset, dataLength, options) {
        if (bufferByteOffset === void 0) bufferByteOffset = 0;
        if (dataOffset === void 0) dataOffset = 0;
        if (options === void 0) options = SetDataOptions.None;
        this._platformBuffer.setData(this._byteLength, data, bufferByteOffset, dataOffset, dataLength, options);
    };
    _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
        if (bufferByteOffset === void 0) bufferByteOffset = 0;
        if (dataOffset === void 0) dataOffset = 0;
        this._platformBuffer.getData(data, bufferByteOffset, dataOffset, dataLength);
    };
    _proto._rebuild = function _rebuild() {
        var platformBuffer = this._engine._hardwareRenderer.createPlatformBuffer(this._type, this._byteLength, this._bufferUsage);
        this._platformBuffer = platformBuffer;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._platformBuffer.destroy();
    };
    /**
   * @deprecated
   */ _proto.resize = function resize(byteLength) {
        this._platformBuffer.resize(byteLength);
        this._byteLength = byteLength;
    };
    _create_class$3(Buffer, [
        {
            key: "type",
            get: /**
   * Buffer binding flag.
   */ function get() {
                return this._type;
            }
        },
        {
            key: "byteLength",
            get: /**
   * Byte length.
   */ function get() {
                return this._byteLength;
            }
        },
        {
            key: "bufferUsage",
            get: /**
   * Buffer usage.
   */ function get() {
                return this._bufferUsage;
            }
        }
    ]);
    return Buffer;
}(GraphicsResource);

/**
 * Buffer binding flag.
 */ var BufferBindFlag;
(function(BufferBindFlag) {
    BufferBindFlag[BufferBindFlag[/** Vertex buffer binding flag */ "VertexBuffer"] = 0] = "VertexBuffer";
    BufferBindFlag[BufferBindFlag[/** Index buffer binding flag */ "IndexBuffer"] = 1] = "IndexBuffer";
})(BufferBindFlag || (BufferBindFlag = {}));

/**
 * Mesh topology.
 */ var MeshTopology;
(function(MeshTopology) {
    MeshTopology[MeshTopology[/** Draws a single dot */ "Points"] = 0] = "Points";
    MeshTopology[MeshTopology[/** Draws a line between a pair of vertices */ "Lines"] = 1] = "Lines";
    MeshTopology[MeshTopology[/** Draws a straight line to the next vertex, and connects the last vertex back to the first */ "LineLoop"] = 2] = "LineLoop";
    MeshTopology[MeshTopology[/** Draws a straight line to the next vertex. */ "LineStrip"] = 3] = "LineStrip";
    MeshTopology[MeshTopology[/** Draws a triangle for a group of three vertices */ "Triangles"] = 4] = "Triangles";
    MeshTopology[MeshTopology[/** Draws a triangle strip */ "TriangleStrip"] = 5] = "TriangleStrip";
    MeshTopology[MeshTopology[/** Draws a triangle fan */ "TriangleFan"] = 6] = "TriangleFan";
})(MeshTopology || (MeshTopology = {}));

/**
 * Index buffer binding.
 */ var IndexBufferBinding = /*#__PURE__*/ function() {
    function IndexBufferBinding(buffer, format) {
        this._buffer = buffer;
        this._format = format;
    }
    _create_class$3(IndexBufferBinding, [
        {
            key: "buffer",
            get: /**
   * Index buffer.
   */ function get() {
                return this._buffer;
            }
        },
        {
            key: "format",
            get: /**
   * Index buffer format.
   */ function get() {
                return this._format;
            }
        }
    ]);
    return IndexBufferBinding;
}();

/**
 * Sub-mesh, mainly contains drawing information.
 */ var SubMesh = /*#__PURE__*/ function() {
    function SubMesh(start, count, topology) {
        if (start === void 0) start = 0;
        if (count === void 0) count = 0;
        if (topology === void 0) topology = MeshTopology.Triangles;
        this.start = start;
        this.count = count;
        this.topology = topology;
    }
    var _proto = SubMesh.prototype;
    _proto.dispose = function dispose() {};
    return SubMesh;
}();

/**
 * Mesh.
 */ var Mesh = /*#__PURE__*/ function(GraphicsResource) {
    _inherits$2(Mesh, GraphicsResource);
    function Mesh(engine, name) {
        var _this;
        _this = GraphicsResource.call(this, engine) || this;
        /** @internal */ _this._vertexElementMap = {};
        /** @internal */ _this._instanceCount = 0;
        /** @internal */ _this._vertexBufferBindings = [];
        /** @internal */ _this._indexBufferBinding = null;
        /** @internal */ _this._vertexElements = [];
        /** @internal */ _this._enableVAO = true;
        /** @internal */ _this._updateFlagManager = new UpdateFlagManager();
        _this._bounds = new BoundingBox();
        _this._subMeshes = [];
        _this.name = name;
        _this._platformPrimitive = _this._engine._hardwareRenderer.createPlatformPrimitive(_assert_this_initialized(_this));
        _this._onBoundsChanged = _this._onBoundsChanged.bind(_assert_this_initialized(_this));
        var bounds = _this._bounds;
        // @ts-ignore
        bounds.min._onValueChanged = _this._onBoundsChanged;
        // @ts-ignore
        bounds.max._onValueChanged = _this._onBoundsChanged;
        return _this;
    }
    var _proto = Mesh.prototype;
    _proto.addSubMesh = function addSubMesh(startOrSubMesh, count, topology) {
        if (topology === void 0) topology = MeshTopology.Triangles;
        if (typeof startOrSubMesh === "number") {
            startOrSubMesh = new SubMesh(startOrSubMesh, count, topology);
        }
        this._subMeshes.push(startOrSubMesh);
        return startOrSubMesh;
    };
    /**
   * Remove sub-mesh.
   * @param subMesh - Sub-mesh needs to be removed
   */ _proto.removeSubMesh = function removeSubMesh(subMesh) {
        var subMeshes = this._subMeshes;
        var index = subMeshes.indexOf(subMesh);
        if (index !== -1) {
            subMeshes.splice(index, 1);
        }
    };
    /**
   * Clear all sub-mesh.
   */ _proto.clearSubMesh = function clearSubMesh() {
        this._subMeshes.length = 0;
    };
    /**
   * @internal
   */ _proto._clearVertexElements = function _clearVertexElements() {
        this._vertexElements.length = 0;
        var vertexElementMap = this._vertexElementMap;
        for(var k in vertexElementMap){
            delete vertexElementMap[k];
        }
    };
    /**
   * @internal
   */ _proto._addVertexElement = function _addVertexElement(element) {
        var semantic = element.semantic;
        this._vertexElementMap[semantic] = element;
        this._vertexElements.push(element);
        this._updateFlagManager.dispatch(0x2);
        this._bufferStructChanged = true;
    };
    /**
   * @internal
   */ _proto._insertVertexElement = function _insertVertexElement(i, element) {
        var semantic = element.semantic;
        this._vertexElementMap[semantic] = element;
        this._vertexElements.splice(i, 0, element);
        this._updateFlagManager.dispatch(0x2);
        this._bufferStructChanged = true;
    };
    /**
   * @internal
   */ _proto._setVertexBufferBinding = function _setVertexBufferBinding(index, binding) {
        var referCount = this._getReferCount();
        if (referCount > 0) {
            var _this__vertexBufferBindings_index;
            (_this__vertexBufferBindings_index = this._vertexBufferBindings[index]) == null ? void 0 : _this__vertexBufferBindings_index._buffer._addReferCount(-referCount);
            binding == null ? void 0 : binding._buffer._addReferCount(referCount);
        }
        this._vertexBufferBindings[index] = binding;
        this._bufferStructChanged = true;
    };
    /**
   * @internal
   */ _proto._draw = function _draw(shaderProgram, subMesh) {
        this._platformPrimitive.draw(shaderProgram, subMesh);
        this._bufferStructChanged = false;
    };
    _proto._addReferCount = function _addReferCount(value) {
        var _this__indexBufferBinding;
        GraphicsResource.prototype._addReferCount.call(this, value);
        var vertexBufferBindings = this._vertexBufferBindings;
        for(var i = 0, n = vertexBufferBindings.length; i < n; i++){
            vertexBufferBindings[i]._buffer._addReferCount(value);
        }
        (_this__indexBufferBinding = this._indexBufferBinding) == null ? void 0 : _this__indexBufferBinding._buffer._addReferCount(value);
    };
    _proto._rebuild = function _rebuild() {
        this._engine._hardwareRenderer.createPlatformPrimitive(this);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        GraphicsResource.prototype._onDestroy.call(this);
        this._vertexBufferBindings = null;
        this._indexBufferBinding = null;
        this._vertexElements = null;
        this._vertexElementMap = null;
        this._platformPrimitive.destroy();
    };
    /**
   * @internal
   */ _proto._setVertexElements = function _setVertexElements(elements) {
        this._clearVertexElements();
        for(var i = 0, n = elements.length; i < n; i++){
            this._addVertexElement(elements[i]);
        }
    };
    /**
   * @internal
   */ _proto._setIndexBufferBinding = function _setIndexBufferBinding(binding) {
        var lastBinding = this._indexBufferBinding;
        var referCount = this._getReferCount();
        if (referCount > 0) {
            lastBinding == null ? void 0 : lastBinding.buffer._addReferCount(-referCount);
            binding == null ? void 0 : binding.buffer._addReferCount(referCount);
        }
        if (binding) {
            this._indexBufferBinding = binding;
            this._glIndexType = BufferUtil._getGLIndexType(binding.format);
            this._glIndexByteCount = BufferUtil._getGLIndexByteCount(binding.format);
            (!lastBinding || lastBinding._buffer !== binding._buffer) && (this._bufferStructChanged = true);
        } else {
            this._indexBufferBinding = null;
            this._glIndexType = undefined;
            lastBinding && (this._bufferStructChanged = true);
        }
    };
    _proto._onBoundsChanged = function _onBoundsChanged() {
        this._updateFlagManager.dispatch(0x1);
    };
    _create_class$3(Mesh, [
        {
            key: "bounds",
            get: /**
   * The bounding volume of the mesh.
   */ function get() {
                return this._bounds;
            },
            set: function set(value) {
                if (this._bounds !== value) {
                    this._bounds.copyFrom(value);
                }
            }
        },
        {
            key: "subMesh",
            get: /**
   * First sub-mesh. Rendered using the first material.
   */ function get() {
                return this._subMeshes[0] || null;
            }
        },
        {
            key: "subMeshes",
            get: /**
   * A collection of sub-mesh, each sub-mesh can be rendered with an independent material.
   */ function get() {
                return this._subMeshes;
            }
        }
    ]);
    return Mesh;
}(GraphicsResource);
var MeshModifyFlags;
(function(MeshModifyFlags) {
    MeshModifyFlags[MeshModifyFlags["Bounds"] = 0x1] = "Bounds";
    MeshModifyFlags[MeshModifyFlags["VertexElements"] = 0x2] = "VertexElements";
})(MeshModifyFlags || (MeshModifyFlags = {}));

/**
 * Vertex buffer binding.
 */ var VertexBufferBinding = /*#__PURE__*/ function() {
    function VertexBufferBinding(buffer, stride) {
        this._buffer = buffer;
        this._stride = stride;
    }
    _create_class$3(VertexBufferBinding, [
        {
            key: "buffer",
            get: /**
   * Vertex buffer.
   */ function get() {
                return this._buffer;
            }
        },
        {
            key: "stride",
            get: /**
   * Vertex buffer stride.
   */ function get() {
                return this._stride;
            }
        }
    ]);
    return VertexBufferBinding;
}();

/**
 * @internal
 */ var BlendShapeManager = /*#__PURE__*/ function() {
    function BlendShapeManager(engine, modelMesh) {
        /** @internal */ this._blendShapeCount = 0;
        /** @internal */ this._blendShapes = [];
        /** @internal */ this._subDataDirtyFlags = [];
        /** @internal */ this._vertexBuffers = [];
        /** @internal */ this._uniformOccupiesCount = 0;
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._storeInVertexBufferInfo = [];
        this._maxCountSingleVertexBuffer = 0;
        this._lastCreateHostInfo = new Vector3(0, 0, 0);
        this._canUseTextureStoreData = true;
        this._dataTextureInfo = new Vector3();
        this._engine = engine;
        this._modelMesh = modelMesh;
        this._canUseTextureStoreData = this._engine._hardwareRenderer.capability.canUseFloatTextureBlendShape;
        this._updateLayoutChange = this._updateLayoutChange.bind(this);
    }
    var _proto = BlendShapeManager.prototype;
    /**
   * @internal
   */ _proto._addBlendShape = function _addBlendShape(blendShape) {
        this._blendShapes.push(blendShape);
        this._blendShapeCount++;
        blendShape._layoutChangeManager.addListener(this._updateLayoutChange);
        this._updateLayoutChange(0, blendShape);
        this._subDataDirtyFlags.push(blendShape._dataChangeManager.createFlag(BoolUpdateFlag));
    };
    /**
   * @internal
   */ _proto._clearBlendShapes = function _clearBlendShapes() {
        var blendShapes = this._blendShapes;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            blendShapes[i]._layoutChangeManager.removeListener(this._updateLayoutChange);
        }
        this._useBlendNormal = false;
        this._useBlendTangent = false;
        this._vertexElementCount = 0;
        this._blendShapes.length = 0;
        this._blendShapeCount = 0;
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for(var i1 = 0, n1 = subDataDirtyFlags.length; i1 < n1; i1++){
            subDataDirtyFlags[i1].destroy();
        }
        subDataDirtyFlags.length = 0;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(shaderData, skinnedMeshRenderer) {
        var blendShapeCount = this._blendShapeCount;
        if (blendShapeCount > 0) {
            shaderData.enableMacro(BlendShapeManager._blendShapeMacro);
            if (this._useTextureMode()) {
                shaderData.enableMacro(BlendShapeManager._blendShapeTextureMacro);
                shaderData.setTexture(BlendShapeManager._blendShapeTextureProperty, this._vertexTexture);
                shaderData.setVector3(BlendShapeManager._blendShapeTextureInfoProperty, this._dataTextureInfo);
                shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
                shaderData.enableMacro("RENDERER_BLENDSHAPE_COUNT", blendShapeCount.toString());
                this._uniformOccupiesCount = blendShapeCount + 1;
            } else {
                var maxBlendCount = this._getVertexBufferModeSupportCount();
                if (blendShapeCount > maxBlendCount) {
                    var condensedBlendShapeWeights = skinnedMeshRenderer._condensedBlendShapeWeights;
                    if (!condensedBlendShapeWeights) {
                        condensedBlendShapeWeights = new Float32Array(maxBlendCount);
                        skinnedMeshRenderer._condensedBlendShapeWeights = condensedBlendShapeWeights;
                    }
                    this._filterCondensedBlendShapeWeights(skinnedMeshRenderer.blendShapeWeights, condensedBlendShapeWeights);
                    shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, condensedBlendShapeWeights);
                    this._modelMesh._enableVAO = false;
                    blendShapeCount = maxBlendCount;
                } else {
                    shaderData.setFloatArray(BlendShapeManager._blendShapeWeightsProperty, skinnedMeshRenderer.blendShapeWeights);
                    this._modelMesh._enableVAO = true;
                }
                shaderData.disableMacro(BlendShapeManager._blendShapeTextureMacro);
                shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
                this._uniformOccupiesCount = blendShapeCount;
            }
            if (this._useBlendNormal) {
                shaderData.enableMacro(BlendShapeManager._blendShapeNormalMacro);
            } else {
                shaderData.disableMacro(BlendShapeManager._blendShapeNormalMacro);
            }
            if (this._useBlendTangent) {
                shaderData.enableMacro(BlendShapeManager._blendShapeTangentMacro);
            } else {
                shaderData.disableMacro(BlendShapeManager._blendShapeTangentMacro);
            }
        } else {
            shaderData.disableMacro(BlendShapeManager._blendShapeMacro);
            shaderData.disableMacro("RENDERER_BLENDSHAPE_COUNT");
        }
    };
    /**
   * @internal
   */ _proto._useTextureMode = function _useTextureMode() {
        if (!this._canUseTextureStoreData) {
            return false;
        }
        return this._blendShapeCount > this._getVertexBufferModeSupportCount();
    };
    /**
   * @internal
   */ _proto._layoutOrCountChange = function _layoutOrCountChange() {
        var last = this._lastCreateHostInfo;
        return last.x !== this._blendShapeCount || !!last.y !== this._useBlendNormal || !!last.z !== this._useBlendTangent;
    };
    /**
   * @internal
   */ _proto._vertexElementsNeedUpdate = function _vertexElementsNeedUpdate() {
        var maxSupportCount = this._getVertexBufferModeSupportCount();
        var info = this._lastCreateHostInfo;
        return Math.min(info.x, maxSupportCount) !== Math.min(this._blendShapeCount, maxSupportCount) || !!info.y !== this._useBlendNormal || !!info.z !== this._useBlendTangent;
    };
    /**
   * @internal
   */ _proto._needUpdateData = function _needUpdateData() {
        var subDataDirtyFlags = this._subDataDirtyFlags;
        for(var i = 0, n = subDataDirtyFlags.length; i < n; i++){
            if (subDataDirtyFlags[i].flag) {
                return true;
            }
        }
        return false;
    };
    /**
   * @internal
   */ _proto._setAttributeModeOffsetInfo = function _setAttributeModeOffsetInfo(vertexElementOffset, bufferBindingOffset) {
        this._vertexElementOffset = vertexElementOffset;
        this._bufferBindingOffset = bufferBindingOffset;
    };
    /**
   * @internal
   */ _proto._addVertexElements = function _addVertexElements(modelMesh) {
        var bindingOffset = this._bufferBindingOffset;
        var offset = 0;
        for(var i = 0, n = Math.min(this._blendShapeCount, this._getVertexBufferModeSupportCount()); i < n; i++){
            modelMesh._addVertexElement(new VertexElement("POSITION_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
            offset += 12;
            if (this._useBlendNormal) {
                modelMesh._addVertexElement(new VertexElement("NORMAL_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
                offset += 12;
            }
            if (this._useBlendTangent) {
                modelMesh._addVertexElement(new VertexElement("TANGENT_BS" + i, offset, VertexElementFormat.Vector3, bindingOffset));
                offset += 12;
            }
        }
    };
    /**
   * @internal
   */ _proto._update = function _update(vertexCountChange, noLongerReadable) {
        var vertexCount = this._modelMesh.vertexCount;
        var useTexture = this._useTextureMode();
        var createHost = this._layoutOrCountChange() || vertexCountChange;
        if (createHost) {
            if (useTexture) {
                this._createTextureArray(vertexCount);
            } else {
                this._createVertexBuffers(vertexCount, noLongerReadable);
            }
            this._lastCreateHostInfo.set(this._blendShapeCount, +this._useBlendNormal, +this._useBlendTangent);
        }
        if (this._needUpdateData()) {
            if (useTexture) {
                this._updateTextureArray(vertexCount, createHost);
            } else {
                this._updateVertexBuffers(vertexCount, createHost);
            }
        }
    };
    /**
   * @internal
   */ _proto._releaseMemoryCache = function _releaseMemoryCache() {
        var blendShapes = this._blendShapes;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            blendShapes[i]._releaseData();
        }
        this._vertices = null;
    };
    _proto._createVertexBuffers = function _createVertexBuffers(vertexCount, noLongerAccessible) {
        var _this = this, engine = _this._engine, modelMesh = _this._modelMesh, blendShapeCount = _this._blendShapeCount, vertexBuffers = _this._vertexBuffers;
        var vertexFloatCount = this._vertexElementCount * 3;
        var vertexByteCount = vertexFloatCount * 4;
        var maxCountSingleBuffer = Math.floor(255 / vertexByteCount); // 255: Attribute MaxStride
        var bufferCount = Math.ceil(blendShapeCount / maxCountSingleBuffer);
        var floatCount = vertexFloatCount * vertexCount * Math.min(maxCountSingleBuffer, blendShapeCount);
        vertexBuffers.length = bufferCount;
        this._vertices = new Float32Array(floatCount);
        this._maxCountSingleVertexBuffer = maxCountSingleBuffer;
        this._storeInVertexBufferInfo.length = blendShapeCount;
        var bufferBindingOffset = this._bufferBindingOffset;
        for(var i = 0; i < bufferCount; i++){
            var lastIndex = bufferCount - 1;
            var containCount = i === lastIndex ? blendShapeCount - lastIndex * maxCountSingleBuffer : maxCountSingleBuffer;
            var stride = containCount * vertexByteCount;
            var byteLength = stride * vertexCount;
            var usage = noLongerAccessible ? BufferUsage.Static : BufferUsage.Dynamic;
            var blendShapeBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, byteLength, usage);
            modelMesh._setVertexBufferBinding(bufferBindingOffset + i, new VertexBufferBinding(blendShapeBuffer, stride));
            vertexBuffers[i] = blendShapeBuffer;
        }
    };
    _proto._createTextureArray = function _createTextureArray(vertexCount) {
        var maxTextureSize = this._engine._hardwareRenderer.capability.maxTextureSize;
        var vertexPixelStride = this._vertexElementCount;
        var textureWidth = vertexPixelStride * vertexCount;
        var textureHeight = 1;
        if (textureWidth > maxTextureSize) {
            textureHeight = Math.ceil(textureWidth / maxTextureSize);
            textureWidth = maxTextureSize;
        }
        var blendShapeDataTexture = this._vertexTexture;
        var blendShapeCount = this._blendShapes.length;
        blendShapeDataTexture && blendShapeDataTexture.destroy();
        blendShapeDataTexture = new Texture2DArray(this._engine, textureWidth, textureHeight, blendShapeCount, TextureFormat.R32G32B32A32, false);
        blendShapeDataTexture.filterMode = TextureFilterMode.Point;
        this._vertices = new Float32Array(blendShapeCount * textureWidth * textureHeight * 4);
        this._vertexTexture = blendShapeDataTexture;
        this._dataTextureInfo.set(vertexPixelStride, textureWidth, textureHeight);
    };
    /**
   * @internal
   */ _proto._updateVertexBuffers = function _updateVertexBuffers(vertexCount, force) {
        var _this = this, blendShapes = _this._blendShapes, maxCountSingleBuffer = _this._maxCountSingleVertexBuffer;
        var _this1 = this, vertices = _this1._vertices, vertexBuffers = _this1._vertexBuffers, storeInfos = _this1._storeInVertexBufferInfo;
        var subDataDirtyFlags = this._subDataDirtyFlags;
        var blendShapeFloatStride = this._vertexElementCount * 3;
        var blendShapeByteStride = blendShapeFloatStride * 4;
        var bufferOffset = this._bufferBindingOffset;
        // @todo: should fix bug when dataChangedFlag is true
        for(var i = 0, n = blendShapes.length; i < n; i++){
            var dataChangedFlag = subDataDirtyFlags[i];
            if (force || dataChangedFlag.flag) {
                var frames = blendShapes[i].frames;
                var frameCount = frames.length;
                var endFrame = frames[frameCount - 1];
                if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
                    throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
                }
                var bufferIndex = Math.floor(i / maxCountSingleBuffer);
                var indexInBuffer = i % maxCountSingleBuffer;
                var buffer = vertexBuffers[bufferIndex];
                var bufferFloatStride = buffer.byteLength / (vertexCount * 4);
                var offset = indexInBuffer * blendShapeFloatStride;
                var storeInfo = storeInfos[i];
                storeInfo || (storeInfos[i] = storeInfo = new Vector2());
                storeInfo.set(bufferOffset + bufferIndex, indexInBuffer * blendShapeByteStride); // BufferOffset is mesh vertexBuffer offset
                var deltaPositions = endFrame.deltaPositions;
                for(var j = 0; j < vertexCount; j++){
                    var start = offset + bufferFloatStride * j;
                    var deltaPosition = deltaPositions[j];
                    if (deltaPosition) {
                        vertices[start] = deltaPosition.x;
                        vertices[start + 1] = deltaPosition.y;
                        vertices[start + 2] = deltaPosition.z;
                    }
                }
                offset += 3;
                if (this._useBlendNormal) {
                    var deltaNormals = endFrame.deltaNormals;
                    if (deltaNormals) {
                        for(var j1 = 0; j1 < vertexCount; j1++){
                            var start1 = offset + bufferFloatStride * j1;
                            var deltaNormal = deltaNormals[j1];
                            if (deltaNormal) {
                                vertices[start1] = deltaNormal.x;
                                vertices[start1 + 1] = deltaNormal.y;
                                vertices[start1 + 2] = deltaNormal.z;
                            }
                        }
                    }
                    offset += 3;
                }
                if (this._useBlendTangent) {
                    var deltaTangents = endFrame.deltaTangents;
                    if (deltaTangents) {
                        for(var j2 = 0; j2 < vertexCount; j2++){
                            var start2 = offset + bufferFloatStride * j2;
                            var deltaTangent = deltaTangents[j2];
                            if (deltaTangent) {
                                vertices[start2] = deltaTangent.x;
                                vertices[start2 + 1] = deltaTangent.y;
                                vertices[start2 + 2] = deltaTangent.z;
                            }
                        }
                    }
                    offset += 3;
                }
                if (indexInBuffer === maxCountSingleBuffer - 1 || i === n - 1) {
                    // @todo: can optimize in setData
                    buffer.setData(vertices, 0, 0, buffer.byteLength / 4);
                }
                dataChangedFlag.flag = false;
            }
        }
    };
    _proto._updateTextureArray = function _updateTextureArray(vertexCount, force) {
        var _this = this, blendShapes = _this._blendShapes, vertexTexture = _this._vertexTexture, vertices = _this._vertices, subDataDirtyFlags = _this._subDataDirtyFlags;
        for(var i = 0, n = blendShapes.length; i < n; i++){
            var subDirtyFlag = subDataDirtyFlags[i];
            var subBlendShapeDataStride = vertexTexture.width * vertexTexture.height * 4;
            if (force || subDirtyFlag.flag) {
                var frames = blendShapes[i].frames;
                var frameCount = frames.length;
                var endFrame = frames[frameCount - 1];
                if (frameCount > 0 && endFrame.deltaPositions.length !== vertexCount) {
                    throw "BlendShape frame deltaPositions length must same with mesh vertexCount.";
                }
                var deltaPositions = endFrame.deltaPositions, deltaNormals = endFrame.deltaNormals, deltaTangents = endFrame.deltaTangents;
                var offset = i * subBlendShapeDataStride;
                for(var j = 0; j < vertexCount; j++){
                    var position = deltaPositions[j];
                    vertices[offset] = position.x;
                    vertices[offset + 1] = position.y;
                    vertices[offset + 2] = position.z;
                    offset += 4;
                    if (deltaNormals) {
                        var normal = deltaNormals[j];
                        vertices[offset] = normal.x;
                        vertices[offset + 1] = normal.y;
                        vertices[offset + 2] = normal.z;
                        offset += 4;
                    }
                    if (deltaTangents) {
                        var tangent = deltaTangents[j];
                        vertices[offset] = tangent.x;
                        vertices[offset + 1] = tangent.y;
                        vertices[offset + 2] = tangent.z;
                        offset += 4;
                    }
                }
                subDirtyFlag.flag = false;
            }
        }
        vertexTexture.setPixelBuffer(0, vertices);
    };
    _proto._updateLayoutChange = function _updateLayoutChange(type, blendShape) {
        var notFirst = this._blendShapeCount > 1;
        var vertexElementCount = 1;
        var useBlendNormal = blendShape._useBlendShapeNormal;
        var useBlendTangent = blendShape._useBlendShapeTangent;
        if (notFirst) {
            useBlendNormal && (useBlendNormal = this._useBlendNormal);
            useBlendTangent && (useBlendTangent = this._useBlendTangent);
        }
        useBlendNormal && vertexElementCount++;
        useBlendTangent && vertexElementCount++;
        this._useBlendNormal = useBlendNormal;
        this._useBlendTangent = useBlendTangent;
        this._vertexElementCount = vertexElementCount;
    };
    _proto._attributeModeUpdateVertexElement = function _attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, index, condensedIndex) {
        var elementOffset = this._vertexElementOffset + this._vertexElementCount * condensedIndex;
        var _vertexBufferStoreInfo_index = vertexBufferStoreInfo[index], bufferIndex = _vertexBufferStoreInfo_index.x, offset = _vertexBufferStoreInfo_index.y;
        var vertexElement = vertexElements[elementOffset];
        vertexElement.bindingIndex = bufferIndex;
        vertexElement.offset = offset;
        if (this._useBlendNormal) {
            var vertexElement1 = vertexElements[++elementOffset];
            offset += 12;
            vertexElement1.bindingIndex = bufferIndex;
            vertexElement1.offset = offset;
        }
        if (this._useBlendTangent) {
            var vertexElement2 = vertexElements[++elementOffset];
            offset += 12;
            vertexElement2.bindingIndex = bufferIndex;
            vertexElement2.offset = offset;
        }
    };
    _proto._getVertexBufferModeSupportCount = function _getVertexBufferModeSupportCount() {
        if (this._useBlendNormal && this._useBlendTangent) {
            return 2;
        } else {
            return this._useBlendNormal || this._useBlendTangent ? 4 : 8;
        }
    };
    _proto._filterCondensedBlendShapeWeights = function _filterCondensedBlendShapeWeights(blendShapeWeights, condensedBlendShapeWeights) {
        var condensedWeightsCount = condensedBlendShapeWeights.length;
        var vertexElements = this._modelMesh._vertexElements;
        var vertexBufferStoreInfo = this._storeInVertexBufferInfo;
        var thresholdWeight = Number.POSITIVE_INFINITY;
        var thresholdIndex;
        for(var i = 0, n = Math.min(blendShapeWeights.length, this._blendShapeCount); i < n; i++){
            var weight = blendShapeWeights[i];
            if (i < condensedWeightsCount) {
                this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, i);
                condensedBlendShapeWeights[i] = weight;
                if (weight < thresholdWeight) {
                    thresholdWeight = weight;
                    thresholdIndex = i;
                }
            } else if (weight > thresholdWeight) {
                this._attributeModeUpdateVertexElement(vertexElements, vertexBufferStoreInfo, i, thresholdIndex);
                condensedBlendShapeWeights[thresholdIndex] = weight;
                thresholdWeight = Number.POSITIVE_INFINITY;
                for(var j = 0; j < condensedWeightsCount; j++){
                    var condensedWeight = condensedBlendShapeWeights[j];
                    if (condensedWeight < thresholdWeight) {
                        thresholdWeight = condensedWeight;
                        thresholdIndex = j;
                    }
                }
            }
        }
    };
    return BlendShapeManager;
}();
(function() {
    BlendShapeManager._blendShapeMacro = ShaderMacro.getByName("RENDERER_HAS_BLENDSHAPE");
})();
(function() {
    BlendShapeManager._blendShapeTextureMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_USE_TEXTURE");
})();
(function() {
    BlendShapeManager._blendShapeNormalMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_NORMAL");
})();
(function() {
    BlendShapeManager._blendShapeTangentMacro = ShaderMacro.getByName("RENDERER_BLENDSHAPE_HAS_TANGENT");
})();
(function() {
    BlendShapeManager._blendShapeWeightsProperty = ShaderProperty.getByName("renderer_BlendShapeWeights");
})();
(function() {
    BlendShapeManager._blendShapeTextureProperty = ShaderProperty.getByName("renderer_BlendShapeTexture");
})();
(function() {
    BlendShapeManager._blendShapeTextureInfoProperty = ShaderProperty.getByName("renderer_BlendShapeTextureInfo");
})();

/**
 * Vertex attribute types of a vertex in a ModelMesh.
 */ var VertexAttribute;
(function(VertexAttribute) {
    VertexAttribute[/** Vertex position. */ "Position"] = "POSITION";
    VertexAttribute[/** Vertex normal. */ "Normal"] = "NORMAL";
    VertexAttribute[/** Vertex color. */ "Color"] = "COLOR_0";
    VertexAttribute[/** Vertex tangent. */ "Tangent"] = "TANGENT";
    VertexAttribute[/** Vertex bone weight. */ "BoneWeight"] = "WEIGHTS_0";
    VertexAttribute[/** Vertex bone index. */ "BoneIndex"] = "JOINTS_0";
    VertexAttribute[/** Vertex UV. */ "UV"] = "TEXCOORD_0";
    VertexAttribute[/** Vertex UV1. */ "UV1"] = "TEXCOORD_1";
    VertexAttribute[/** Vertex UV2. */ "UV2"] = "TEXCOORD_2";
    VertexAttribute[/** Vertex UV3. */ "UV3"] = "TEXCOORD_3";
    VertexAttribute[/** Vertex UV4. */ "UV4"] = "TEXCOORD_4";
    VertexAttribute[/** Vertex UV5. */ "UV5"] = "TEXCOORD_5";
    VertexAttribute[/** Vertex UV6. */ "UV6"] = "TEXCOORD_6";
    VertexAttribute[/** Vertex UV7. */ "UV7"] = "TEXCOORD_7";
})(VertexAttribute || (VertexAttribute = {}));

/**
 * Mesh containing common vertex elements of the model.
 */ var ModelMesh = /*#__PURE__*/ function(Mesh) {
    _inherits$2(ModelMesh, Mesh);
    function ModelMesh(engine, name) {
        var _this;
        _this = Mesh.call(this, engine) || this;
        _this._vertexCount = 0;
        _this._readable = true;
        _this._verticesFloat32 = null;
        _this._verticesUint8 = null;
        _this._indices = null;
        _this._indicesFormat = null;
        _this._indicesChangeFlag = false;
        _this._positions = null;
        _this._normals = null;
        _this._colors = null;
        _this._tangents = null;
        _this._uv = null;
        _this._uv1 = null;
        _this._uv2 = null;
        _this._uv3 = null;
        _this._uv4 = null;
        _this._uv5 = null;
        _this._uv6 = null;
        _this._uv7 = null;
        _this._boneWeights = null;
        _this._boneIndices = null;
        _this._bufferStrides = [];
        _this._vertexBufferUpdateFlag = 0;
        _this._vertexDataUpdateFlag = 0;
        _this._vertexElementsUpdate = false;
        _this._customVertexElements = [];
        _this._vertexCountChanged = false;
        _this.name = name;
        _this._blendShapeManager = new BlendShapeManager(engine, _assert_this_initialized(_this));
        return _this;
    }
    var _proto = ModelMesh.prototype;
    /**
   * Set positions for the mesh.
   * @param positions - The positions for the mesh.
   */ _proto.setPositions = function setPositions(positions) {
        if (!this._positions && !positions) {
            return;
        }
        var newVertexCount = (positions == null ? void 0 : positions.length) || 0;
        this._vertexCountChanged = this._vertexCount != newVertexCount;
        this._vertexCount = newVertexCount;
        this._vertexElementsUpdate = !!this._positions !== !!positions;
        this._vertexBufferUpdateFlag |= 0x1;
        this._vertexDataUpdateFlag &= ~0x1;
        this._positions = positions;
    };
    /**
   * Get positions for the mesh.
   * @remarks Please call the setPositions() method after modification to ensure that the modification takes effect.
   */ _proto.getPositions = function getPositions() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._positions;
    };
    /**
   * Set per-vertex normals for the mesh.
   * @param normals - The normals for the mesh.
   */ _proto.setNormals = function setNormals(normals) {
        if (normals) {
            if (normals.length !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        } else if (!this._normals) {
            return;
        }
        this._vertexElementsUpdate = !!this._normals !== !!normals;
        this._vertexBufferUpdateFlag |= 0x2;
        this._vertexDataUpdateFlag &= ~0x2;
        this._normals = normals;
    };
    /**
   * Get normals for the mesh.
   * @remarks Please call the setNormals() method after modification to ensure that the modification takes effect.
   */ _proto.getNormals = function getNormals() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._normals;
    };
    /**
   * Set per-vertex colors for the mesh.
   * @param colors - The colors for the mesh.
   */ _proto.setColors = function setColors(colors) {
        if (colors) {
            if (colors.length !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        } else if (!this._colors) {
            return;
        }
        this._vertexElementsUpdate = !!this._colors !== !!colors;
        this._vertexBufferUpdateFlag |= 0x4;
        this._vertexDataUpdateFlag &= ~0x4;
        this._colors = colors;
    };
    /**
   * Get colors for the mesh.
   * @remarks Please call the setColors() method after modification to ensure that the modification takes effect.
   */ _proto.getColors = function getColors() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._colors;
    };
    /**
   * Set per-vertex bone weights for the mesh.
   * @param boneWeights - The bone weights for the mesh.
   */ _proto.setBoneWeights = function setBoneWeights(boneWeights) {
        if (boneWeights) {
            if (boneWeights.length !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        } else if (!this._boneWeights) {
            return;
        }
        this._vertexElementsUpdate = !!this._boneWeights !== !!boneWeights;
        this._vertexBufferUpdateFlag |= 0x10;
        this._vertexDataUpdateFlag &= ~0x10;
        this._boneWeights = boneWeights;
    };
    /**
   * Get weights for the mesh.
   * @remarks Please call the setWeights() method after modification to ensure that the modification takes effect.
   */ _proto.getBoneWeights = function getBoneWeights() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._boneWeights;
    };
    /**
   * Set per-vertex bone indices for the mesh.
   * @param boneIndices - The bone indices for the mesh.
   */ _proto.setBoneIndices = function setBoneIndices(boneIndices) {
        if (boneIndices) {
            if ((boneIndices == null ? void 0 : boneIndices.length) !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        } else if (!this._boneIndices) {
            return;
        }
        this._vertexElementsUpdate = !!this._boneIndices !== !!boneIndices;
        this._vertexBufferUpdateFlag |= 0x20;
        this._vertexDataUpdateFlag &= ~0x20;
        this._boneIndices = boneIndices;
    };
    /**
   * Get joints for the mesh.
   * @remarks Please call the setBoneIndices() method after modification to ensure that the modification takes effect.
   */ _proto.getBoneIndices = function getBoneIndices() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._boneIndices;
    };
    /**
   * Set per-vertex tangents for the mesh.
   * @param tangents - The tangents for the mesh.
   */ _proto.setTangents = function setTangents(tangents) {
        if (tangents) {
            if (tangents.length !== this._vertexCount) {
                throw "The array provided needs to be the same size as vertex count.";
            }
        } else if (!this._tangents) {
            return;
        }
        this._vertexElementsUpdate = !!this._tangents !== !!tangents;
        this._vertexBufferUpdateFlag |= 0x8;
        this._vertexDataUpdateFlag &= ~0x8;
        this._tangents = tangents;
    };
    /**
   * Get tangents for the mesh.
   * @remarks Please call the setTangents() method after modification to ensure that the modification takes effect.
   */ _proto.getTangents = function getTangents() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._tangents;
    };
    _proto.setUVs = function setUVs(uv, channelIndex) {
        if (uv && uv.length !== this._vertexCount) {
            throw "The array provided needs to be the same size as vertex count.";
        }
        channelIndex = channelIndex != null ? channelIndex : 0;
        switch(channelIndex){
            case 0:
                if (!this._uv && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv !== !!uv;
                this._vertexBufferUpdateFlag |= 0x40;
                this._vertexDataUpdateFlag &= ~0x40;
                this._uv = uv;
                break;
            case 1:
                if (!this._uv1 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv1 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x80;
                this._vertexDataUpdateFlag &= ~0x80;
                this._uv1 = uv;
                break;
            case 2:
                if (!this._uv2 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv2 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x100;
                this._vertexDataUpdateFlag &= ~0x100;
                this._uv2 = uv;
                break;
            case 3:
                if (!this._uv3 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv3 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x200;
                this._vertexDataUpdateFlag &= ~0x200;
                this._uv3 = uv;
                break;
            case 4:
                if (!this._uv4 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv4 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x400;
                this._vertexDataUpdateFlag &= ~0x400;
                this._uv4 = uv;
                break;
            case 5:
                if (!this._uv5 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv5 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x800;
                this._vertexDataUpdateFlag &= ~0x800;
                this._uv5 = uv;
                break;
            case 6:
                if (!this._uv6 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv6 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x1000;
                this._vertexDataUpdateFlag &= ~0x1000;
                this._uv6 = uv;
                break;
            case 7:
                if (!this._uv7 && !uv) {
                    return;
                }
                this._vertexElementsUpdate = !!this._uv7 !== !!uv;
                this._vertexBufferUpdateFlag |= 0x2000;
                this._vertexDataUpdateFlag &= ~0x2000;
                this._uv7 = uv;
                break;
            default:
                throw "The index of channel needs to be in range [0 - 7].";
        }
    };
    _proto.getUVs = function getUVs(channelIndex) {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        channelIndex = channelIndex != null ? channelIndex : 0;
        switch(channelIndex){
            case 0:
                return this._uv;
            case 1:
                return this._uv1;
            case 2:
                return this._uv2;
            case 3:
                return this._uv3;
            case 4:
                return this._uv4;
            case 5:
                return this._uv5;
            case 6:
                return this._uv6;
            case 7:
                return this._uv7;
        }
        throw "The index of channel needs to be in range [0 - 7].";
    };
    /**
   * Set indices for the mesh.
   * @param indices - The indices for the mesh.
   */ _proto.setIndices = function setIndices(indices) {
        if (this._indices !== indices) {
            this._indices = indices;
            if (_instanceof$2(indices, Uint8Array)) {
                this._indicesFormat = IndexFormat.UInt8;
            } else if (_instanceof$2(indices, Uint16Array)) {
                this._indicesFormat = IndexFormat.UInt16;
            } else if (_instanceof$2(indices, Uint32Array)) {
                this._indicesFormat = IndexFormat.UInt32;
            }
        }
        this._indicesChangeFlag = true;
    };
    /**
   * Get indices for the mesh.
   */ _proto.getIndices = function getIndices() {
        if (!this._readable) {
            throw "Not allowed to access data while accessible is false.";
        }
        return this._indices;
    };
    /**
   * @beta
   * @todo Update buffer should support custom vertex elements.
   * Set vertex elements.
   * @param elements - Vertex element collection
   */ _proto.setVertexElements = function setVertexElements(elements) {
        var customVertexElements = this._customVertexElements;
        customVertexElements.length = 0;
        var customVertexElementMap = {};
        for(var i = 0, n = elements.length; i < n; i++){
            var element = elements[i];
            customVertexElements.push(element);
            customVertexElementMap[element.semantic] = element;
        }
        if (customVertexElementMap[VertexAttribute.Position]) {
            var positions = this.getPositions();
            positions && (this._vertexBufferUpdateFlag |= 0x1);
        } else {
            this.setPositions(null);
        }
        if (customVertexElementMap[VertexAttribute.Normal]) {
            var normals = this.getNormals();
            normals && (this._vertexBufferUpdateFlag |= 0x2);
        } else {
            this.setNormals(null);
        }
        if (customVertexElementMap[VertexAttribute.Color]) {
            var colors = this.getColors();
            colors && (this._vertexBufferUpdateFlag |= 0x4);
        } else {
            this.setColors(null);
        }
        if (customVertexElementMap[VertexAttribute.BoneWeight]) {
            var boneWeights = this.getBoneWeights();
            boneWeights && (this._vertexBufferUpdateFlag |= 0x10);
        } else {
            this.setBoneWeights(null);
        }
        if (customVertexElementMap[VertexAttribute.BoneIndex]) {
            var boneIndices = this.getBoneIndices();
            boneIndices && (this._vertexBufferUpdateFlag |= 0x20);
        } else {
            this.setBoneIndices(null);
        }
        if (customVertexElementMap[VertexAttribute.Tangent]) {
            var tangents = this.getTangents();
            tangents && (this._vertexBufferUpdateFlag |= 0x8);
        } else {
            this.setTangents(null);
        }
        if (customVertexElementMap[VertexAttribute.UV]) {
            var uvs = this.getUVs(0);
            uvs && (this._vertexBufferUpdateFlag |= 0x40);
        } else {
            this.setUVs(null, 0);
        }
        if (customVertexElementMap[VertexAttribute.UV1]) {
            var uv1s = this.getUVs(1);
            uv1s && (this._vertexBufferUpdateFlag |= 0x80);
        } else {
            this.setUVs(null, 1);
        }
        if (customVertexElementMap[VertexAttribute.UV2]) {
            var uv2s = this.getUVs(2);
            uv2s && (this._vertexBufferUpdateFlag |= 0x100);
        } else {
            this.setUVs(null, 2);
        }
        if (customVertexElementMap[VertexAttribute.UV3]) {
            var uv3s = this.getUVs(3);
            uv3s && (this._vertexBufferUpdateFlag |= 0x200);
        } else {
            this.setUVs(null, 3);
        }
        if (customVertexElementMap[VertexAttribute.UV4]) {
            var uv4s = this.getUVs(4);
            uv4s && (this._vertexBufferUpdateFlag |= 0x400);
        } else {
            this.setUVs(null, 4);
        }
        if (customVertexElementMap[VertexAttribute.UV5]) {
            var uv5s = this.getUVs(5);
            uv5s && (this._vertexBufferUpdateFlag |= 0x800);
        } else {
            this.setUVs(null, 5);
        }
        if (customVertexElementMap[VertexAttribute.UV6]) {
            var uv6s = this.getUVs(6);
            uv6s && (this._vertexBufferUpdateFlag |= 0x1000);
        } else {
            this.setUVs(null, 6);
        }
        if (customVertexElementMap[VertexAttribute.UV7]) {
            var uv7s = this.getUVs(7);
            uv7s && (this._vertexBufferUpdateFlag |= 0x2000);
        } else {
            this.setUVs(null, 7);
        }
        this._vertexElementsUpdate = true;
    };
    /**
   * @beta
   * @todo Use this way to update gpu buffer should can get cpu data(may be should support get data form GPU).
   * @use `setPosition` and `setVertexBufferBinding` at the same time, thew VertexBufferBinding and Vertex buffer data should right.
   */ _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
        if (strideOrFirstIndex === void 0) strideOrFirstIndex = 0;
        if (index === void 0) index = 0;
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== undefined;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
        var bindings = this._vertexBufferBindings;
        bindings.length <= index && (bindings.length = index + 1);
        this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
        this._vertexDataUpdateFlag |= 0x1;
    };
    /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */ _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) firstIndex = 0;
        var bindings = this._vertexBufferBindings;
        var count = vertexBufferBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);
        for(var i = 0; i < count; i++){
            this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
        }
    };
    /**
   * Add a BlendShape for this ModelMesh.
   * @param blendShape - The BlendShape
   */ _proto.addBlendShape = function addBlendShape(blendShape) {
        this._blendShapeManager._addBlendShape(blendShape);
    };
    /**
   * Clear all BlendShapes.
   */ _proto.clearBlendShapes = function clearBlendShapes() {
        this._blendShapeManager._clearBlendShapes();
    };
    /**
   * Get name of BlendShape by given index.
   * @param index - The index of BlendShape
   * @returns The name of BlendShape
   */ _proto.getBlendShapeName = function getBlendShapeName(index) {
        var blendShapes = this._blendShapeManager._blendShapes;
        return blendShapes[index].name;
    };
    /**
   * Upload Mesh Data to GPU.
   * @param noLongerReadable - Whether to read data later. If true, you'll never read data anymore (free memory cache)
   */ _proto.uploadData = function uploadData(noLongerReadable) {
        var _this__vertexBufferBindings_;
        // Update vertex elements
        this._updateVertexElements();
        // Vertex count change
        var vertexBuffer = (_this__vertexBufferBindings_ = this._vertexBufferBindings[0]) == null ? void 0 : _this__vertexBufferBindings_._buffer;
        if (this._vertexCountChanged) {
            this._vertexBufferUpdateFlag = 0xffff;
            vertexBuffer == null ? void 0 : vertexBuffer.destroy();
            var elementCount = this._bufferStrides[0] / 4;
            var vertexFloatCount = elementCount * this.vertexCount;
            var vertices = new Float32Array(vertexFloatCount);
            this._verticesFloat32 = vertices;
            this._verticesUint8 = new Uint8Array(vertices.buffer);
            this._updateVertices(vertices);
            var bufferUsage = noLongerReadable ? BufferUsage.Static : BufferUsage.Dynamic;
            var newVertexBuffer = new Buffer(this._engine, BufferBindFlag.VertexBuffer, vertices, bufferUsage);
            this._setVertexBufferBinding(0, new VertexBufferBinding(newVertexBuffer, elementCount * 4));
            this._vertexCountChanged = false;
        } else {
            if (this._vertexBufferUpdateFlag & 0xffff) {
                var vertices1 = this._verticesFloat32;
                if (!vertices1) {
                    var elementCount1 = this._bufferStrides[0] / 4;
                    var vertexFloatCount1 = elementCount1 * this.vertexCount;
                    this._verticesFloat32 = vertices1 = new Float32Array(vertexFloatCount1);
                }
                this._updateVertices(vertices1);
                vertexBuffer.setData(vertices1);
            }
        }
        if (this._indicesChangeFlag) {
            var _this__indexBufferBinding;
            var _this = this, indices = _this._indices;
            var indexBuffer = (_this__indexBufferBinding = this._indexBufferBinding) == null ? void 0 : _this__indexBufferBinding._buffer;
            if (indices) {
                if (!indexBuffer || indices.byteLength != indexBuffer.byteLength) {
                    indexBuffer == null ? void 0 : indexBuffer.destroy();
                    var newIndexBuffer = new Buffer(this._engine, BufferBindFlag.IndexBuffer, indices);
                    this._setIndexBufferBinding(new IndexBufferBinding(newIndexBuffer, this._indicesFormat));
                } else {
                    indexBuffer.setData(indices);
                    if (this._indexBufferBinding._format !== this._indicesFormat) {
                        this._setIndexBufferBinding(new IndexBufferBinding(indexBuffer, this._indicesFormat));
                    }
                }
            } else if (indexBuffer) {
                indexBuffer.destroy();
                this._setIndexBufferBinding(null);
            }
            this._indicesChangeFlag = false;
        }
        var _this1 = this, blendShapeManager = _this1._blendShapeManager;
        blendShapeManager._blendShapeCount > 0 && blendShapeManager._update(this._vertexCountChanged, noLongerReadable);
        if (noLongerReadable) {
            this._readable = false;
            this._releaseCache();
        }
    };
    /**
   * Calculate mesh tangent.
   * @remark need to set positions(with or not with indices), normals, uv before calculation.
   * @remark based on http://foundationsofgameenginedev.com/FGED2-sample.pdf
   */ _proto.calculateTangents = function calculateTangents() {
        if (!this._normals || !this._uv) {
            throw "Set normal and uv before calculation.";
        }
        var _this = this, indices = _this._indices, positions = _this._positions, normals = _this._normals, uvs = _this._uv, vertexCount = _this._vertexCount;
        var e1 = ModelMesh._tempVec0, e2 = ModelMesh._tempVec1, t = ModelMesh._tempVec2, b = ModelMesh._tempVec3, temp = ModelMesh._tempVec4;
        var triangleCount = indices ? indices.length / 3 : positions.length / 3;
        var tangents = new Array(vertexCount);
        var biTangents = new Array(vertexCount);
        for(var i = 0; i < vertexCount; i++){
            tangents[i] = new Vector4();
            biTangents[i] = new Vector3();
        }
        // Calculate tangent and bi-tangent for each triangle and add to all three vertices.
        for(var k = 0; k < triangleCount; k++){
            var i0 = 3 * k;
            var i1 = 3 * k + 1;
            var i2 = 3 * k + 2;
            if (indices) {
                i0 = indices[i0];
                i1 = indices[i1];
                i2 = indices[i2];
            }
            var p0 = positions[i0];
            var p1 = positions[i1];
            var p2 = positions[i2];
            var w0 = uvs[i0];
            var w1 = uvs[i1];
            var w2 = uvs[i2];
            Vector3.subtract(p1, p0, e1);
            Vector3.subtract(p2, p0, e2);
            var x1 = w1.x - w0.x;
            var x2 = w2.x - w0.x;
            var y1 = w1.y - w0.y;
            var y2 = w2.y - w0.y;
            var r = 1.0 / (x1 * y2 - x2 * y1);
            Vector3.scale(e1, y2 * r, t);
            Vector3.scale(e2, y1 * r, temp);
            Vector3.subtract(t, temp, t);
            Vector3.scale(e2, x1 * r, b);
            Vector3.scale(e1, x2 * r, temp);
            Vector3.subtract(b, temp, b);
            var tangent = tangents[i0];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            tangent = tangents[i1];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            tangent = tangents[i2];
            tangent.set(tangent.x + t.x, tangent.y + t.y, tangent.z + t.z, 1.0);
            biTangents[i0].add(b);
            biTangents[i1].add(b);
            biTangents[i2].add(b);
        }
        // Orthonormalize each tangent and calculate the handedness.
        for(var i3 = 0; i3 < vertexCount; i3++){
            var n = normals[i3];
            var b1 = biTangents[i3];
            var tangent1 = tangents[i3];
            t.set(tangent1.x, tangent1.y, tangent1.z);
            Vector3.cross(t, b1, temp);
            var w = Vector3.dot(temp, n) > 0.0 ? 1 : -1;
            Vector3.scale(n, Vector3.dot(t, n), temp);
            Vector3.subtract(t, temp, t);
            t.normalize();
            tangent1.set(t.x, t.y, t.z, w);
        }
        this.setTangents(tangents);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Mesh.prototype._onDestroy.call(this);
        this._readable && this._releaseCache();
    };
    _proto._supplementaryVertexElements = function _supplementaryVertexElements() {
        this._clearVertexElements();
        var customVertexElements = this._customVertexElements;
        for(var i = 0, n = customVertexElements.length; i < n; i++){
            this._addVertexElement(customVertexElements[i]);
        }
        var vertexElementMap = this._vertexElementMap;
        if (this._positions && !vertexElementMap[VertexAttribute.Position]) {
            this._insertVertexAttribute(VertexAttribute.Position);
        }
        if (this._normals && !vertexElementMap[VertexAttribute.Normal]) {
            this._insertVertexAttribute(VertexAttribute.Normal);
        }
        if (this._colors && !vertexElementMap[VertexAttribute.Color]) {
            this._insertVertexAttribute(VertexAttribute.Color);
        }
        if (this._boneWeights && !vertexElementMap[VertexAttribute.BoneWeight]) {
            this._insertVertexAttribute(VertexAttribute.BoneWeight);
        }
        if (this._boneIndices && !vertexElementMap[VertexAttribute.BoneIndex]) {
            this._insertVertexAttribute(VertexAttribute.BoneIndex);
        }
        if (this._tangents && !vertexElementMap[VertexAttribute.Tangent]) {
            this._insertVertexAttribute(VertexAttribute.Tangent);
        }
        if (this._uv && !vertexElementMap[VertexAttribute.UV]) {
            this._insertVertexAttribute(VertexAttribute.UV);
        }
        if (this._uv1 && !vertexElementMap[VertexAttribute.UV1]) {
            this._insertVertexAttribute(VertexAttribute.UV1);
        }
        if (this._uv2 && !vertexElementMap[VertexAttribute.UV2]) {
            this._insertVertexAttribute(VertexAttribute.UV2);
        }
        if (this._uv3 && !vertexElementMap[VertexAttribute.UV3]) {
            this._insertVertexAttribute(VertexAttribute.UV3);
        }
        if (this._uv4 && !vertexElementMap[VertexAttribute.UV4]) {
            this._insertVertexAttribute(VertexAttribute.UV4);
        }
        if (this._uv5 && !vertexElementMap[VertexAttribute.UV5]) {
            this._insertVertexAttribute(VertexAttribute.UV5);
        }
        if (this._uv6 && !vertexElementMap[VertexAttribute.UV6]) {
            this._insertVertexAttribute(VertexAttribute.UV6);
        }
        if (this._uv7 && !vertexElementMap[VertexAttribute.UV7]) {
            this._insertVertexAttribute(VertexAttribute.UV7);
        }
    };
    _proto._updateVertexElements = function _updateVertexElements() {
        var bsManager = this._blendShapeManager;
        var bsAttributeUpdate = !bsManager._useTextureMode() && bsManager._vertexElementsNeedUpdate();
        if (this._vertexElementsUpdate || bsAttributeUpdate) {
            this._supplementaryVertexElements();
            if (bsAttributeUpdate && bsManager._blendShapeCount > 0) {
                // Reserve at least 1 placeholder to save the built-in vertex buffer
                bsManager._setAttributeModeOffsetInfo(this._vertexElements.length, this._vertexBufferBindings.length || 1);
                bsManager._addVertexElements(this);
            }
            this._vertexElementsUpdate = false;
        }
    };
    _proto._updateVertices = function _updateVertices(vertices) {
        // prettier-ignore
        var _this = this, _bufferStrides = _this._bufferStrides, _vertexCount = _this._vertexCount, _positions = _this._positions, _normals = _this._normals, _colors = _this._colors, _vertexChangeFlag = _this._vertexBufferUpdateFlag, _boneWeights = _this._boneWeights, _boneIndices = _this._boneIndices, _tangents = _this._tangents, _uv = _this._uv, _uv1 = _this._uv1, _uv2 = _this._uv2, _uv3 = _this._uv3, _uv4 = _this._uv4, _uv5 = _this._uv5, _uv6 = _this._uv6, _uv7 = _this._uv7;
        var _vertexStrideFloat = _bufferStrides[0] / 4;
        if (_vertexChangeFlag & 0x1) {
            for(var i = 0; i < _vertexCount; i++){
                var start = _vertexStrideFloat * i;
                var position = _positions[i];
                vertices[start] = position.x;
                vertices[start + 1] = position.y;
                vertices[start + 2] = position.z;
            }
        }
        var offset = 3;
        if (_normals) {
            if (_vertexChangeFlag & 0x2) {
                for(var i1 = 0; i1 < _vertexCount; i1++){
                    var start1 = _vertexStrideFloat * i1 + offset;
                    var normal = _normals[i1];
                    if (normal) {
                        vertices[start1] = normal.x;
                        vertices[start1 + 1] = normal.y;
                        vertices[start1 + 2] = normal.z;
                    }
                }
            }
            offset += 3;
        }
        if (_colors) {
            if (_vertexChangeFlag & 0x4) {
                for(var i2 = 0; i2 < _vertexCount; i2++){
                    var start2 = _vertexStrideFloat * i2 + offset;
                    var color = _colors[i2];
                    if (color) {
                        vertices[start2] = color.r;
                        vertices[start2 + 1] = color.g;
                        vertices[start2 + 2] = color.b;
                        vertices[start2 + 3] = color.a;
                    }
                }
            }
            offset += 4;
        }
        if (_boneWeights) {
            if (_vertexChangeFlag & 0x10) {
                for(var i3 = 0; i3 < _vertexCount; i3++){
                    var start3 = _vertexStrideFloat * i3 + offset;
                    var weight = _boneWeights[i3];
                    if (weight) {
                        vertices[start3] = weight.x;
                        vertices[start3 + 1] = weight.y;
                        vertices[start3 + 2] = weight.z;
                        vertices[start3 + 3] = weight.w;
                    }
                }
            }
            offset += 4;
        }
        if (_boneIndices) {
            if (_vertexChangeFlag & 0x20) {
                var _verticesUint8 = this._verticesUint8;
                for(var i4 = 0; i4 < _vertexCount; i4++){
                    var start4 = _vertexStrideFloat * i4 + offset;
                    var joint = _boneIndices[i4];
                    if (joint) {
                        var internalStart = start4 * 4;
                        _verticesUint8[internalStart] = joint.x;
                        _verticesUint8[internalStart + 1] = joint.y;
                        _verticesUint8[internalStart + 2] = joint.z;
                        _verticesUint8[internalStart + 3] = joint.w;
                    }
                }
            }
            offset += 1;
        }
        if (_tangents) {
            if (_vertexChangeFlag & 0x8) {
                for(var i5 = 0; i5 < _vertexCount; i5++){
                    var start5 = _vertexStrideFloat * i5 + offset;
                    var tangent = _tangents[i5];
                    if (tangent) {
                        vertices[start5] = tangent.x;
                        vertices[start5 + 1] = tangent.y;
                        vertices[start5 + 2] = tangent.z;
                        vertices[start5 + 3] = tangent.w;
                    }
                }
            }
            offset += 4;
        }
        if (_uv) {
            if (_vertexChangeFlag & 0x40) {
                for(var i6 = 0; i6 < _vertexCount; i6++){
                    var start6 = _vertexStrideFloat * i6 + offset;
                    var uv = _uv[i6];
                    if (uv) {
                        vertices[start6] = uv.x;
                        vertices[start6 + 1] = uv.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv1) {
            if (_vertexChangeFlag & 0x80) {
                for(var i7 = 0; i7 < _vertexCount; i7++){
                    var start7 = _vertexStrideFloat * i7 + offset;
                    var uv1 = _uv1[i7];
                    if (uv1) {
                        vertices[start7] = uv1.x;
                        vertices[start7 + 1] = uv1.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv2) {
            if (_vertexChangeFlag & 0x100) {
                for(var i8 = 0; i8 < _vertexCount; i8++){
                    var start8 = _vertexStrideFloat * i8 + offset;
                    var uv2 = _uv2[i8];
                    if (uv2) {
                        vertices[start8] = uv2.x;
                        vertices[start8 + 1] = uv2.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv3) {
            if (_vertexChangeFlag & 0x200) {
                for(var i9 = 0; i9 < _vertexCount; i9++){
                    var start9 = _vertexStrideFloat * i9 + offset;
                    var uv3 = _uv3[i9];
                    if (uv3) {
                        vertices[start9] = uv3.x;
                        vertices[start9 + 1] = uv3.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv4) {
            if (_vertexChangeFlag & 0x400) {
                for(var i10 = 0; i10 < _vertexCount; i10++){
                    var start10 = _vertexStrideFloat * i10 + offset;
                    var uv4 = _uv4[i10];
                    if (uv4) {
                        vertices[start10] = uv4.x;
                        vertices[start10 + 1] = uv4.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv5) {
            if (_vertexChangeFlag & 0x800) {
                for(var i11 = 0; i11 < _vertexCount; i11++){
                    var start11 = _vertexStrideFloat * i11 + offset;
                    var uv5 = _uv5[i11];
                    if (uv5) {
                        vertices[start11] = uv5.x;
                        vertices[start11 + 1] = uv5.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv6) {
            if (_vertexChangeFlag & 0x1000) {
                for(var i12 = 0; i12 < _vertexCount; i12++){
                    var start12 = _vertexStrideFloat * i12 + offset;
                    var uv6 = _uv6[i12];
                    if (uv6) {
                        vertices[start12] = uv6.x;
                        vertices[start12 + 1] = uv6.y;
                    }
                }
            }
            offset += 2;
        }
        if (_uv7) {
            if (_vertexChangeFlag & 0x2000) {
                for(var i13 = 0; i13 < _vertexCount; i13++){
                    var start13 = _vertexStrideFloat * i13 + offset;
                    var uv7 = _uv7[i13];
                    if (uv7) {
                        vertices[start13] = uv7.x;
                        vertices[start13 + 1] = uv7.y;
                    }
                }
            }
            offset += 2;
        }
        this._vertexBufferUpdateFlag = 0;
    };
    _proto._insertVertexAttribute = function _insertVertexAttribute(vertexAttribute) {
        var format = this._getAttributeFormat(vertexAttribute);
        var needByteLength = this._getAttributeByteLength(vertexAttribute);
        var vertexElements = this._vertexElements;
        var i = 0;
        var lastOffset = 0;
        for(var n = vertexElements.length; i < n; i++){
            var vertexElement = vertexElements[i];
            if (vertexElement.bindingIndex == 0) {
                if (vertexElement.offset - lastOffset >= needByteLength) {
                    break;
                }
                lastOffset = vertexElement.offset + this._getAttributeByteLength(vertexElement.semantic);
            }
        }
        this._insertVertexElement(i, new VertexElement(vertexAttribute, lastOffset, format, 0));
        this._bufferStrides[0] = lastOffset + needByteLength;
    };
    _proto._getAttributeFormat = function _getAttributeFormat(attribute) {
        switch(attribute){
            case VertexAttribute.Position:
                return VertexElementFormat.Vector3;
            case VertexAttribute.Normal:
                return VertexElementFormat.Vector3;
            case VertexAttribute.Color:
                return VertexElementFormat.Vector4;
            case VertexAttribute.BoneWeight:
                return VertexElementFormat.Vector4;
            case VertexAttribute.BoneIndex:
                return VertexElementFormat.UByte4;
            case VertexAttribute.Tangent:
                return VertexElementFormat.Vector4;
            case VertexAttribute.UV:
            case VertexAttribute.UV1:
            case VertexAttribute.UV2:
            case VertexAttribute.UV3:
            case VertexAttribute.UV4:
            case VertexAttribute.UV5:
            case VertexAttribute.UV6:
            case VertexAttribute.UV7:
                return VertexElementFormat.Vector2;
        }
    };
    _proto._getAttributeByteLength = function _getAttributeByteLength(attribute) {
        switch(attribute){
            case VertexAttribute.Position:
                return 12;
            case VertexAttribute.Normal:
                return 12;
            case VertexAttribute.Color:
                return 16;
            case VertexAttribute.BoneWeight:
                return 16;
            case VertexAttribute.BoneIndex:
                return 4;
            case VertexAttribute.Tangent:
                return 16;
            case VertexAttribute.UV:
            case VertexAttribute.UV1:
            case VertexAttribute.UV2:
            case VertexAttribute.UV3:
            case VertexAttribute.UV4:
            case VertexAttribute.UV5:
            case VertexAttribute.UV6:
            case VertexAttribute.UV7:
                return 8;
        }
    };
    _proto._releaseCache = function _releaseCache() {
        this._verticesUint8 = null;
        this._indices = null;
        this._verticesFloat32 = null;
        this._positions = null;
        this._tangents = null;
        this._normals = null;
        this._colors = null;
        this._uv = null;
        this._uv1 = null;
        this._uv2 = null;
        this._uv3 = null;
        this._uv4 = null;
        this._uv5 = null;
        this._uv6 = null;
        this._uv7 = null;
        this._blendShapeManager._releaseMemoryCache();
    };
    _create_class$3(ModelMesh, [
        {
            key: "readable",
            get: /**
   * Whether to read data of the mesh.
   */ function get() {
                return this._readable;
            }
        },
        {
            key: "vertexCount",
            get: /**
   * Vertex count of current mesh.
   */ function get() {
                if (this._vertexDataUpdateFlag & 0x1) {
                    var vertexCount = 0;
                    var positionElement = this._vertexElementMap[VertexAttribute.Position];
                    if (positionElement) {
                        var positionBufferBinding = this._vertexBufferBindings[positionElement.bindingIndex];
                        if (positionBufferBinding) {
                            vertexCount = positionBufferBinding.buffer.byteLength / positionBufferBinding.stride;
                        }
                    }
                    this._vertexCount = vertexCount;
                    this._vertexDataUpdateFlag &= ~0x1;
                }
                return this._vertexCount;
            }
        },
        {
            key: "vertexElements",
            get: /**
   * Vertex element collection.
   */ function get() {
                this._updateVertexElements();
                return this._vertexElements;
            }
        },
        {
            key: "vertexBufferBindings",
            get: /**
   * Vertex buffer binding collection.
   */ function get() {
                return this._vertexBufferBindings;
            }
        },
        {
            key: "blendShapes",
            get: /**
   * BlendShapes of this ModelMesh.
   */ function get() {
                return this._blendShapeManager._blendShapes;
            }
        },
        {
            key: "blendShapeCount",
            get: /**
   * BlendShape count of this ModelMesh.
   */ function get() {
                return this._blendShapeManager._blendShapeCount;
            }
        }
    ]);
    return ModelMesh;
}(Mesh);
(function() {
    ModelMesh._tempVec0 = new Vector3();
})();
(function() {
    ModelMesh._tempVec1 = new Vector3();
})();
(function() {
    ModelMesh._tempVec2 = new Vector3();
})();
(function() {
    ModelMesh._tempVec3 = new Vector3();
})();
(function() {
    ModelMesh._tempVec4 = new Vector3();
})();
var VertexChangedFlags;
(function(VertexChangedFlags) {
    VertexChangedFlags[VertexChangedFlags["Position"] = 0x1] = "Position";
    VertexChangedFlags[VertexChangedFlags["Normal"] = 0x2] = "Normal";
    VertexChangedFlags[VertexChangedFlags["Color"] = 0x4] = "Color";
    VertexChangedFlags[VertexChangedFlags["Tangent"] = 0x8] = "Tangent";
    VertexChangedFlags[VertexChangedFlags["BoneWeight"] = 0x10] = "BoneWeight";
    VertexChangedFlags[VertexChangedFlags["BoneIndex"] = 0x20] = "BoneIndex";
    VertexChangedFlags[VertexChangedFlags["UV"] = 0x40] = "UV";
    VertexChangedFlags[VertexChangedFlags["UV1"] = 0x80] = "UV1";
    VertexChangedFlags[VertexChangedFlags["UV2"] = 0x100] = "UV2";
    VertexChangedFlags[VertexChangedFlags["UV3"] = 0x200] = "UV3";
    VertexChangedFlags[VertexChangedFlags["UV4"] = 0x400] = "UV4";
    VertexChangedFlags[VertexChangedFlags["UV5"] = 0x800] = "UV5";
    VertexChangedFlags[VertexChangedFlags["UV6"] = 0x1000] = "UV6";
    VertexChangedFlags[VertexChangedFlags["UV7"] = 0x2000] = "UV7";
    VertexChangedFlags[VertexChangedFlags["All"] = 0xffff] = "All";
})(VertexChangedFlags || (VertexChangedFlags = {}));

/**
 * Mesh skin data, equal glTF skins define
 */ var Skin = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Skin, EngineObject);
    function Skin(name) {
        var _this;
        _this = EngineObject.call(this, null) || this;
        _this.name = name;
        _this.inverseBindMatrices = []; // inverse bind matrix array
        _this.joints = []; // joints name array, element type: string
        _this.skeleton = "none"; // root bone name
        return _this;
    }
    return Skin;
}(EngineObject);

/**
 * MeshRenderer Component.
 */ var MeshRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(MeshRenderer, Renderer);
    function MeshRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this;
        _this._enableVertexColor = false;
        _this._onMeshChanged = _this._onMeshChanged.bind(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = MeshRenderer.prototype;
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Renderer.prototype._onDestroy.call(this);
        var mesh = this._mesh;
        if (mesh) {
            mesh.destroyed || mesh._addReferCount(-1);
            mesh._updateFlagManager.removeListener(this._onMeshChanged);
            this._mesh = null;
        }
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        Renderer.prototype._cloneTo.call(this, target);
        target.mesh = this._mesh;
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        var mesh = this._mesh;
        if (mesh) {
            var localBounds = mesh.bounds;
            var worldMatrix = this._entity.transform.worldMatrix;
            BoundingBox.transform(localBounds, worldMatrix, worldBounds);
        } else {
            worldBounds.min.set(0, 0, 0);
            worldBounds.max.set(0, 0, 0);
        }
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        var mesh = this._mesh;
        if (mesh) {
            if (this._dirtyUpdateFlag & 0x2) {
                var shaderData = this.shaderData;
                var vertexElements = mesh._vertexElements;
                shaderData.disableMacro(MeshRenderer._uvMacro);
                shaderData.disableMacro(MeshRenderer._uv1Macro);
                shaderData.disableMacro(MeshRenderer._normalMacro);
                shaderData.disableMacro(MeshRenderer._tangentMacro);
                shaderData.disableMacro(MeshRenderer._enableVertexColorMacro);
                for(var i = 0, n = vertexElements.length; i < n; i++){
                    switch(vertexElements[i].semantic){
                        case "TEXCOORD_0":
                            shaderData.enableMacro(MeshRenderer._uvMacro);
                            break;
                        case "TEXCOORD_1":
                            shaderData.enableMacro(MeshRenderer._uv1Macro);
                            break;
                        case "NORMAL":
                            shaderData.enableMacro(MeshRenderer._normalMacro);
                            break;
                        case "TANGENT":
                            shaderData.enableMacro(MeshRenderer._tangentMacro);
                            break;
                        case "COLOR_0":
                            this._enableVertexColor && shaderData.enableMacro(MeshRenderer._enableVertexColorMacro);
                            break;
                    }
                }
                this._dirtyUpdateFlag &= ~0x2;
            }
            var materials = this._materials;
            var subMeshes = mesh.subMeshes;
            var renderPipeline = context.camera._renderPipeline;
            var meshRenderDataPool = this._engine._meshRenderDataPool;
            for(var i1 = 0, n1 = subMeshes.length; i1 < n1; i1++){
                var material = materials[i1];
                if (!material) continue;
                var renderData = meshRenderDataPool.getFromPool();
                renderData.set(this, material, mesh, subMeshes[i1]);
                renderPipeline.pushRenderData(context, renderData);
            }
        } else {
            Logger.error("mesh is null.");
        }
    };
    _proto._setMesh = function _setMesh(mesh) {
        var lastMesh = this._mesh;
        if (lastMesh) {
            lastMesh._addReferCount(-1);
            lastMesh._updateFlagManager.removeListener(this._onMeshChanged);
        }
        if (mesh) {
            mesh._addReferCount(1);
            mesh._updateFlagManager.addListener(this._onMeshChanged);
            this._dirtyUpdateFlag |= 0x3;
        }
        this._mesh = mesh;
    };
    _proto._onMeshChanged = function _onMeshChanged(type) {
        type & MeshModifyFlags.Bounds && (this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume);
        type & MeshModifyFlags.VertexElements && (this._dirtyUpdateFlag |= 0x2);
    };
    _create_class$3(MeshRenderer, [
        {
            key: "mesh",
            get: /**
   * Mesh assigned to the renderer.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                if (this._mesh !== value) {
                    this._setMesh(value);
                }
            }
        },
        {
            key: "enableVertexColor",
            get: /**
   * Whether enable vertex color.
   */ function get() {
                return this._enableVertexColor;
            },
            set: function set(value) {
                if (value !== this._enableVertexColor) {
                    this._dirtyUpdateFlag |= 0x2;
                    this._enableVertexColor = value;
                }
            }
        }
    ]);
    return MeshRenderer;
}(Renderer);
(function() {
    MeshRenderer._uvMacro = ShaderMacro.getByName("RENDERER_HAS_UV");
})();
(function() {
    MeshRenderer._uv1Macro = ShaderMacro.getByName("RENDERER_HAS_UV1");
})();
(function() {
    MeshRenderer._normalMacro = ShaderMacro.getByName("RENDERER_HAS_NORMAL");
})();
(function() {
    MeshRenderer._tangentMacro = ShaderMacro.getByName("RENDERER_HAS_TANGENT");
})();
(function() {
    MeshRenderer._enableVertexColorMacro = ShaderMacro.getByName("RENDERER_ENABLE_VERTEXCOLOR");
})();
__decorate$1([
    ignoreClone
], MeshRenderer.prototype, "_mesh", void 0);
__decorate$1([
    ignoreClone
], MeshRenderer.prototype, "_onMeshChanged", null);
var /**
 * @remarks Extends `RendererUpdateFlag`.
 */ MeshRendererUpdateFlags;
(function(MeshRendererUpdateFlags) {
    MeshRendererUpdateFlags[MeshRendererUpdateFlags[/** VertexElementMacro. */ "VertexElementMacro"] = 0x2] = "VertexElementMacro";
    MeshRendererUpdateFlags[MeshRendererUpdateFlags[/** All. */ "All"] = 0x3] = "All";
})(MeshRendererUpdateFlags || (MeshRendererUpdateFlags = {}));

/**
 * SkinnedMeshRenderer.
 */ var SkinnedMeshRenderer = /*#__PURE__*/ function(MeshRenderer) {
    _inherits$2(SkinnedMeshRenderer, MeshRenderer);
    function SkinnedMeshRenderer(entity) {
        var _this;
        _this = MeshRenderer.call(this, entity) || this;
        _this._hasInitSkin = false;
        _this._jointDataCreateCache = new Vector2(-1, -1);
        _this._localBounds = new BoundingBox();
        _this._skin = null;
        var rhi = _this.entity.engine._hardwareRenderer;
        var maxVertexUniformVectors = rhi.renderStates.getParameter(rhi.gl.MAX_VERTEX_UNIFORM_VECTORS);
        // Limit size to 256 to avoid some problem:
        // For renderer is "Apple GPU", when uniform is large than 256 the skeleton matrix array access in shader very slow in Safari or WKWebview. This may be a apple bug, Chrome and Firefox is OK!
        // For renderer is "ANGLE (AMD, AMD Radeon(TM) Graphics Direct3011 vs_5_0 ps_5_0, D3011)", compile shader si very slow because of max uniform is 4096.
        maxVertexUniformVectors = Math.min(maxVertexUniformVectors, rhi._options._maxAllowSkinUniformVectorCount);
        _this._maxVertexUniformVectors = maxVertexUniformVectors;
        _this._onLocalBoundsChanged = _this._onLocalBoundsChanged.bind(_assert_this_initialized(_this));
        var localBounds = _this._localBounds;
        // @ts-ignore
        localBounds.min._onValueChanged = _this._onLocalBoundsChanged;
        // @ts-ignore
        localBounds.max._onValueChanged = _this._onLocalBoundsChanged;
        return _this;
    }
    var _proto = SkinnedMeshRenderer.prototype;
    /**
   * @internal
   */ _proto.update = function update() {
        if (!this._hasInitSkin) {
            this._initSkin();
            this._hasInitSkin = true;
        }
        var skin = this._skin;
        if (skin) {
            var ibms = skin.inverseBindMatrices;
            var worldToLocal = this._rootBone.getInvModelMatrix();
            var _this = this, joints = _this._jointEntities, jointMatrices = _this._jointMatrices;
            for(var i = joints.length - 1; i >= 0; i--){
                var joint = joints[i];
                var offset = i * 16;
                if (joint) {
                    Utils._floatMatrixMultiply(joint.transform.worldMatrix, ibms[i].elements, 0, jointMatrices, offset);
                } else {
                    jointMatrices.set(ibms[i].elements, offset);
                }
                Utils._floatMatrixMultiply(worldToLocal, jointMatrices, offset, jointMatrices, offset);
            }
        }
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(context) {
        var entity = this.entity;
        var worldMatrix = this._rootBone ? this._rootBone.transform.worldMatrix : entity.transform.worldMatrix;
        this._updateTransformShaderData(context, worldMatrix);
        var shaderData = this.shaderData;
        var mesh = this.mesh;
        var blendShapeManager = mesh._blendShapeManager;
        blendShapeManager._updateShaderData(shaderData, this);
        var skin = this._skin;
        if (skin) {
            var bsUniformOccupiesCount = blendShapeManager._uniformOccupiesCount;
            var jointCount = skin.joints.length;
            var jointDataCreateCache = this._jointDataCreateCache;
            var jointCountChange = jointCount !== jointDataCreateCache.x;
            if (jointCountChange || bsUniformOccupiesCount !== jointDataCreateCache.y) {
                // directly use max joint count to avoid shader recompile
                // @TODO: different shader type should use different count, not always 44
                var remainUniformJointCount = Math.ceil((this._maxVertexUniformVectors - (44 + bsUniformOccupiesCount)) / 4);
                if (jointCount > remainUniformJointCount) {
                    var engine = this.engine;
                    if (engine._hardwareRenderer.canIUseMoreJoints) {
                        if (jointCountChange) {
                            var _this__jointTexture;
                            (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
                            this._jointTexture = new Texture2D(engine, 4, jointCount, TextureFormat.R32G32B32A32, false);
                            this._jointTexture.filterMode = TextureFilterMode.Point;
                            this._jointTexture.isGCIgnored = true;
                        }
                        shaderData.disableMacro("RENDERER_JOINTS_NUM");
                        shaderData.enableMacro("RENDERER_USE_JOINT_TEXTURE");
                        shaderData.setTexture(SkinnedMeshRenderer._jointSamplerProperty, this._jointTexture);
                    } else {
                        Logger.error("component's joints count(" + jointCount + ") greater than device's MAX_VERTEX_UNIFORM_VECTORS number " + this._maxVertexUniformVectors + ", and don't support jointTexture in this device. suggest joint count less than " + remainUniformJointCount + ".", this);
                    }
                } else {
                    var _this__jointTexture1;
                    (_this__jointTexture1 = this._jointTexture) == null ? void 0 : _this__jointTexture1.destroy();
                    shaderData.disableMacro("RENDERER_USE_JOINT_TEXTURE");
                    shaderData.enableMacro("RENDERER_JOINTS_NUM", remainUniformJointCount.toString());
                    shaderData.setFloatArray(SkinnedMeshRenderer._jointMatrixProperty, this._jointMatrices);
                }
                jointDataCreateCache.set(jointCount, bsUniformOccupiesCount);
            }
            if (this._jointTexture) {
                this._jointTexture.setPixelBuffer(this._jointMatrices);
            }
        }
        var layer = entity.layer;
        this._rendererLayer.set(layer & 65535, layer >>> 16 & 65535, 0, 0);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        var _this__rootBone, _this__jointTexture;
        MeshRenderer.prototype._onDestroy.call(this);
        (_this__rootBone = this._rootBone) == null ? void 0 : _this__rootBone.transform._updateFlagManager.removeListener(this._onTransformChanged);
        this._rootBone = null;
        this._jointDataCreateCache = null;
        this._skin = null;
        this._blendShapeWeights = null;
        this._localBounds = null;
        this._jointMatrices = null;
        (_this__jointTexture = this._jointTexture) == null ? void 0 : _this__jointTexture.destroy();
        this._jointTexture = null;
        if (this._jointEntities) {
            this._jointEntities.length = 0;
            this._jointEntities = null;
        }
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        MeshRenderer.prototype._cloneTo.call(this, target);
        this._blendShapeWeights && (target._blendShapeWeights = this._blendShapeWeights.slice());
    };
    /**
   * @internal
   */ _proto._registerEntityTransformListener = function _registerEntityTransformListener() {
    // Cancel register listener to entity transform.
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        if (this._rootBone) {
            var localBounds = this._localBounds;
            var worldMatrix = this._rootBone.transform.worldMatrix;
            BoundingBox.transform(localBounds, worldMatrix, worldBounds);
        } else {
            MeshRenderer.prototype._updateBounds.call(this, worldBounds);
        }
    };
    _proto._initSkin = function _initSkin() {
        var rhi = this.entity.engine._hardwareRenderer;
        if (!rhi) return;
        var _this = this, skin = _this._skin, shaderData = _this.shaderData;
        if (!skin) {
            shaderData.disableMacro("RENDERER_HAS_SKIN");
            return;
        }
        var joints = skin.joints;
        var jointCount = joints.length;
        var jointEntities = new Array(jointCount);
        for(var i = jointCount - 1; i >= 0; i--){
            jointEntities[i] = this._findByEntityName(this.entity, joints[i]);
        }
        this._jointEntities = jointEntities;
        this._jointMatrices = new Float32Array(jointCount * 16);
        var lastRootBone = this._rootBone;
        var rootBone = this._findByEntityName(this.entity, skin.skeleton);
        lastRootBone && lastRootBone.transform._updateFlagManager.removeListener(this._onTransformChanged);
        rootBone.transform._updateFlagManager.addListener(this._onTransformChanged);
        var rootIndex = joints.indexOf(skin.skeleton);
        if (rootIndex !== -1) {
            BoundingBox.transform(this._mesh.bounds, skin.inverseBindMatrices[rootIndex], this._localBounds);
        } else {
            // Root bone is not in joints list, we can only compute approximate inverse bind matrix
            // Average all root bone's children inverse bind matrix
            var approximateBindMatrix = new Matrix(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var subRootBoneCount = this._computeApproximateBindMatrix(jointEntities, skin.inverseBindMatrices, rootBone, approximateBindMatrix);
            if (subRootBoneCount !== 0) {
                Matrix.multiplyScalar(approximateBindMatrix, 1.0 / subRootBoneCount, approximateBindMatrix);
                BoundingBox.transform(this._mesh.bounds, approximateBindMatrix, this._localBounds);
            } else {
                this._localBounds.copyFrom(this._mesh.bounds);
            }
        }
        this._rootBone = rootBone;
        if (jointCount) {
            shaderData.enableMacro("RENDERER_HAS_SKIN");
            shaderData.setInt(SkinnedMeshRenderer._jointCountProperty, jointCount);
        } else {
            shaderData.disableMacro("RENDERER_HAS_SKIN");
        }
    };
    _proto._computeApproximateBindMatrix = function _computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootEntity, approximateBindMatrix) {
        var subRootBoneCount = 0;
        var children = rootEntity.children;
        for(var i = 0, n = children.length; i < n; i++){
            var rootChild = children[i];
            var index = jointEntities.indexOf(rootChild);
            if (index !== -1) {
                Matrix.add(approximateBindMatrix, inverseBindMatrices[index], approximateBindMatrix);
                subRootBoneCount++;
            } else {
                subRootBoneCount += this._computeApproximateBindMatrix(jointEntities, inverseBindMatrices, rootChild, approximateBindMatrix);
            }
        }
        return subRootBoneCount;
    };
    _proto._findByEntityName = function _findByEntityName(rootEntity, name) {
        if (!rootEntity) {
            return null;
        }
        var result = rootEntity.findByName(name);
        if (result) {
            return result;
        }
        return this._findByEntityName(rootEntity.parent, name);
    };
    _proto._checkBlendShapeWeightLength = function _checkBlendShapeWeightLength() {
        var mesh = this._mesh;
        var newBlendShapeCount = mesh ? mesh.blendShapeCount : 0;
        var lastBlendShapeWeights = this._blendShapeWeights;
        if (lastBlendShapeWeights) {
            var lastBlendShapeWeightsCount = lastBlendShapeWeights.length;
            if (lastBlendShapeWeightsCount !== newBlendShapeCount) {
                var newBlendShapeWeights = new Float32Array(newBlendShapeCount);
                if (newBlendShapeCount > lastBlendShapeWeightsCount) {
                    newBlendShapeWeights.set(lastBlendShapeWeights);
                } else {
                    for(var i = 0; i < newBlendShapeCount; i++){
                        newBlendShapeWeights[i] = lastBlendShapeWeights[i];
                    }
                }
                this._blendShapeWeights = newBlendShapeWeights;
            }
        } else {
            this._blendShapeWeights = new Float32Array(newBlendShapeCount);
        }
    };
    _proto._onLocalBoundsChanged = function _onLocalBoundsChanged() {
        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
    };
    _create_class$3(SkinnedMeshRenderer, [
        {
            key: "blendShapeWeights",
            get: /**
   * The weights of the BlendShapes.
   * @remarks Array index is BlendShape index.
   */ function get() {
                this._checkBlendShapeWeightLength();
                return this._blendShapeWeights;
            },
            set: function set(value) {
                this._checkBlendShapeWeightLength();
                var blendShapeWeights = this._blendShapeWeights;
                if (value.length <= blendShapeWeights.length) {
                    blendShapeWeights.set(value);
                } else {
                    for(var i = 0, n = blendShapeWeights.length; i < n; i++){
                        blendShapeWeights[i] = value[i];
                    }
                }
            }
        },
        {
            key: "skin",
            get: /**
   * Skin Object.
   */ function get() {
                return this._skin;
            },
            set: function set(value) {
                if (this._skin !== value) {
                    this._skin = value;
                    this._hasInitSkin = false;
                }
            }
        },
        {
            key: "localBounds",
            get: /**
   * Local bounds.
   */ function get() {
                return this._localBounds;
            },
            set: function set(value) {
                if (this._localBounds !== value) {
                    this._localBounds.copyFrom(value);
                }
            }
        },
        {
            key: "rootBone",
            get: /**
   * Root bone.
   */ function get() {
                return this._rootBone;
            },
            set: function set(value) {
                this._skin.skeleton = value.name;
                this._hasInitSkin = false;
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
            }
        }
    ]);
    return SkinnedMeshRenderer;
}(MeshRenderer);
(function() {
    SkinnedMeshRenderer._jointCountProperty = ShaderProperty.getByName("renderer_JointCount");
})();
(function() {
    SkinnedMeshRenderer._jointSamplerProperty = ShaderProperty.getByName("renderer_JointSampler");
})();
(function() {
    SkinnedMeshRenderer._jointMatrixProperty = ShaderProperty.getByName("renderer_JointMatrix");
})();
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_hasInitSkin", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointDataCreateCache", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_blendShapeWeights", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_maxVertexUniformVectors", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_rootBone", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_localBounds", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointMatrices", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointTexture", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_jointEntities", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_condensedBlendShapeWeights", void 0);
__decorate$1([
    ignoreClone
], SkinnedMeshRenderer.prototype, "_onLocalBoundsChanged", null);

/**
 * @internal
 */ var PrimitiveMeshRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits$2(PrimitiveMeshRestorer, ContentRestorer);
    function PrimitiveMeshRestorer(resource, primitiveInfo) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.primitiveInfo = primitiveInfo;
        return _this;
    }
    var _proto = PrimitiveMeshRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var primitiveInfo = this.primitiveInfo;
        switch(primitiveInfo.type){
            case 0:
                var sphereInfo = primitiveInfo;
                PrimitiveMesh._setSphereData(this.resource, sphereInfo.radius, sphereInfo.segments, sphereInfo.noLongerAccessible, true);
                break;
            case 1:
                var cuboidInfo = primitiveInfo;
                PrimitiveMesh._setCuboidData(this.resource, cuboidInfo.width, cuboidInfo.height, cuboidInfo.depth, cuboidInfo.noLongerAccessible, true);
                break;
            case 2:
                var planeInfo = primitiveInfo;
                PrimitiveMesh._setPlaneData(this.resource, planeInfo.width, planeInfo.height, planeInfo.horizontalSegments, planeInfo.verticalSegments, planeInfo.noLongerAccessible, true);
                break;
            case 3:
                var cylinderInfo = primitiveInfo;
                PrimitiveMesh._setCylinderData(this.resource, cylinderInfo.radiusTop, cylinderInfo.radiusBottom, cylinderInfo.height, cylinderInfo.radialSegments, cylinderInfo.heightSegments, cylinderInfo.noLongerAccessible, true);
                break;
            case 4:
                var torusInfo = primitiveInfo;
                PrimitiveMesh._setTorusData(this.resource, torusInfo.radius, torusInfo.tubeRadius, torusInfo.radialSegments, torusInfo.tubularSegments, torusInfo.arc, torusInfo.noLongerAccessible, true);
                break;
            case 5:
                var coneInfo = primitiveInfo;
                PrimitiveMesh._setConeData(this.resource, coneInfo.radius, coneInfo.height, coneInfo.radialSegments, coneInfo.heightSegments, coneInfo.noLongerAccessible, true);
                break;
            case 6:
                var capsuleInfo = primitiveInfo;
                PrimitiveMesh._setCapsuleData(this.resource, capsuleInfo.radius, capsuleInfo.height, capsuleInfo.radialSegments, capsuleInfo.heightSegments, capsuleInfo.noLongerAccessible, true);
                break;
        }
    };
    return PrimitiveMeshRestorer;
}(ContentRestorer);
var PrimitiveType;
(function(PrimitiveType) {
    PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
    PrimitiveType[PrimitiveType["Cuboid"] = 1] = "Cuboid";
    PrimitiveType[PrimitiveType["Plane"] = 2] = "Plane";
    PrimitiveType[PrimitiveType["Cylinder"] = 3] = "Cylinder";
    PrimitiveType[PrimitiveType["Torus"] = 4] = "Torus";
    PrimitiveType[PrimitiveType["Cone"] = 5] = "Cone";
    PrimitiveType[PrimitiveType["Capsule"] = 6] = "Capsule";
})(PrimitiveType || (PrimitiveType = {}));
/**
 * @internal
 */ var PrimitiveRestoreInfo = function PrimitiveRestoreInfo(type, noLongerAccessible) {
    this.type = type;
    this.noLongerAccessible = noLongerAccessible;
};
/**
 * @internal
 */ var SphereRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(SphereRestoreInfo, PrimitiveRestoreInfo);
    function SphereRestoreInfo(radius, segments, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 0, noLongerAccessible) || this;
        _this.radius = radius;
        _this.segments = segments;
        return _this;
    }
    return SphereRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CuboidRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CuboidRestoreInfo, PrimitiveRestoreInfo);
    function CuboidRestoreInfo(width, height, depth, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 1, noLongerAccessible) || this;
        _this.width = width;
        _this.height = height;
        _this.depth = depth;
        return _this;
    }
    return CuboidRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var PlaneRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(PlaneRestoreInfo, PrimitiveRestoreInfo);
    function PlaneRestoreInfo(width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 2, noLongerAccessible) || this;
        _this.width = width;
        _this.height = height;
        _this.horizontalSegments = horizontalSegments;
        _this.verticalSegments = verticalSegments;
        return _this;
    }
    return PlaneRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CylinderRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CylinderRestoreInfo, PrimitiveRestoreInfo);
    function CylinderRestoreInfo(radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 3, noLongerAccessible) || this;
        _this.radiusTop = radiusTop;
        _this.radiusBottom = radiusBottom;
        _this.height = height;
        _this.radialSegments = radialSegments;
        _this.heightSegments = heightSegments;
        return _this;
    }
    return CylinderRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var TorusRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(TorusRestoreInfo, PrimitiveRestoreInfo);
    function TorusRestoreInfo(radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 4, noLongerAccessible) || this;
        _this.radius = radius;
        _this.tubeRadius = tubeRadius;
        _this.radialSegments = radialSegments;
        _this.tubularSegments = tubularSegments;
        _this.arc = arc;
        return _this;
    }
    return TorusRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var ConeRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(ConeRestoreInfo, PrimitiveRestoreInfo);
    function ConeRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 5, noLongerAccessible) || this;
        _this.radius = radius;
        _this.height = height;
        _this.radialSegments = radialSegments;
        _this.heightSegments = heightSegments;
        return _this;
    }
    return ConeRestoreInfo;
}(PrimitiveRestoreInfo);
/**
 * @internal
 */ var CapsuleRestoreInfo = /*#__PURE__*/ function(PrimitiveRestoreInfo) {
    _inherits$2(CapsuleRestoreInfo, PrimitiveRestoreInfo);
    function CapsuleRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible) {
        var _this;
        _this = PrimitiveRestoreInfo.call(this, 6, noLongerAccessible) || this;
        _this.radius = radius;
        _this.height = height;
        _this.radialSegments = radialSegments;
        _this.heightSegments = heightSegments;
        return _this;
    }
    return CapsuleRestoreInfo;
}(PrimitiveRestoreInfo);

/**
 * Used to generate common primitive meshes.
 */ var PrimitiveMesh = /*#__PURE__*/ function() {
    function PrimitiveMesh() {}
    /**
   * Create a sphere mesh.
   * @param engine - Engine
   * @param radius - Sphere radius
   * @param segments - Number of segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Sphere model mesh
   */ PrimitiveMesh.createSphere = function createSphere(engine, radius, segments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (segments === void 0) segments = 18;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var sphereMesh = new ModelMesh(engine);
        PrimitiveMesh._setSphereData(sphereMesh, radius, segments, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(sphereMesh, new SphereRestoreInfo(radius, segments, noLongerAccessible)));
        return sphereMesh;
    };
    /**
   * Create a cuboid mesh.
   * @param engine - Engine
   * @param width - Cuboid width
   * @param height - Cuboid height
   * @param depth - Cuboid depth
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cuboid model mesh
   */ PrimitiveMesh.createCuboid = function createCuboid(engine, width, height, depth, noLongerAccessible) {
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (depth === void 0) depth = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCuboidData(mesh, width, height, depth, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CuboidRestoreInfo(width, height, depth, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a plane mesh.
   * @param engine - Engine
   * @param width - Plane width
   * @param height - Plane height
   * @param horizontalSegments - Plane horizontal segments
   * @param verticalSegments - Plane vertical segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Plane model mesh
   */ PrimitiveMesh.createPlane = function createPlane(engine, width, height, horizontalSegments, verticalSegments, noLongerAccessible) {
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (horizontalSegments === void 0) horizontalSegments = 1;
        if (verticalSegments === void 0) verticalSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setPlaneData(mesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new PlaneRestoreInfo(width, height, horizontalSegments, verticalSegments, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a cylinder mesh.
   * @param engine - Engine
   * @param radiusTop - The radius of top cap
   * @param radiusBottom - The radius of bottom cap
   * @param height - The height of torso
   * @param radialSegments - Cylinder radial segments
   * @param heightSegments - Cylinder height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cylinder model mesh
   */ PrimitiveMesh.createCylinder = function createCylinder(engine, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radiusTop === void 0) radiusTop = 0.5;
        if (radiusBottom === void 0) radiusBottom = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCylinderData(mesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CylinderRestoreInfo(radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a torus mesh.
   * @param engine - Engine
   * @param radius - Torus radius
   * @param tubeRadius - Torus tube
   * @param radialSegments - Torus radial segments
   * @param tubularSegments - Torus tubular segments
   * @param arc - Central angle
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Torus model mesh
   */ PrimitiveMesh.createTorus = function createTorus(engine, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (tubeRadius === void 0) tubeRadius = 0.1;
        if (radialSegments === void 0) radialSegments = 30;
        if (tubularSegments === void 0) tubularSegments = 30;
        if (arc === void 0) arc = 360;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setTorusData(mesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new TorusRestoreInfo(radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a cone mesh.
   * @param engine - Engine
   * @param radius - The radius of cap
   * @param height - The height of torso
   * @param radialSegments - Cone radial segments
   * @param heightSegments - Cone height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Cone model mesh
   */ PrimitiveMesh.createCone = function createCone(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setConeData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new ConeRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible)));
        return mesh;
    };
    /**
   * Create a capsule mesh.
   * @param engine - Engine
   * @param radius - The radius of the two hemispherical ends
   * @param height - The height of the cylindrical part, measured between the centers of the hemispherical ends
   * @param radialSegments - Hemispherical end radial segments
   * @param heightSegments - Cylindrical part height segments
   * @param noLongerAccessible - No longer access the vertices of the mesh after creation
   * @returns Capsule model mesh
   */ PrimitiveMesh.createCapsule = function createCapsule(engine, radius, height, radialSegments, heightSegments, noLongerAccessible) {
        if (radius === void 0) radius = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 6;
        if (heightSegments === void 0) heightSegments = 1;
        if (noLongerAccessible === void 0) noLongerAccessible = true;
        var mesh = new ModelMesh(engine);
        PrimitiveMesh._setCapsuleData(mesh, radius, height, radialSegments, heightSegments, noLongerAccessible, false);
        engine.resourceManager.addContentRestorer(new PrimitiveMeshRestorer(mesh, new CapsuleRestoreInfo(radius, height, radialSegments, heightSegments, noLongerAccessible)));
        return mesh;
    };
    /**
   * @internal
   */ PrimitiveMesh._setSphereData = function _setSphereData(sphereMesh, radius, segments, noLongerAccessible, isRestoreMode) {
        segments = Math.max(2, Math.floor(segments));
        var count = segments + 1;
        var vertexCount = count * count;
        var rectangleCount = segments * segments;
        var indices = PrimitiveMesh._generateIndices(sphereMesh.engine, vertexCount, rectangleCount * 6);
        var thetaRange = Math.PI;
        var alphaRange = thetaRange * 2;
        var countReciprocal = 1.0 / count;
        var segmentsReciprocal = 1.0 / segments;
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        for(var i = 0; i < vertexCount; ++i){
            var x = i % count;
            var y = i * countReciprocal | 0;
            var u = x * segmentsReciprocal;
            var v = y * segmentsReciprocal;
            var alphaDelta = u * alphaRange;
            var thetaDelta = v * thetaRange;
            var sinTheta = Math.sin(thetaDelta);
            var posX = -radius * Math.cos(alphaDelta) * sinTheta;
            var posY = radius * Math.cos(thetaDelta);
            var posZ = radius * Math.sin(alphaDelta) * sinTheta;
            // Position
            positions[i] = new Vector3(posX, posY, posZ);
            // Normal
            normals[i] = new Vector3(posX, posY, posZ);
            // TexCoord
            uvs[i] = new Vector2(u, v);
        }
        var offset = 0;
        for(var i1 = 0; i1 < rectangleCount; ++i1){
            var x1 = i1 % segments;
            var y1 = i1 * segmentsReciprocal | 0;
            var a = y1 * count + x1;
            var b = a + 1;
            var c = a + count;
            var d = c + 1;
            indices[offset++] = b;
            indices[offset++] = a;
            indices[offset++] = d;
            indices[offset++] = a;
            indices[offset++] = c;
            indices[offset++] = d;
        }
        if (!isRestoreMode) {
            var bounds = sphereMesh.bounds;
            bounds.min.set(-radius, -radius, -radius);
            bounds.max.set(radius, radius, radius);
        }
        PrimitiveMesh._initialize(sphereMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    /**
   * @internal
   */ PrimitiveMesh._setCuboidData = function _setCuboidData(cuboidMesh, width, height, depth, noLongerAccessible, isRestoreMode) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfDepth = depth / 2;
        var positions = new Array(24);
        var normals = new Array(24);
        var uvs = new Array(24);
        // Up
        positions[0] = new Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[1] = new Vector3(halfWidth, halfHeight, -halfDepth);
        positions[2] = new Vector3(halfWidth, halfHeight, halfDepth);
        positions[3] = new Vector3(-halfWidth, halfHeight, halfDepth);
        normals[0] = new Vector3(0, 1, 0);
        normals[1] = new Vector3(0, 1, 0);
        normals[2] = new Vector3(0, 1, 0);
        normals[3] = new Vector3(0, 1, 0);
        uvs[0] = new Vector2(0, 0);
        uvs[1] = new Vector2(1, 0);
        uvs[2] = new Vector2(1, 1);
        uvs[3] = new Vector2(0, 1);
        // Down
        positions[4] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
        positions[5] = new Vector3(halfWidth, -halfHeight, -halfDepth);
        positions[6] = new Vector3(halfWidth, -halfHeight, halfDepth);
        positions[7] = new Vector3(-halfWidth, -halfHeight, halfDepth);
        normals[4] = new Vector3(0, -1, 0);
        normals[5] = new Vector3(0, -1, 0);
        normals[6] = new Vector3(0, -1, 0);
        normals[7] = new Vector3(0, -1, 0);
        uvs[4] = new Vector2(0, 1);
        uvs[5] = new Vector2(1, 1);
        uvs[6] = new Vector2(1, 0);
        uvs[7] = new Vector2(0, 0);
        // Left
        positions[8] = new Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[9] = new Vector3(-halfWidth, halfHeight, halfDepth);
        positions[10] = new Vector3(-halfWidth, -halfHeight, halfDepth);
        positions[11] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
        normals[8] = new Vector3(-1, 0, 0);
        normals[9] = new Vector3(-1, 0, 0);
        normals[10] = new Vector3(-1, 0, 0);
        normals[11] = new Vector3(-1, 0, 0);
        uvs[8] = new Vector2(0, 0);
        uvs[9] = new Vector2(1, 0);
        uvs[10] = new Vector2(1, 1);
        uvs[11] = new Vector2(0, 1);
        // Right
        positions[12] = new Vector3(halfWidth, halfHeight, -halfDepth);
        positions[13] = new Vector3(halfWidth, halfHeight, halfDepth);
        positions[14] = new Vector3(halfWidth, -halfHeight, halfDepth);
        positions[15] = new Vector3(halfWidth, -halfHeight, -halfDepth);
        normals[12] = new Vector3(1, 0, 0);
        normals[13] = new Vector3(1, 0, 0);
        normals[14] = new Vector3(1, 0, 0);
        normals[15] = new Vector3(1, 0, 0);
        uvs[12] = new Vector2(1, 0);
        uvs[13] = new Vector2(0, 0);
        uvs[14] = new Vector2(0, 1);
        uvs[15] = new Vector2(1, 1);
        // Front
        positions[16] = new Vector3(-halfWidth, halfHeight, halfDepth);
        positions[17] = new Vector3(halfWidth, halfHeight, halfDepth);
        positions[18] = new Vector3(halfWidth, -halfHeight, halfDepth);
        positions[19] = new Vector3(-halfWidth, -halfHeight, halfDepth);
        normals[16] = new Vector3(0, 0, 1);
        normals[17] = new Vector3(0, 0, 1);
        normals[18] = new Vector3(0, 0, 1);
        normals[19] = new Vector3(0, 0, 1);
        uvs[16] = new Vector2(0, 0);
        uvs[17] = new Vector2(1, 0);
        uvs[18] = new Vector2(1, 1);
        uvs[19] = new Vector2(0, 1);
        // Back
        positions[20] = new Vector3(-halfWidth, halfHeight, -halfDepth);
        positions[21] = new Vector3(halfWidth, halfHeight, -halfDepth);
        positions[22] = new Vector3(halfWidth, -halfHeight, -halfDepth);
        positions[23] = new Vector3(-halfWidth, -halfHeight, -halfDepth);
        normals[20] = new Vector3(0, 0, -1);
        normals[21] = new Vector3(0, 0, -1);
        normals[22] = new Vector3(0, 0, -1);
        normals[23] = new Vector3(0, 0, -1);
        uvs[20] = new Vector2(1, 0);
        uvs[21] = new Vector2(0, 0);
        uvs[22] = new Vector2(0, 1);
        uvs[23] = new Vector2(1, 1);
        var indices = new Uint16Array(36);
        // prettier-ignore
        // Up
        indices[0] = 0, indices[1] = 2, indices[2] = 1, indices[3] = 2, indices[4] = 0, indices[5] = 3, // Down
        indices[6] = 4, indices[7] = 6, indices[8] = 7, indices[9] = 6, indices[10] = 4, indices[11] = 5, // Left
        indices[12] = 8, indices[13] = 10, indices[14] = 9, indices[15] = 10, indices[16] = 8, indices[17] = 11, // Right
        indices[18] = 12, indices[19] = 14, indices[20] = 15, indices[21] = 14, indices[22] = 12, indices[23] = 13, // Front
        indices[24] = 16, indices[25] = 18, indices[26] = 17, indices[27] = 18, indices[28] = 16, indices[29] = 19, // Back
        indices[30] = 20, indices[31] = 22, indices[32] = 23, indices[33] = 22, indices[34] = 20, indices[35] = 21;
        if (!isRestoreMode) {
            var bounds = cuboidMesh.bounds;
            bounds.min.set(-halfWidth, -halfHeight, -halfDepth);
            bounds.max.set(halfWidth, halfHeight, halfDepth);
        }
        PrimitiveMesh._initialize(cuboidMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    /**
   * @internal
   */ PrimitiveMesh._setPlaneData = function _setPlaneData(planeMesh, width, height, horizontalSegments, verticalSegments, noLongerAccessible, isRestoreMode) {
        horizontalSegments = Math.max(1, Math.floor(horizontalSegments));
        verticalSegments = Math.max(1, Math.floor(verticalSegments));
        var horizontalCount = horizontalSegments + 1;
        var verticalCount = verticalSegments + 1;
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var gridWidth = width / horizontalSegments;
        var gridHeight = height / verticalSegments;
        var vertexCount = horizontalCount * verticalCount;
        var rectangleCount = verticalSegments * horizontalSegments;
        var indices = PrimitiveMesh._generateIndices(planeMesh.engine, vertexCount, rectangleCount * 6);
        var horizontalCountReciprocal = 1.0 / horizontalCount;
        var horizontalSegmentsReciprocal = 1.0 / horizontalSegments;
        var verticalSegmentsReciprocal = 1.0 / verticalSegments;
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        for(var i = 0; i < vertexCount; ++i){
            var x = i % horizontalCount;
            var z = i * horizontalCountReciprocal | 0;
            // Position
            positions[i] = new Vector3(x * gridWidth - halfWidth, 0, z * gridHeight - halfHeight);
            // Normal
            normals[i] = new Vector3(0, 1, 0);
            // TexCoord
            uvs[i] = new Vector2(x * horizontalSegmentsReciprocal, z * verticalSegmentsReciprocal);
        }
        var offset = 0;
        for(var i1 = 0; i1 < rectangleCount; ++i1){
            var x1 = i1 % horizontalSegments;
            var y = i1 * horizontalSegmentsReciprocal | 0;
            var a = y * horizontalCount + x1;
            var b = a + 1;
            var c = a + horizontalCount;
            var d = c + 1;
            indices[offset++] = a;
            indices[offset++] = c;
            indices[offset++] = b;
            indices[offset++] = c;
            indices[offset++] = d;
            indices[offset++] = b;
        }
        if (!isRestoreMode) {
            var bounds = planeMesh.bounds;
            bounds.min.set(-halfWidth, 0, -halfHeight);
            bounds.max.set(halfWidth, 0, halfHeight);
        }
        PrimitiveMesh._initialize(planeMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    PrimitiveMesh._setCylinderData = function _setCylinderData(cylinderMesh, radiusTop, radiusBottom, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
        if (radiusTop === void 0) radiusTop = 0.5;
        if (radiusBottom === void 0) radiusBottom = 0.5;
        if (height === void 0) height = 2;
        if (radialSegments === void 0) radialSegments = 20;
        if (heightSegments === void 0) heightSegments = 1;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capTriangleCount = radialSegments * 2;
        var totalVertexCount = torsoVertexCount + 2 + capTriangleCount;
        var indices = PrimitiveMesh._generateIndices(cylinderMesh.engine, totalVertexCount, torsoRectangleCount * 6 + capTriangleCount * 3);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        // Create torso
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var radiusDiff = radiusBottom - radiusTop;
        var slope = radiusDiff / height;
        var radiusSlope = radiusDiff / heightSegments;
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var radius = radiusBottom - y * radiusSlope;
            var posX = radius * sinTheta;
            var posY = y * unitHeight - halfHeight;
            var posZ = radius * cosTheta;
            // Position
            positions[i] = new Vector3(posX, posY, posZ);
            // Normal
            normals[i] = new Vector3(sinTheta, slope, cosTheta);
            // TexCoord
            uvs[i] = new Vector2(u, 1 - v);
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        // Bottom position
        positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
        // Bottom normal
        normals[torsoVertexCount] = new Vector3(0, -1, 0);
        // Bottom texCoord
        uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
        // Top position
        positions[torsoVertexCount + 1] = new Vector3(0, halfHeight, 0);
        // Top normal
        normals[torsoVertexCount + 1] = new Vector3(0, 1, 0);
        // Top texCoord
        uvs[torsoVertexCount + 1] = new Vector2(0.5, 0.5);
        // Add cap vertices
        var offset = torsoVertexCount + 2;
        var diameterTopReciprocal = 1.0 / (radiusTop * 2);
        var diameterBottomReciprocal = 1.0 / (radiusBottom * 2);
        var positionStride = radialCount * heightSegments;
        for(var i2 = 0; i2 < radialSegments; ++i2){
            var curPosBottom = positions[i2];
            var curPosX = curPosBottom.x;
            var curPosZ = curPosBottom.z;
            // Bottom position
            positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
            // Bottom normal
            normals[offset] = new Vector3(0, -1, 0);
            // Bottom texcoord
            uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
            var curPosTop = positions[i2 + positionStride];
            curPosX = curPosTop.x;
            curPosZ = curPosTop.z;
            // Top position
            positions[offset] = new Vector3(curPosX, halfHeight, curPosZ);
            // Top normal
            normals[offset] = new Vector3(0, 1, 0);
            // Top texcoord
            uvs[offset++] = new Vector2(curPosX * diameterTopReciprocal + 0.5, curPosZ * diameterTopReciprocal + 0.5);
        }
        // Add cap indices
        var topCapIndex = torsoVertexCount + 1;
        var bottomIndiceIndex = torsoVertexCount + 2;
        var topIndiceIndex = bottomIndiceIndex + 1;
        for(var i3 = 0; i3 < radialSegments; ++i3){
            var firstStride = i3 * 2;
            var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 2;
            // Bottom
            indices[indicesOffset++] = torsoVertexCount;
            indices[indicesOffset++] = bottomIndiceIndex + secondStride;
            indices[indicesOffset++] = bottomIndiceIndex + firstStride;
            // Top
            indices[indicesOffset++] = topCapIndex;
            indices[indicesOffset++] = topIndiceIndex + firstStride;
            indices[indicesOffset++] = topIndiceIndex + secondStride;
        }
        if (!isRestoreMode) {
            var bounds = cylinderMesh.bounds;
            var radiusMax = Math.max(radiusTop, radiusBottom);
            bounds.min.set(-radiusMax, -halfHeight, -radiusMax);
            bounds.max.set(radiusMax, halfHeight, radiusMax);
        }
        PrimitiveMesh._initialize(cylinderMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    /**
   * @internal
   */ PrimitiveMesh._setTorusData = function _setTorusData(torusMesh, radius, tubeRadius, radialSegments, tubularSegments, arc, noLongerAccessible, isRestoreMode) {
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        var rectangleCount = radialSegments * tubularSegments;
        var indices = PrimitiveMesh._generateIndices(torusMesh.engine, vertexCount, rectangleCount * 6);
        var positions = new Array(vertexCount);
        var normals = new Array(vertexCount);
        var uvs = new Array(vertexCount);
        arc = arc / 180 * Math.PI;
        var offset = 0;
        for(var i = 0; i <= radialSegments; i++){
            for(var j = 0; j <= tubularSegments; j++){
                var u = j / tubularSegments * arc;
                var v = i / radialSegments * Math.PI * 2;
                var cosV = Math.cos(v);
                var sinV = Math.sin(v);
                var cosU = Math.cos(u);
                var sinU = Math.sin(u);
                var position = new Vector3((radius + tubeRadius * cosV) * cosU, (radius + tubeRadius * cosV) * sinU, tubeRadius * sinV);
                positions[offset] = position;
                var centerX = radius * cosU;
                var centerY = radius * sinU;
                normals[offset] = new Vector3(position.x - centerX, position.y - centerY, position.z).normalize();
                uvs[offset++] = new Vector2(j / tubularSegments, i / radialSegments);
            }
        }
        offset = 0;
        for(var i1 = 1; i1 <= radialSegments; i1++){
            for(var j1 = 1; j1 <= tubularSegments; j1++){
                var a = (tubularSegments + 1) * i1 + j1 - 1;
                var b = (tubularSegments + 1) * (i1 - 1) + j1 - 1;
                var c = (tubularSegments + 1) * (i1 - 1) + j1;
                var d = (tubularSegments + 1) * i1 + j1;
                indices[offset++] = a;
                indices[offset++] = b;
                indices[offset++] = d;
                indices[offset++] = b;
                indices[offset++] = c;
                indices[offset++] = d;
            }
        }
        if (!isRestoreMode) {
            var bounds = torusMesh.bounds;
            var outerRadius = radius + tubeRadius;
            bounds.min.set(-outerRadius, -outerRadius, -tubeRadius);
            bounds.max.set(outerRadius, outerRadius, tubeRadius);
        }
        PrimitiveMesh._initialize(torusMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    /**
   * @internal
   */ PrimitiveMesh._setConeData = function _setConeData(coneMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var totalVertexCount = torsoVertexCount + 1 + radialSegments;
        var indices = PrimitiveMesh._generateIndices(coneMesh.engine, totalVertexCount, torsoRectangleCount * 6 + radialSegments * 3);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        // Create torso
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var slope = radius / height;
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            var curRadius = radius - y * radius;
            var posX = curRadius * sinTheta;
            var posY = y * unitHeight - halfHeight;
            var posZ = curRadius * cosTheta;
            // Position
            positions[i] = new Vector3(posX, posY, posZ);
            // Normal
            normals[i] = new Vector3(sinTheta, slope, cosTheta);
            // Texcoord
            uvs[i] = new Vector2(u, 1 - v);
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        // Bottom position
        positions[torsoVertexCount] = new Vector3(0, -halfHeight, 0);
        // Bottom normal
        normals[torsoVertexCount] = new Vector3(0, -1, 0);
        // Bottom texcoord
        uvs[torsoVertexCount] = new Vector2(0.5, 0.5);
        // Add bottom cap vertices
        var offset = torsoVertexCount + 1;
        var diameterBottomReciprocal = 1.0 / (radius * 2);
        for(var i2 = 0; i2 < radialSegments; ++i2){
            var curPos = positions[i2];
            var curPosX = curPos.x;
            var curPosZ = curPos.z;
            // Bottom position
            positions[offset] = new Vector3(curPosX, -halfHeight, curPosZ);
            // Bottom normal
            normals[offset] = new Vector3(0, -1, 0);
            // Bottom texcoord
            uvs[offset++] = new Vector2(curPosX * diameterBottomReciprocal + 0.5, 0.5 - curPosZ * diameterBottomReciprocal);
        }
        var bottomIndiceIndex = torsoVertexCount + 1;
        for(var i3 = 0; i3 < radialSegments; ++i3){
            var firstStride = i3;
            var secondStride = i3 === radialSegments - 1 ? 0 : firstStride + 1;
            // Bottom
            indices[indicesOffset++] = torsoVertexCount;
            indices[indicesOffset++] = bottomIndiceIndex + secondStride;
            indices[indicesOffset++] = bottomIndiceIndex + firstStride;
        }
        if (!isRestoreMode) {
            var bounds = coneMesh.bounds;
            bounds.min.set(-radius, -halfHeight, -radius);
            bounds.max.set(radius, halfHeight, radius);
        }
        PrimitiveMesh._initialize(coneMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    PrimitiveMesh._setCapsuleData = function _setCapsuleData(capsuleMesh, radius, height, radialSegments, heightSegments, noLongerAccessible, isRestoreMode) {
        radialSegments = Math.max(2, Math.floor(radialSegments));
        heightSegments = Math.floor(heightSegments);
        var radialCount = radialSegments + 1;
        var verticalCount = heightSegments + 1;
        var halfHeight = height * 0.5;
        var unitHeight = height / heightSegments;
        var torsoVertexCount = radialCount * verticalCount;
        var torsoRectangleCount = radialSegments * heightSegments;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var totalVertexCount = torsoVertexCount + 2 * capVertexCount;
        var indices = PrimitiveMesh._generateIndices(capsuleMesh.engine, totalVertexCount, (torsoRectangleCount + 2 * capRectangleCount) * 6);
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        var heightSegmentsReciprocal = 1.0 / heightSegments;
        var thetaStart = Math.PI;
        var thetaRange = Math.PI * 2;
        var positions = new Array(totalVertexCount);
        var normals = new Array(totalVertexCount);
        var uvs = new Array(totalVertexCount);
        var indicesOffset = 0;
        // create torso
        for(var i = 0; i < torsoVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * heightSegmentsReciprocal;
            var theta = thetaStart + u * thetaRange;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            positions[i] = new Vector3(radius * sinTheta, y * unitHeight - halfHeight, radius * cosTheta);
            normals[i] = new Vector3(sinTheta, 0, cosTheta);
            uvs[i] = new Vector2(u, 1 - v);
        }
        for(var i1 = 0; i1 < torsoRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = c;
        }
        PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, thetaRange, torsoVertexCount, 1, positions, normals, uvs, indices, indicesOffset);
        PrimitiveMesh._createCapsuleCap(radius, height, radialSegments, -thetaRange, torsoVertexCount + capVertexCount, -1, positions, normals, uvs, indices, indicesOffset + 6 * capRectangleCount);
        if (!isRestoreMode) {
            var bounds = capsuleMesh.bounds;
            bounds.min.set(-radius, -radius - halfHeight, -radius);
            bounds.max.set(radius, radius + halfHeight, radius);
        }
        PrimitiveMesh._initialize(capsuleMesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode);
    };
    PrimitiveMesh._initialize = function _initialize(mesh, positions, normals, uvs, indices, noLongerAccessible, isRestoreMode) {
        mesh.setPositions(positions);
        mesh.setNormals(normals);
        mesh.setUVs(uvs);
        mesh.setIndices(indices);
        mesh.calculateTangents();
        mesh.uploadData(noLongerAccessible);
        if (!isRestoreMode) {
            mesh.addSubMesh(0, indices.length);
        }
    };
    PrimitiveMesh._generateIndices = function _generateIndices(engine, vertexCount, indexCount) {
        var indices = null;
        if (vertexCount > 65535) {
            if (engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
                indices = new Uint32Array(indexCount);
            } else {
                throw Error("The vertex count is over limit.");
            }
        } else {
            indices = new Uint16Array(indexCount);
        }
        return indices;
    };
    PrimitiveMesh._createCapsuleCap = function _createCapsuleCap(radius, height, radialSegments, capAlphaRange, offset, posIndex, positions, normals, uvs, indices, indicesOffset) {
        var radialCount = radialSegments + 1;
        var halfHeight = height * 0.5 * posIndex;
        var capVertexCount = radialCount * radialCount;
        var capRectangleCount = radialSegments * radialSegments;
        var radialCountReciprocal = 1.0 / radialCount;
        var radialSegmentsReciprocal = 1.0 / radialSegments;
        for(var i = 0; i < capVertexCount; ++i){
            var x = i % radialCount;
            var y = i * radialCountReciprocal | 0;
            var u = x * radialSegmentsReciprocal;
            var v = y * radialSegmentsReciprocal;
            var alphaDelta = u * capAlphaRange;
            var thetaDelta = v * Math.PI / 2;
            var sinTheta = Math.sin(thetaDelta);
            var posX = -radius * Math.cos(alphaDelta) * sinTheta;
            var posY = radius * Math.cos(thetaDelta) * posIndex + halfHeight;
            var posZ = radius * Math.sin(alphaDelta) * sinTheta;
            var index = i + offset;
            positions[index] = new Vector3(posX, posY, posZ);
            normals[index] = new Vector3(posX, posY - halfHeight, posZ);
            uvs[index] = new Vector2(u, v);
        }
        for(var i1 = 0; i1 < capRectangleCount; ++i1){
            var x1 = i1 % radialSegments;
            var y1 = i1 * radialSegmentsReciprocal | 0;
            var a = y1 * radialCount + x1 + offset;
            var b = a + 1;
            var c = a + radialCount;
            var d = c + 1;
            indices[indicesOffset++] = b;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = d;
            indices[indicesOffset++] = a;
            indices[indicesOffset++] = c;
            indices[indicesOffset++] = d;
        }
    };
    return PrimitiveMesh;
}();

/**
 * BufferMesh.
 */ var BufferMesh = /*#__PURE__*/ function(Mesh) {
    _inherits$2(BufferMesh, Mesh);
    function BufferMesh() {
        return Mesh.apply(this, arguments);
    }
    var _proto = BufferMesh.prototype;
    /**
   * Set vertex elements.
   * @param elements - Vertex element collection
   */ _proto.setVertexElements = function setVertexElements(elements) {
        this._setVertexElements(elements);
    };
    _proto.setVertexBufferBinding = function setVertexBufferBinding(bufferOrBinding, strideOrFirstIndex, index) {
        if (strideOrFirstIndex === void 0) strideOrFirstIndex = 0;
        if (index === void 0) index = 0;
        var binding = bufferOrBinding;
        var isBinding = binding.buffer !== undefined;
        isBinding || (binding = new VertexBufferBinding(bufferOrBinding, strideOrFirstIndex));
        var bindings = this._vertexBufferBindings;
        bindings.length <= index && (bindings.length = index + 1);
        this._setVertexBufferBinding(isBinding ? strideOrFirstIndex : index, binding);
    };
    /**
   * Set vertex buffer binding.
   * @param vertexBufferBindings - Vertex buffer binding
   * @param firstIndex - First vertex buffer index, the default value is 0
   */ _proto.setVertexBufferBindings = function setVertexBufferBindings(vertexBufferBindings, firstIndex) {
        if (firstIndex === void 0) firstIndex = 0;
        var bindings = this._vertexBufferBindings;
        var count = vertexBufferBindings.length;
        var needLength = firstIndex + count;
        bindings.length < needLength && (bindings.length = needLength);
        for(var i = 0; i < count; i++){
            this._setVertexBufferBinding(firstIndex + i, vertexBufferBindings[i]);
        }
    };
    _proto.setIndexBufferBinding = function setIndexBufferBinding(bufferOrBinding, format) {
        var binding = bufferOrBinding;
        if (binding) {
            var isBinding = binding.buffer !== undefined;
            isBinding || (binding = new IndexBufferBinding(bufferOrBinding, format));
        }
        this._setIndexBufferBinding(binding);
    };
    _create_class$3(BufferMesh, [
        {
            key: "instanceCount",
            get: /**
   * Instanced count, disable instanced drawing when set zero.
   */ function get() {
                return this._instanceCount;
            },
            set: function set(value) {
                this._instanceCount = value;
            }
        },
        {
            key: "vertexBufferBindings",
            get: /**
   * Vertex buffer binding collection.
   */ function get() {
                return this._vertexBufferBindings;
            }
        },
        {
            key: "indexBufferBinding",
            get: /**
   * Index buffer binding.
   */ function get() {
                return this._indexBufferBinding;
            }
        },
        {
            key: "vertexElements",
            get: /**
   * Vertex element collection.
   */ function get() {
                return this._vertexElements;
            }
        }
    ]);
    return BufferMesh;
}(Mesh);

/**
 * BlendShapeFrame.
 */ var BlendShapeFrame = /*#__PURE__*/ function() {
    function BlendShapeFrame(weight, deltaPositions, deltaNormals, deltaTangents) {
        if (deltaNormals === void 0) deltaNormals = null;
        if (deltaTangents === void 0) deltaTangents = null;
        /** @internal */ this._dataChangeManager = new UpdateFlagManager();
        this._dirty = 0x7;
        if (deltaNormals && deltaNormals.length !== deltaPositions.length) {
            throw "deltaNormals length must same with deltaPositions length.";
        }
        if (deltaTangents && deltaTangents.length !== deltaPositions.length) {
            throw "deltaTangents length must same with deltaPositions length.";
        }
        this.weight = weight;
        this._deltaPositions = deltaPositions;
        this._deltaNormals = deltaNormals;
        this._deltaTangents = deltaTangents;
    }
    var _proto = BlendShapeFrame.prototype;
    /**
   * @internal
   */ _proto._releaseData = function _releaseData() {
        this._deltaPositions = null;
        this._deltaNormals = null;
        this._deltaTangents = null;
    };
    _create_class$3(BlendShapeFrame, [
        {
            key: "deltaPositions",
            get: /**
   * Delta positions for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaPositions;
            },
            set: function set(value) {
                this._deltaPositions = value;
                this._dirty |= 0x1;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        },
        {
            key: "deltaNormals",
            get: /**
   * Delta normals for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaNormals;
            },
            set: function set(value) {
                this._deltaNormals = value;
                this._dirty |= 0x2;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        },
        {
            key: "deltaTangents",
            get: /**
   * Delta tangents for the frame being added.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                return this._deltaTangents;
            },
            set: function set(value) {
                this._deltaTangents = value;
                this._dirty |= 0x4;
                this._dataChangeManager.dispatch(this._dirty, this);
            }
        }
    ]);
    return BlendShapeFrame;
}();
var BlendShapeFrameDirty;
(function(BlendShapeFrameDirty) {
    BlendShapeFrameDirty[BlendShapeFrameDirty["Position"] = 0x1] = "Position";
    BlendShapeFrameDirty[BlendShapeFrameDirty["Normal"] = 0x2] = "Normal";
    BlendShapeFrameDirty[BlendShapeFrameDirty["Tangent"] = 0x4] = "Tangent";
    BlendShapeFrameDirty[BlendShapeFrameDirty["All"] = 0x7] = "All";
})(BlendShapeFrameDirty || (BlendShapeFrameDirty = {}));

/**
 * BlendShape.
 */ var BlendShape = /*#__PURE__*/ function() {
    function BlendShape(name) {
        /** @internal */ this._useBlendShapeNormal = true;
        /** @internal */ this._useBlendShapeTangent = true;
        /** @internal */ this._layoutChangeManager = new UpdateFlagManager();
        /** @internal */ this._dataChangeManager = new UpdateFlagManager();
        this._frames = [];
        this.name = name;
        this._frameDataChangeListener = this._frameDataChangeListener.bind(this);
    }
    var _proto = BlendShape.prototype;
    _proto.addFrame = function addFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents) {
        if (typeof frameOrWeight === "number") {
            var frame = new BlendShapeFrame(frameOrWeight, deltaPositions, deltaNormals, deltaTangents);
            this._addFrame(frame);
            return frame;
        } else {
            this._addFrame(frameOrWeight);
        }
    };
    /**
   * Clear all frames.
   */ _proto.clearFrames = function clearFrames() {
        var frames = this._frames;
        for(var i = 0, n = frames.length; i < n; i++){
            frames[i]._dataChangeManager.removeListener(this._frameDataChangeListener);
        }
        frames.length = 0;
        this._updateUseNormalAndTangent(true, true);
        this._dataChangeManager.dispatch();
    };
    /**
   * @internal
   */ _proto._releaseData = function _releaseData() {
        var frames = this._frames;
        for(var i = 0, n = frames.length; i < n; i++){
            frames[i]._releaseData();
        }
    };
    _proto._addFrame = function _addFrame(frame) {
        var frames = this._frames;
        var frameCount = frames.length;
        if (frameCount > 0 && frame.deltaPositions.length !== frames[frameCount - 1].deltaPositions.length) {
            throw "Frame's deltaPositions length must same with before frame deltaPositions length.";
        }
        this._frames.push(frame);
        this._frameDataChangeListener(BlendShapeFrameDirty.All, frame);
        frame._dataChangeManager.addListener(this._frameDataChangeListener);
    };
    _proto._updateUseNormalAndTangent = function _updateUseNormalAndTangent(useNormal, useTangent) {
        var useBlendShapeNormal = this._useBlendShapeNormal && useNormal;
        var useBlendShapeTangent = this._useBlendShapeTangent && useTangent;
        if (this._useBlendShapeNormal !== useBlendShapeNormal || this._useBlendShapeTangent !== useBlendShapeTangent) {
            this._useBlendShapeNormal = useBlendShapeNormal;
            this._useBlendShapeTangent = useBlendShapeTangent;
            this._layoutChangeManager.dispatch(0, this);
        }
    };
    _proto._frameDataChangeListener = function _frameDataChangeListener(type, frame) {
        this._updateUseNormalAndTangent(!!frame.deltaNormals, !!frame.deltaTangents);
        this._dataChangeManager.dispatch();
    };
    _create_class$3(BlendShape, [
        {
            key: "frames",
            get: /**
   * Frames of BlendShape.
   */ function get() {
                return this._frames;
            }
        }
    ]);
    return BlendShape;
}();

var Basic2DBatcher = /*#__PURE__*/ function() {
    function Basic2DBatcher(engine) {
        /** @internal */ this._subMeshPool = new ClassPool(SubMesh);
        /** @internal */ this._batchedQueue = [];
        /** @internal */ this._meshes = [];
        /** @internal */ this._meshCount = 1;
        /** @internal */ this._vertexBuffers = [];
        /** @internal */ this._indiceBuffers = [];
        /** @internal */ this._flushId = 0;
        /** @internal */ this._vertexCount = 0;
        /** @internal */ this._elementCount = 0;
        this._engine = engine;
        this._initMeshes(engine);
    }
    var _proto = Basic2DBatcher.prototype;
    _proto.drawElement = function drawElement(element, camera) {
        var data = element.data;
        if (data.multiRenderData) {
            var charsData = data.charsData;
            var pool = camera.engine._renderElementPool;
            for(var i = 0, n = charsData.length; i < n; ++i){
                var charRenderElement = pool.getFromPool();
                charRenderElement.set(charsData[i], element.shaderPass, element.renderState);
                this._drawSubElement(charRenderElement, camera);
            }
        } else {
            this._drawSubElement(element, camera);
        }
    };
    /**
   * @internal
   * Standalone for canvas 2d renderer plugin.
   */ _proto._initMeshes = function _initMeshes(engine) {
        var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
        this._vertices = new Float32Array(MAX_VERTEX_COUNT * 9);
        this._indices = new Uint16Array(MAX_VERTEX_COUNT * 3);
        var _this = this, _meshes = _this._meshes, _meshCount = _this._meshCount;
        for(var i = 0; i < _meshCount; i++){
            _meshes[i] = this._createMesh(engine, i);
        }
    };
    _proto.flush = function flush(camera) {
        var batchedQueue = this._batchedQueue;
        if (batchedQueue.length === 0) {
            return;
        }
        this._updateData(this._engine);
        this.drawBatches(camera);
        if (!Basic2DBatcher._canUploadSameBuffer) {
            this._flushId++;
        }
        batchedQueue.length = 0;
        this._subMeshPool.resetPool();
        this._vertexCount = 0;
        this._elementCount = 0;
    };
    _proto.clear = function clear() {
        this._flushId = 0;
        this._vertexCount = 0;
        this._elementCount = 0;
        this._batchedQueue.length = 0;
    };
    _proto.destroy = function destroy() {
        this._batchedQueue = null;
        var _this = this, meshes = _this._meshes, vertexBuffers = _this._vertexBuffers, indiceBuffers = _this._indiceBuffers;
        for(var i = 0, n = meshes.length; i < n; ++i){
            meshes[i].destroy();
        }
        this._meshes = null;
        for(var i1 = 0, n1 = vertexBuffers.length; i1 < n1; ++i1){
            vertexBuffers[i1].destroy();
        }
        this._vertexBuffers = null;
        for(var i2 = 0, n2 = indiceBuffers.length; i2 < n2; ++i2){
            indiceBuffers[i2].destroy();
        }
        this._indiceBuffers = null;
    };
    _proto._drawSubElement = function _drawSubElement(element, camera) {
        var vertexCount = element.data.verticesData.vertexCount;
        if (this._vertexCount + vertexCount > Basic2DBatcher.MAX_VERTEX_COUNT) {
            this.flush(camera);
        }
        this._vertexCount += vertexCount;
        this._batchedQueue[this._elementCount++] = element;
    };
    _proto._createMesh = function _createMesh(engine, index) {
        var MAX_VERTEX_COUNT = Basic2DBatcher.MAX_VERTEX_COUNT;
        var mesh = new BufferMesh(engine, "BufferMesh" + index);
        mesh.isGCIgnored = true;
        var vertexElements = [];
        var vertexStride = this.createVertexElements(vertexElements);
        // vertices
        var vertexBuffer = this._vertexBuffers[index] = new Buffer(engine, BufferBindFlag.VertexBuffer, MAX_VERTEX_COUNT * 4 * vertexStride, BufferUsage.Dynamic);
        vertexBuffer.isGCIgnored = true;
        // indices
        var indiceBuffer = this._indiceBuffers[index] = new Buffer(engine, BufferBindFlag.IndexBuffer, MAX_VERTEX_COUNT * 2 * 3, BufferUsage.Dynamic);
        indiceBuffer.isGCIgnored = true;
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setIndexBufferBinding(indiceBuffer, IndexFormat.UInt16);
        mesh.setVertexElements(vertexElements);
        return mesh;
    };
    _proto._updateData = function _updateData(engine) {
        var _this = this, _meshes = _this._meshes, _flushId = _this._flushId;
        if (!Basic2DBatcher._canUploadSameBuffer && this._meshCount <= _flushId) {
            this._meshCount++;
            _meshes[_flushId] = this._createMesh(engine, _flushId);
        }
        var _this1 = this, batchedQueue = _this1._batchedQueue, vertices = _this1._vertices, indices = _this1._indices;
        var mesh = _meshes[_flushId];
        mesh.clearSubMesh();
        var vertexIndex = 0;
        var indiceIndex = 0;
        var vertexStartIndex = 0;
        var vertexCount = 0;
        var curIndiceStartIndex = 0;
        var curMeshIndex = 0;
        var preElement = null;
        for(var i = 0, len = batchedQueue.length; i < len; i++){
            var curElement = batchedQueue[i];
            var curData = curElement.data;
            // Batch vertex
            vertexIndex = this.updateVertices(curData, vertices, vertexIndex);
            // Batch indice
            var triangles = curData.verticesData.triangles;
            var triangleNum = triangles.length;
            for(var j = 0; j < triangleNum; j++){
                indices[indiceIndex++] = triangles[j] + curIndiceStartIndex;
            }
            curIndiceStartIndex += curData.verticesData.vertexCount;
            if (preElement === null) {
                vertexCount += triangleNum;
            } else {
                if (this.canBatch(preElement, curElement)) {
                    vertexCount += triangleNum;
                } else {
                    mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
                    vertexStartIndex += vertexCount;
                    vertexCount = triangleNum;
                    batchedQueue[curMeshIndex++] = preElement;
                }
            }
            preElement = curElement;
        }
        mesh.addSubMesh(this._getSubMeshFromPool(vertexStartIndex, vertexCount));
        batchedQueue[curMeshIndex] = preElement;
        this._vertexBuffers[_flushId].setData(vertices, 0, 0, vertexIndex);
        this._indiceBuffers[_flushId].setData(indices, 0, 0, indiceIndex);
    };
    _proto._getSubMeshFromPool = function _getSubMeshFromPool(start, count) {
        var subMesh = this._subMeshPool.getFromPool();
        subMesh.start = start;
        subMesh.count = count;
        subMesh.topology = MeshTopology.Triangles;
        return subMesh;
    };
    return Basic2DBatcher;
}();
(function() {
    Basic2DBatcher._disableBatchTag = ShaderTagKey.getByName("spriteDisableBatching");
})();
(function() {
    /** The maximum number of vertex. */ Basic2DBatcher.MAX_VERTEX_COUNT = 4096;
})();
(function() {
    Basic2DBatcher._canUploadSameBuffer = true;
})();

var SpriteMaskBatcher = /*#__PURE__*/ function(Basic2DBatcher) {
    _inherits$2(SpriteMaskBatcher, Basic2DBatcher);
    function SpriteMaskBatcher() {
        return Basic2DBatcher.apply(this, arguments);
    }
    var _proto = SpriteMaskBatcher.prototype;
    _proto.createVertexElements = function createVertexElements(vertexElements) {
        vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
        vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
        return 20;
    };
    _proto.canBatch = function canBatch(preElement, curElement) {
        var preSpriteData = preElement.data;
        var curSpriteData = curElement.data;
        if (preSpriteData.isAdd !== curSpriteData.isAdd) {
            return false;
        }
        // Compare renderer property
        var preShaderData = preSpriteData.component.shaderData;
        var curShaderData = curSpriteData.component.shaderData;
        var textureProperty = SpriteMask._textureProperty;
        var alphaCutoffProperty = SpriteMask._alphaCutoffProperty;
        return preShaderData.getTexture(textureProperty) === curShaderData.getTexture(textureProperty) && preShaderData.getTexture(alphaCutoffProperty) === curShaderData.getTexture(alphaCutoffProperty);
    };
    _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
        var _element_verticesData = element.verticesData, positions = _element_verticesData.positions, uvs = _element_verticesData.uvs, vertexCount = _element_verticesData.vertexCount;
        for(var i = 0; i < vertexCount; i++){
            var curPos = positions[i];
            var curUV = uvs[i];
            vertices[vertexIndex++] = curPos.x;
            vertices[vertexIndex++] = curPos.y;
            vertices[vertexIndex++] = curPos.z;
            vertices[vertexIndex++] = curUV.x;
            vertices[vertexIndex++] = curUV.y;
        }
        return vertexIndex;
    };
    _proto.drawBatches = function drawBatches(camera) {
        var _this = this, engine = _this._engine, batchedQueue = _this._batchedQueue;
        var mesh = this._meshes[this._flushId];
        var subMeshes = mesh.subMeshes;
        var sceneData = camera.scene.shaderData;
        var cameraData = camera.shaderData;
        for(var i = 0, len = subMeshes.length; i < len; i++){
            var subMesh = subMeshes[i];
            var spriteMaskElement = batchedQueue[i];
            var spritMaskData = spriteMaskElement.data;
            if (!subMesh || !spriteMaskElement) {
                return;
            }
            var renderer = spritMaskData.component;
            var material = spritMaskData.material;
            var compileMacros = Shader._compileMacros;
            // union render global macro and material self macro.
            ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
            // Update stencil state
            var stencilState = material.renderState.stencilState;
            var op = spritMaskData.isAdd ? StencilOperation.IncrementSaturate : StencilOperation.DecrementSaturate;
            stencilState.passOperationFront = op;
            stencilState.passOperationBack = op;
            var program = material.shader.subShaders[0].passes[0]._getShaderProgram(engine, compileMacros);
            if (!program.isValid) {
                return;
            }
            program.bind();
            program.groupingOtherUniformBlock();
            program.uploadAll(program.sceneUniformBlock, sceneData);
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
            program.uploadAll(program.materialUniformBlock, material.shaderData);
            material.renderState._apply(engine, false);
            engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
        }
    };
    return SpriteMaskBatcher;
}(Basic2DBatcher);

/**
 * @internal
 */ var SpriteMaskManager = /*#__PURE__*/ function() {
    function SpriteMaskManager(engine) {
        this._preMaskLayer = 0;
        this._batcher = new SpriteMaskBatcher(engine);
    }
    var _proto = SpriteMaskManager.prototype;
    _proto.clear = function clear() {
        this._preMaskLayer = 0;
        this._batcher.clear();
    };
    _proto.preRender = function preRender(camera, renderer) {
        if (renderer.maskInteraction === SpriteMaskInteraction.None) {
            return;
        }
        this._batcher.clear();
        this._processMasksDiff(camera, renderer);
        this._batcher.flush(camera);
    };
    _proto.postRender = function postRender(renderer) {
        if (renderer.maskInteraction === SpriteMaskInteraction.None) {
            return;
        }
        this._preMaskLayer = renderer.maskLayer;
    };
    _proto.destroy = function destroy() {
        this._batcher.destroy();
        this._batcher = null;
    };
    _proto._processMasksDiff = function _processMasksDiff(camera, renderer) {
        var preMaskLayer = this._preMaskLayer;
        var curMaskLayer = renderer.maskLayer;
        if (preMaskLayer !== curMaskLayer) {
            var allMasks = camera._renderPipeline._allSpriteMasks;
            var commonLayer = preMaskLayer & curMaskLayer;
            var addLayer = curMaskLayer & ~preMaskLayer;
            var reduceLayer = preMaskLayer & ~curMaskLayer;
            var allMaskElements = allMasks._elements;
            for(var i = 0, n = allMasks.length; i < n; i++){
                var mask = allMaskElements[i];
                var influenceLayers = mask.influenceLayers;
                if (influenceLayers & commonLayer) {
                    continue;
                }
                if (influenceLayers & addLayer) {
                    var maskRenderElement = mask._maskElement;
                    maskRenderElement.data.isAdd = true;
                    this._batcher.drawElement(maskRenderElement, camera);
                    continue;
                }
                if (influenceLayers & reduceLayer) {
                    var maskRenderElement1 = mask._maskElement;
                    maskRenderElement1.data.isAdd = false;
                    this._batcher.drawElement(maskRenderElement1, camera);
                }
            }
        }
    };
    return SpriteMaskManager;
}();

var SpriteMaskRenderData = /*#__PURE__*/ function(RenderData) {
    _inherits$2(SpriteMaskRenderData, RenderData);
    function SpriteMaskRenderData() {
        var _this;
        _this = RenderData.call(this) || this;
        _this.isAdd = true;
        _this.multiRenderData = false;
        return _this;
    }
    var _proto = SpriteMaskRenderData.prototype;
    _proto.set = function set(component, material, verticesData) {
        this.component = component;
        this.material = material;
        this.verticesData = verticesData;
    };
    _proto.dispose = function dispose() {
        this.component = this.material = this.verticesData = null;
    };
    return SpriteMaskRenderData;
}(RenderData);

var SpriteRenderData = /*#__PURE__*/ function(RenderData) {
    _inherits$2(SpriteRenderData, RenderData);
    function SpriteRenderData() {
        var _this;
        _this = RenderData.call(this) || this;
        _this.multiRenderData = false;
        return _this;
    }
    var _proto = SpriteRenderData.prototype;
    _proto.set = function set(component, material, verticesData, texture, dataIndex) {
        if (dataIndex === void 0) dataIndex = 0;
        this.component = component;
        this.material = material;
        this.verticesData = verticesData;
        this.texture = texture;
        this.dataIndex = dataIndex;
    };
    _proto.dispose = function dispose() {
        this.component = this.material = this.verticesData = this.texture = null;
    };
    return SpriteRenderData;
}(RenderData);

var TextRenderData = /*#__PURE__*/ function(RenderData) {
    _inherits$2(TextRenderData, RenderData);
    function TextRenderData() {
        var _this;
        _this = RenderData.call(this) || this;
        _this.charsData = [];
        _this.multiRenderData = true;
        return _this;
    }
    var _proto = TextRenderData.prototype;
    _proto.dispose = function dispose() {
        this.component = this.material = null;
        this.charsData.length = 0;
    };
    return TextRenderData;
}(RenderData);

/**
 * The Background mode enumeration.
 */ var BackgroundMode;
(function(BackgroundMode) {
    BackgroundMode[BackgroundMode[/* Solid color. */ "SolidColor"] = 0] = "SolidColor";
    BackgroundMode[BackgroundMode[/* Sky. */ "Sky"] = 1] = "Sky";
    BackgroundMode[BackgroundMode[/** Texture */ "Texture"] = 2] = "Texture";
})(BackgroundMode || (BackgroundMode = {}));

/**
 * Filling mode of background texture.
 */ var BackgroundTextureFillMode;
(function(BackgroundTextureFillMode) {
    BackgroundTextureFillMode[BackgroundTextureFillMode[/* Maintain the aspect ratio and scale the texture to fit the width of the canvas. */ "AspectFitWidth"] = 0] = "AspectFitWidth";
    BackgroundTextureFillMode[BackgroundTextureFillMode[/* Maintain the aspect ratio and scale the texture to fit the height of the canvas. */ "AspectFitHeight"] = 1] = "AspectFitHeight";
    BackgroundTextureFillMode[BackgroundTextureFillMode[/* Scale the texture fully fills the canvas. */ "Fill"] = 2] = "Fill";
})(BackgroundTextureFillMode || (BackgroundTextureFillMode = {}));

/**
 * Sky.
 */ var Sky = /*#__PURE__*/ function() {
    function Sky() {}
    var _proto = Sky.prototype;
    /**
   * @internal
   */ _proto.destroy = function destroy() {
        this.mesh = null;
        this.material = null;
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        var _this = this, material = _this.material, mesh = _this.mesh;
        if (!material) {
            Logger.warn("The material of sky is not defined.");
            return;
        }
        if (!mesh) {
            Logger.warn("The mesh of sky is not defined.");
            return;
        }
        var _context_camera = context.camera, engine = _context_camera.engine, aspectRatio = _context_camera.aspectRatio, fieldOfView = _context_camera.fieldOfView, viewMatrix = _context_camera.viewMatrix, cameraShaderData = _context_camera.shaderData;
        var sceneData = context.camera.scene.shaderData;
        var viewProjMatrix = Sky._viewProjMatrix, projectionMatrix = Sky._projectionMatrix;
        var rhi = engine._hardwareRenderer;
        var materialShaderData = material.shaderData, shader = material.shader, renderState = material.renderState;
        // no-scale view matrix
        viewProjMatrix.copyFrom(viewMatrix);
        var e = viewProjMatrix.elements;
        e[12] = e[13] = e[14] = 0;
        // epsilon-infinity projection matrix http://terathon.com/gdc07_lengyel.pdf
        var f = 1.0 / Math.tan(MathUtil$1.degreeToRadian(fieldOfView) / 2);
        projectionMatrix.elements[0] = f / aspectRatio;
        projectionMatrix.elements[5] = f;
        // view-proj matrix
        Matrix.multiply(projectionMatrix, viewProjMatrix, viewProjMatrix);
        var originViewProjMatrix = cameraShaderData.getMatrix(RenderContext.vpMatrixProperty);
        cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, viewProjMatrix);
        var compileMacros = Shader._compileMacros;
        ShaderMacroCollection.unionCollection(context.camera._globalShaderMacro, materialShaderData._macroCollection, compileMacros);
        var program = shader.subShaders[0].passes[0]._getShaderProgram(engine, compileMacros);
        program.bind();
        program.groupingOtherUniformBlock();
        program.uploadAll(program.sceneUniformBlock, sceneData);
        program.uploadAll(program.cameraUniformBlock, cameraShaderData);
        program.uploadAll(program.materialUniformBlock, materialShaderData);
        program.uploadUnGroupTextures();
        renderState._apply(engine, false);
        rhi.drawPrimitive(mesh, mesh.subMesh, program);
        cameraShaderData.setMatrix(RenderContext.vpMatrixProperty, originViewProjMatrix);
    };
    _create_class$3(Sky, [
        {
            key: "material",
            get: /**
   *  Material of the sky.
   */ function get() {
                return this._material;
            },
            set: function set(value) {
                if (this._material !== value) {
                    var _this__material;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__material = this._material) == null ? void 0 : _this__material._addReferCount(-1);
                    this._material = value;
                }
            }
        },
        {
            key: "mesh",
            get: /**
   *  Mesh of the sky.
   */ function get() {
                return this._mesh;
            },
            set: function set(value) {
                if (this._mesh !== value) {
                    var _this__mesh;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__mesh = this._mesh) == null ? void 0 : _this__mesh._addReferCount(-1);
                    this._mesh = value;
                }
            }
        }
    ]);
    return Sky;
}();
(function() {
    Sky._epsilon = 1e-6;
})();
(function() {
    Sky._viewProjMatrix = new Matrix();
})();
(function() {
    Sky._projectionMatrix = new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, Sky._epsilon - 1, -1, 0, 0, 0, 0);
})();

/**
 * Background of scene.
 */ var Background = /*#__PURE__*/ function() {
    function Background(_engine) {
        this._engine = _engine;
        this./**
   * Background mode.
   * @defaultValue `BackgroundMode.SolidColor`
   * @remarks If using `BackgroundMode.Sky` mode and material or mesh of the `sky` is not defined, it will downgrade to `BackgroundMode.SolidColor`.
   */ mode = BackgroundMode.SolidColor;
        this./**
   * Background solid color.
   * @defaultValue `new Color(0.25, 0.25, 0.25, 1.0)`
   * @remarks When `mode` is `BackgroundMode.SolidColor`, the property will take effects.
   */ solidColor = new Color$1(0.25, 0.25, 0.25, 1.0);
        this.sky = new Sky();
        this./** @internal */ _textureFillMode = BackgroundTextureFillMode.AspectFitHeight;
        this._texture = null;
        this._initMesh(_engine);
    }
    var _proto = Background.prototype;
    /**
   * @internal
   */ _proto.destroy = function destroy() {
        this._mesh._addReferCount(-1);
        this._mesh = null;
        this.texture = null;
        this.solidColor = null;
        this.sky.destroy();
    };
    /**
   * @internal
   * Standalone for CanvasRenderer plugin.
   */ _proto._initMesh = function _initMesh(engine) {
        this._mesh = this._createPlane(engine);
        this._mesh._addReferCount(1);
    };
    /**
   * @internal
   */ _proto._resizeBackgroundTexture = function _resizeBackgroundTexture() {
        if (!this._texture) {
            return;
        }
        var canvas = this._engine.canvas;
        var width = canvas.width, height = canvas.height;
        var _this = this, _backgroundTextureMesh = _this._mesh;
        var positions = _backgroundTextureMesh.getPositions();
        switch(this._textureFillMode){
            case BackgroundTextureFillMode.Fill:
                positions[0].set(-1, -1, 1);
                positions[1].set(1, -1, 1);
                positions[2].set(-1, 1, 1);
                positions[3].set(1, 1, 1);
                break;
            case BackgroundTextureFillMode.AspectFitWidth:
                var fitWidthScale = this._texture.height * width / this.texture.width / height;
                positions[0].set(-1, -fitWidthScale, 1);
                positions[1].set(1, -fitWidthScale, 1);
                positions[2].set(-1, fitWidthScale, 1);
                positions[3].set(1, fitWidthScale, 1);
                break;
            case BackgroundTextureFillMode.AspectFitHeight:
                var fitHeightScale = this._texture.width * height / this.texture.height / width;
                positions[0].set(-fitHeightScale, -1, 1);
                positions[1].set(fitHeightScale, -1, 1);
                positions[2].set(-fitHeightScale, 1, 1);
                positions[3].set(fitHeightScale, 1, 1);
                break;
        }
        _backgroundTextureMesh.setPositions(positions);
        _backgroundTextureMesh.uploadData(false);
    };
    _proto._createPlane = function _createPlane(engine) {
        var mesh = new ModelMesh(engine);
        mesh.isGCIgnored = true;
        var indices = new Uint8Array([
            1,
            2,
            0,
            1,
            3,
            2
        ]);
        var positions = new Array(4);
        var uvs = new Array(4);
        for(var i = 0; i < 4; ++i){
            positions[i] = new Vector3();
            uvs[i] = new Vector2(i % 2, 1 - (i * 0.5 | 0));
        }
        mesh.setPositions(positions);
        mesh.setUVs(uvs);
        mesh.setIndices(indices);
        mesh.uploadData(false);
        mesh.addSubMesh(0, indices.length);
        return mesh;
    };
    _create_class$3(Background, [
        {
            key: "texture",
            get: /**
   * Background texture.
   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
   */ function get() {
                return this._texture;
            },
            set: function set(value) {
                if (this._texture !== value) {
                    var _this__texture;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__texture = this._texture) == null ? void 0 : _this__texture._addReferCount(-1);
                    this._texture = value;
                    this._engine._backgroundTextureMaterial.shaderData.setTexture("material_BaseTexture", value);
                }
            }
        },
        {
            key: "textureFillMode",
            get: /**
   * @internal
   * Background texture fill mode.
   * @remarks When `mode` is `BackgroundMode.Texture`, the property will take effects.
   * @defaultValue `BackgroundTextureFillMode.FitHeight`
   */ function get() {
                return this._textureFillMode;
            },
            set: function set(value) {
                if (value !== this._textureFillMode) {
                    this._textureFillMode = value;
                    this._resizeBackgroundTexture();
                }
            }
        }
    ]);
    return Background;
}();

/**
 * Fog Mode.
 */ exports.FogMode = void 0;
(function(FogMode) {
    FogMode[FogMode[/** Disable fog. */ "None"] = 0] = "None";
    FogMode[FogMode[/** Linear fog. */ "Linear"] = 1] = "Linear";
    FogMode[FogMode[/** Exponential fog. */ "Exponential"] = 2] = "Exponential";
    FogMode[FogMode[/** Exponential squared fog. */ "ExponentialSquared"] = 3] = "ExponentialSquared";
})(exports.FogMode || (exports.FogMode = {}));

/**
 * Diffuse mode.
 */ var DiffuseMode;
(function(DiffuseMode) {
    DiffuseMode[DiffuseMode[/** Solid color mode. */ "SolidColor"] = 0] = "SolidColor";
    DiffuseMode[DiffuseMode[/**
   * SH mode
   * @remarks
   * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
   */ "SphericalHarmonics"] = 1] = "SphericalHarmonics";
})(DiffuseMode || (DiffuseMode = {}));

/**
 * Ambient light.
 */ var AmbientLight = /*#__PURE__*/ function() {
    function AmbientLight() {
        this._diffuseSolidColor = new Color$1(0.212, 0.227, 0.259);
        this._diffuseIntensity = 1.0;
        this._specularIntensity = 1.0;
        this._diffuseMode = DiffuseMode.SolidColor;
        this._shArray = new Float32Array(27);
        this._scenes = [];
        this._specularTextureDecodeRGBM = false;
    }
    var _proto = AmbientLight.prototype;
    /**
   * @internal
   */ _proto._addToScene = function _addToScene(scene) {
        this._scenes.push(scene);
        var shaderData = scene.shaderData;
        shaderData.setColor(AmbientLight._diffuseColorProperty, this._diffuseSolidColor);
        shaderData.setFloat(AmbientLight._diffuseIntensityProperty, this._diffuseIntensity);
        shaderData.setFloat(AmbientLight._specularIntensityProperty, this._specularIntensity);
        shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
        this._setDiffuseMode(shaderData);
        this._setSpecularTextureDecodeRGBM(shaderData);
        this._setSpecularTexture(shaderData);
    };
    /**
   * @internal
   */ _proto._removeFromScene = function _removeFromScene(scene) {
        var scenes = this._scenes;
        var index = scenes.indexOf(scene);
        scenes.splice(index, 1);
    };
    _proto._setDiffuseMode = function _setDiffuseMode(sceneShaderData) {
        if (this._diffuseMode === DiffuseMode.SphericalHarmonics) {
            sceneShaderData.enableMacro(AmbientLight._shMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._shMacro);
        }
    };
    _proto._setSpecularTexture = function _setSpecularTexture(sceneShaderData) {
        if (this._specularTexture) {
            sceneShaderData.setTexture(AmbientLight._specularTextureProperty, this._specularTexture);
            sceneShaderData.setFloat(AmbientLight._mipLevelProperty, this._specularTexture.mipmapCount - 1);
            sceneShaderData.enableMacro(AmbientLight._specularMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._specularMacro);
        }
    };
    _proto._setSpecularTextureDecodeRGBM = function _setSpecularTextureDecodeRGBM(sceneShaderData) {
        if (this._specularTextureDecodeRGBM) {
            sceneShaderData.enableMacro(AmbientLight._decodeRGBMMacro);
        } else {
            sceneShaderData.disableMacro(AmbientLight._decodeRGBMMacro);
        }
    };
    _proto._preComputeSH = function _preComputeSH(sh, out) {
        /**
     * Basis constants
     *
     * 0: 1/2 * Math.sqrt(1 / Math.PI)
     *
     * 1: -1/2 * Math.sqrt(3 / Math.PI)
     * 2: 1/2 * Math.sqrt(3 / Math.PI)
     * 3: -1/2 * Math.sqrt(3 / Math.PI)
     *
     * 4: 1/2 * Math.sqrt(15 / Math.PI)
     * 5: -1/2 * Math.sqrt(15 / Math.PI)
     * 6: 1/4 * Math.sqrt(5 / Math.PI)
     * 7: -1/2 * Math.sqrt(15 / Math.PI)
     * 8: 1/4 * Math.sqrt(15 / Math.PI)
     */ /**
     * Convolution kernel
     *
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */ var src = sh.coefficients;
        // l0
        out[0] = src[0] * 0.886227; // kernel0 * basis0 = 0.886227
        out[1] = src[1] * 0.886227;
        out[2] = src[2] * 0.886227;
        // l1
        out[3] = src[3] * -1.023327; // kernel1 * basis1 = -1.023327;
        out[4] = src[4] * -1.023327;
        out[5] = src[5] * -1.023327;
        out[6] = src[6] * 1.023327; // kernel1 * basis2 = 1.023327
        out[7] = src[7] * 1.023327;
        out[8] = src[8] * 1.023327;
        out[9] = src[9] * -1.023327; // kernel1 * basis3 = -1.023327
        out[10] = src[10] * -1.023327;
        out[11] = src[11] * -1.023327;
        // l2
        out[12] = src[12] * 0.858086; // kernel2 * basis4 = 0.858086
        out[13] = src[13] * 0.858086;
        out[14] = src[14] * 0.858086;
        out[15] = src[15] * -0.858086; // kernel2 * basis5 = -0.858086
        out[16] = src[16] * -0.858086;
        out[17] = src[17] * -0.858086;
        out[18] = src[18] * 0.247708; // kernel2 * basis6 = 0.247708
        out[19] = src[19] * 0.247708;
        out[20] = src[20] * 0.247708;
        out[21] = src[21] * -0.858086; // kernel2 * basis7 = -0.858086
        out[22] = src[22] * -0.858086;
        out[23] = src[23] * -0.858086;
        out[24] = src[24] * 0.429042; // kernel2 * basis8 = 0.429042
        out[25] = src[25] * 0.429042;
        out[26] = src[26] * 0.429042;
    };
    _create_class$3(AmbientLight, [
        {
            key: "specularTextureDecodeRGBM",
            get: /**
   * Whether to decode from specularTexture with RGBM format.
   */ function get() {
                return this._specularTextureDecodeRGBM;
            },
            set: function set(value) {
                this._specularTextureDecodeRGBM = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setSpecularTextureDecodeRGBM(scenes[i].shaderData);
                }
            }
        },
        {
            key: "diffuseMode",
            get: /**
   * Diffuse mode of ambient light.
   */ function get() {
                return this._diffuseMode;
            },
            set: function set(value) {
                this._diffuseMode = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setDiffuseMode(scenes[i].shaderData);
                }
            }
        },
        {
            key: "diffuseSolidColor",
            get: /**
   * Diffuse reflection solid color.
   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SolidColor`.
   */ function get() {
                return this._diffuseSolidColor;
            },
            set: function set(value) {
                if (value !== this._diffuseSolidColor) {
                    this._diffuseSolidColor.copyFrom(value);
                }
            }
        },
        {
            key: "diffuseSphericalHarmonics",
            get: /**
   * Diffuse reflection spherical harmonics 3.
   * @remarks Effective when diffuse reflection mode is `DiffuseMode.SphericalHarmonics`.
   */ function get() {
                return this._diffuseSphericalHarmonics;
            },
            set: function set(value) {
                this._diffuseSphericalHarmonics = value;
                if (value) {
                    this._preComputeSH(value, this._shArray);
                    var scenes = this._scenes;
                    for(var i = 0, n = scenes.length; i < n; i++){
                        scenes[i].shaderData.setFloatArray(AmbientLight._diffuseSHProperty, this._shArray);
                    }
                }
            }
        },
        {
            key: "diffuseIntensity",
            get: /**
   * Diffuse reflection intensity.
   */ function get() {
                return this._diffuseIntensity;
            },
            set: function set(value) {
                this._diffuseIntensity = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    scenes[i].shaderData.setFloat(AmbientLight._diffuseIntensityProperty, value);
                }
            }
        },
        {
            key: "specularTexture",
            get: /**
   * Specular reflection texture.
   */ function get() {
                return this._specularTexture;
            },
            set: function set(value) {
                this._specularTexture = value;
                var scenes = this._scenes;
                for(var i = 0, n = scenes.length; i < n; i++){
                    this._setSpecularTexture(scenes[i].shaderData);
                }
            }
        },
        {
            key: "specularIntensity",
            get: /**
   * Specular reflection intensity.
   */ function get() {
                return this._specularIntensity;
            },
            set: function set(value) {
                this._specularIntensity = value;
                for(var i = 0, n = this._scenes.length; i < n; i++){
                    this._scenes[i].shaderData.setFloat(AmbientLight._specularIntensityProperty, value);
                }
            }
        }
    ]);
    return AmbientLight;
}();
(function() {
    AmbientLight._shMacro = ShaderMacro.getByName("SCENE_USE_SH");
})();
(function() {
    AmbientLight._specularMacro = ShaderMacro.getByName("SCENE_USE_SPECULAR_ENV");
})();
(function() {
    AmbientLight._decodeRGBMMacro = ShaderMacro.getByName("SCENE_IS_DECODE_ENV_RGBM");
})();
(function() {
    AmbientLight._diffuseColorProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuse");
})();
(function() {
    AmbientLight._diffuseSHProperty = ShaderProperty.getByName("scene_EnvSH");
})();
(function() {
    AmbientLight._diffuseIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.diffuseIntensity");
})();
(function() {
    AmbientLight._specularTextureProperty = ShaderProperty.getByName("scene_EnvSpecularSampler");
})();
(function() {
    AmbientLight._specularIntensityProperty = ShaderProperty.getByName("scene_EnvMapLight.specularIntensity");
})();
(function() {
    AmbientLight._mipLevelProperty = ShaderProperty.getByName("scene_EnvMapLight.mipMapLevel");
})();

/**
 * Scene.
 */ var Scene = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(Scene, EngineObject);
    function Scene(engine, name) {
        var _this;
        _this = EngineObject.call(this, engine) || this;
        /** If cast shadows. */ _this.castShadows = true;
        /** The resolution of the shadow maps. */ _this.shadowResolution = ShadowResolution.Medium;
        /** The splits of two cascade distribution. */ _this.shadowTwoCascadeSplits = 1.0 / 3.0;
        /** The splits of four cascade distribution. */ _this.shadowFourCascadeSplits = new Vector3(1.0 / 15, 3.0 / 15.0, 7.0 / 15.0);
        /** Max Shadow distance. */ _this.shadowDistance = 50;
        /** @internal */ _this._activeCameras = [];
        /** @internal */ _this._isActiveInEngine = false;
        /** @internal */ _this._globalShaderMacro = new ShaderMacroCollection();
        /** @internal */ _this._rootEntities = [];
        _this._background = new Background(_this._engine);
        _this._shaderData = new ShaderData(ShaderDataGroup.Scene);
        _this._shadowCascades = ShadowCascadesMode.NoCascades;
        _this._fogMode = exports.FogMode.None;
        _this._fogColor = new Color$1(0.5, 0.5, 0.5, 1.0);
        _this._fogStart = 0;
        _this._fogEnd = 300;
        _this._fogDensity = 0.01;
        _this._fogParams = new Vector4();
        _this.name = name || "";
        var shaderData = _this.shaderData;
        shaderData._addReferCount(1);
        _this.ambientLight = new AmbientLight();
        engine.sceneManager._allScenes.push(_assert_this_initialized(_this));
        shaderData.enableMacro("SCENE_FOG_MODE", _this._fogMode.toString());
        shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", _this.shadowCascades.toString());
        shaderData.setColor(Scene._fogColorProperty, _this._fogColor);
        shaderData.setVector4(Scene._fogParamsProperty, _this._fogParams);
        _this._computeLinearFogParams(_this._fogStart, _this._fogEnd);
        _this._computeExponentialFogParams(_this._fogDensity);
        return _this;
    }
    var _proto = Scene.prototype;
    /**
   * Create root entity.
   * @param name - Entity name
   * @returns Entity
   */ _proto.createRootEntity = function createRootEntity(name) {
        var entity = new Entity(this._engine, name);
        this.addRootEntity(entity);
        return entity;
    };
    _proto.addRootEntity = function addRootEntity(indexOrChild, entity) {
        var index;
        if (typeof indexOrChild === "number") {
            index = indexOrChild;
        } else {
            index = undefined;
            entity = indexOrChild;
        }
        var isRoot = entity._isRoot;
        // let entity become root
        if (!isRoot) {
            entity._isRoot = true;
            entity._removeFromParent();
        }
        // add or remove from scene's rootEntities
        var oldScene = entity._scene;
        if (oldScene !== this) {
            if (oldScene && isRoot) {
                oldScene._removeFromEntityList(entity);
            }
            this._addToRootEntityList(index, entity);
            Entity._traverseSetOwnerScene(entity, this);
        } else if (!isRoot) {
            this._addToRootEntityList(index, entity);
        }
        // process entity active/inActive
        if (this._isActiveInEngine) {
            !entity._isActiveInHierarchy && entity._isActive && entity._processActive();
        } else {
            entity._isActiveInHierarchy && entity._processInActive();
        }
    };
    /**
   * Remove an entity.
   * @param entity - The root entity to remove
   */ _proto.removeRootEntity = function removeRootEntity(entity) {
        if (entity._isRoot && entity._scene == this) {
            this._removeFromEntityList(entity);
            entity._isRoot = false;
            this._isActiveInEngine && entity._isActiveInHierarchy && entity._processInActive();
            Entity._traverseSetOwnerScene(entity, null);
        }
    };
    /**
   * Get root entity from index.
   * @param index - Index
   * @returns Entity
   */ _proto.getRootEntity = function getRootEntity(index) {
        if (index === void 0) index = 0;
        return this._rootEntities[index];
    };
    /**
   * Find entity globally by name.
   * @param name - Entity name
   * @returns Entity
   */ _proto.findEntityByName = function findEntityByName(name) {
        var rootEntities = this._rootEntities;
        for(var i = 0, n = rootEntities.length; i < n; i++){
            var entity = rootEntities[i].findByName(name);
            if (entity) {
                return entity;
            }
        }
        return null;
    };
    /**
   * Find entity globally by name,use â€˜/â€™ symbol as a path separator.
   * @param path - Entity's path
   * @returns Entity
   */ _proto.findEntityByPath = function findEntityByPath(path) {
        var splits = path.split("/").filter(Boolean);
        for(var i = 0, n = this.rootEntitiesCount; i < n; i++){
            var findEntity = this.getRootEntity(i);
            if (findEntity.name != splits[0]) continue;
            for(var j = 1, m = splits.length; j < m; ++j){
                findEntity = Entity._findChildByName(findEntity, splits[j]);
                if (!findEntity) break;
            }
            return findEntity;
        }
        return null;
    };
    /**
   * Destroy this scene.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        this._destroy();
        var allScenes = this.engine.sceneManager._allScenes;
        allScenes.splice(allScenes.indexOf(this), 1);
    };
    /**
   * @internal
   */ _proto._attachRenderCamera = function _attachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);
        if (index === -1) {
            this._activeCameras.push(camera);
        } else {
            Logger.warn("Camera already attached.");
        }
    };
    /**
   * @internal
   */ _proto._detachRenderCamera = function _detachRenderCamera(camera) {
        var index = this._activeCameras.indexOf(camera);
        if (index !== -1) {
            this._activeCameras.splice(index, 1);
        }
    };
    /**
   * @internal
   */ _proto._processActive = function _processActive(active) {
        this._isActiveInEngine = active;
        var rootEntities = this._rootEntities;
        for(var i = rootEntities.length - 1; i >= 0; i--){
            var entity = rootEntities[i];
            if (entity._isActive) {
                active ? entity._processActive() : entity._processInActive();
            }
        }
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData() {
        var shaderData = this.shaderData;
        var engine = this._engine;
        var lightManager = engine._lightManager;
        engine.time._updateSceneShaderData(shaderData);
        lightManager._updateShaderData(this.shaderData);
        var sunLightIndex = lightManager._getSunLightIndex();
        if (sunLightIndex !== -1) {
            var sunlight = lightManager._directLights.get(sunLightIndex);
            shaderData.setColor(Scene._sunlightColorProperty, sunlight._getLightIntensityColor());
            shaderData.setVector3(Scene._sunlightDirectionProperty, sunlight.direction);
            this._sunLight = sunlight;
        } else {
            this._sunLight = null;
        }
        if (this.castShadows && this._sunLight && this._sunLight.shadowType !== exports.ShadowType.None) {
            shaderData.enableMacro("SCENE_SHADOW_TYPE", this._sunLight.shadowType.toString());
        } else {
            shaderData.disableMacro("SCENE_SHADOW_TYPE");
        }
        // union scene and camera macro.
        ShaderMacroCollection.unionCollection(this.engine._macroCollection, shaderData._macroCollection, this._globalShaderMacro);
    };
    /**
   * @internal
   */ _proto._removeFromEntityList = function _removeFromEntityList(entity) {
        var rootEntities = this._rootEntities;
        var index = entity._siblingIndex;
        rootEntities.splice(index, 1);
        for(var n = rootEntities.length; index < n; index++){
            rootEntities[index]._siblingIndex--;
        }
        entity._siblingIndex = -1;
    };
    /**
   * @internal
   */ _proto._destroy = function _destroy() {
        this._isActiveInEngine && (this._engine.sceneManager.activeScene = null);
        while(this.rootEntitiesCount > 0){
            this._rootEntities[0].destroy();
        }
        this._activeCameras.length = 0;
        this.background.destroy();
        this.shaderData._addReferCount(-1);
    };
    _proto._addToRootEntityList = function _addToRootEntityList(index, rootEntity) {
        var rootEntities = this._rootEntities;
        var rootEntityCount = rootEntities.length;
        if (index === undefined) {
            rootEntity._siblingIndex = rootEntityCount;
            rootEntities.push(rootEntity);
        } else {
            if (index < 0 || index > rootEntityCount) {
                throw "The index " + index + " is out of child list bounds " + rootEntityCount;
            }
            rootEntity._siblingIndex = index;
            rootEntities.splice(index, 0, rootEntity);
            for(var i = index + 1, n = rootEntityCount + 1; i < n; i++){
                rootEntities[i]._siblingIndex++;
            }
        }
    };
    _proto._computeLinearFogParams = function _computeLinearFogParams(fogStart, fogEnd) {
        var fogRange = fogEnd - fogStart;
        var fogParams = this._fogParams;
        fogParams.x = -1 / fogRange;
        fogParams.y = fogEnd / fogRange;
    };
    _proto._computeExponentialFogParams = function _computeExponentialFogParams(density) {
        this._fogParams.z = density / Math.LN2;
        this._fogParams.w = density / Math.sqrt(Math.LN2);
    };
    _create_class$3(Scene, [
        {
            key: "shaderData",
            get: /**
   * Scene-related shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "background",
            get: /**
   * The background of the scene.
   */ function get() {
                return this._background;
            }
        },
        {
            key: "shadowCascades",
            get: /**
   *  Number of cascades to use for directional light shadows.
   */ function get() {
                return this._shadowCascades;
            },
            set: function set(value) {
                if (this._shadowCascades !== value) {
                    this.shaderData.enableMacro("SCENE_SHADOW_CASCADED_COUNT", value.toString());
                    this._shadowCascades = value;
                }
            }
        },
        {
            key: "ambientLight",
            get: /**
   * Ambient light.
   */ function get() {
                return this._ambientLight;
            },
            set: function set(value) {
                if (!value) {
                    Logger.warn("The scene must have one ambient light");
                    return;
                }
                var lastAmbientLight = this._ambientLight;
                if (lastAmbientLight !== value) {
                    lastAmbientLight && lastAmbientLight._removeFromScene(this);
                    value._addToScene(this);
                    this._ambientLight = value;
                }
            }
        },
        {
            key: "fogMode",
            get: /**
   * Fog mode.
   * @remarks
   * If set to `FogMode.None`, the fog will be disabled.
   * If set to `FogMode.Linear`, the fog will be linear and controlled by `fogStart` and `fogEnd`.
   * If set to `FogMode.Exponential`, the fog will be exponential and controlled by `fogDensity`.
   * If set to `FogMode.ExponentialSquared`, the fog will be exponential squared and controlled by `fogDensity`.
   */ function get() {
                return this._fogMode;
            },
            set: function set(value) {
                if (this._fogMode !== value) {
                    this.shaderData.enableMacro("SCENE_FOG_MODE", value.toString());
                    this._fogMode = value;
                }
            }
        },
        {
            key: "fogColor",
            get: /**
   * Fog color.
   */ function get() {
                return this._fogColor;
            },
            set: function set(value) {
                if (this._fogColor !== value) {
                    this._fogColor.copyFrom(value);
                }
            }
        },
        {
            key: "fogStart",
            get: /**
   * Fog start.
   */ function get() {
                return this._fogStart;
            },
            set: function set(value) {
                if (this._fogStart !== value) {
                    this._computeLinearFogParams(value, this._fogEnd);
                    this._fogStart = value;
                }
            }
        },
        {
            key: "fogEnd",
            get: /**
   * Fog end.
   */ function get() {
                return this._fogEnd;
            },
            set: function set(value) {
                if (this._fogEnd !== value) {
                    this._computeLinearFogParams(this._fogStart, value);
                    this._fogEnd = value;
                }
            }
        },
        {
            key: "fogDensity",
            get: /**
   * Fog density.
   */ function get() {
                return this._fogDensity;
            },
            set: function set(value) {
                if (this._fogDensity !== value) {
                    this._computeExponentialFogParams(value);
                    this._fogDensity = value;
                }
            }
        },
        {
            key: "rootEntitiesCount",
            get: /**
   * Count of root entities.
   */ function get() {
                return this._rootEntities.length;
            }
        },
        {
            key: "rootEntities",
            get: /**
   * Root entity collection.
   */ function get() {
                return this._rootEntities;
            }
        }
    ]);
    return Scene;
}(EngineObject);
(function() {
    Scene._fogColorProperty = ShaderProperty.getByName("scene_FogColor");
})();
(function() {
    Scene._fogParamsProperty = ShaderProperty.getByName("scene_FogParams");
})();
(function() {
    Scene._sunlightColorProperty = ShaderProperty.getByName("scene_SunlightColor");
})();
(function() {
    Scene._sunlightDirectionProperty = ShaderProperty.getByName("scene_SunlightDirection");
})();

/**
 * Scene manager.
 */ var SceneManager = /*#__PURE__*/ function() {
    function SceneManager(engine) {
        this.engine = engine;
        this./** @internal */ _allScenes = [];
    }
    var _proto = SceneManager.prototype;
    /**
   * Load and activate scene.
   * @param url - the path of the scene
   * @param destroyOldScene - whether to destroy old scene information
   * @returns scene promise
   */ _proto.loadScene = function loadScene(url, destroyOldScene) {
        if (destroyOldScene === void 0) destroyOldScene = true;
        var _this = this;
        var scenePromise = this.engine.resourceManager.load(url);
        scenePromise.then(function(scene) {
            var oldScene = _this._activeScene;
            _this.activeScene = scene;
            if (oldScene && destroyOldScene) {
                oldScene.destroy();
            }
        });
        return scenePromise;
    };
    /**
   * Merge the source scene into the target scene.
   * @remarks the global information of destScene will be used after the merge, and the lightingMap information will be merged.
   * @param sourceScene - source scene
   * @param destScene - target scene
   */ _proto.mergeScenes = function mergeScenes(sourceScene, destScene) {
        var oldRootEntities = sourceScene.rootEntities;
        for(var i = 0, n = oldRootEntities.length; i < n; i++){
            destScene.addRootEntity(oldRootEntities[i]);
        }
    };
    /**
   * @internal
   */ _proto._destroyAllScene = function _destroyAllScene() {
        var allScenes = this._allScenes;
        for(var i = 0, n = allScenes.length; i < n; i++){
            allScenes[i]._destroy();
        }
        allScenes.length = 0;
    };
    _create_class$3(SceneManager, [
        {
            key: "activeScene",
            get: /**
   * Get the activated scene.
   */ function get() {
                return this._activeScene;
            },
            set: function set(scene) {
                var oldScene = this._activeScene;
                if (oldScene !== scene) {
                    oldScene && oldScene._processActive(false);
                    scene && scene._processActive(true);
                    this._activeScene = scene;
                }
            }
        }
    ]);
    return SceneManager;
}();

var backgroundTextureFs = "#define GLSLIFY 1\nuniform sampler2D material_BaseTexture;varying vec2 v_uv;void main(){gl_FragColor=texture2D(material_BaseTexture,v_uv);}"; // eslint-disable-line

var backgroundTextureVs = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var blinnPhongFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <ShadowFragmentDeclaration>\n#include <mobile_material_frag>\n#include <FogFragmentDeclaration>\n#include <normal_get>\nvoid main(){\n#include <begin_mobile_frag>\n#include <begin_viewdir_frag>\n#include <mobile_blinnphong_frag>\ngl_FragColor=emission+ambient+diffuse+specular;\n#ifdef MATERIAL_IS_TRANSPARENT\ngl_FragColor.a=diffuse.a;\n#else\ngl_FragColor.a=1.0;\n#endif\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var blinnPhongVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <position_vert>\n#include <ShadowVertex>\n#include <FogVertex>\n}"; // eslint-disable-line

var particleFs = "#define GLSLIFY 1\nvarying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;uniform sampler2D u_texture;void main(){if(v_lifeLeft==1.0){discard;}float alphaFactor=1.0;\n#ifdef fadeIn\nfloat fadeInFactor=step(0.5,v_lifeLeft);alphaFactor=2.0*fadeInFactor*(1.0-v_lifeLeft)+(1.0-fadeInFactor);\n#endif\n#ifdef fadeOut\nfloat fadeOutFactor=step(0.5,v_lifeLeft);alphaFactor=alphaFactor*2.0*(1.0-fadeOutFactor)*v_lifeLeft+alphaFactor*fadeOutFactor;\n#endif\n#ifdef particleTexture\nvec4 tex=texture2D(u_texture,v_uv);\n#ifdef useOriginColor\ngl_FragColor=vec4(tex.rgb,alphaFactor*tex.a*v_color.w);\n#else\ngl_FragColor=vec4(v_color.xyz*tex.rgb,alphaFactor*tex.a*v_color.w);\n#endif\n#else\ngl_FragColor=vec4(v_color.xyz,alphaFactor*v_color.w);\n#endif\n}"; // eslint-disable-line

var particleVs = "#define GLSLIFY 1\nattribute vec3 a_position;attribute vec3 a_velocity;attribute vec3 a_acceleration;attribute vec4 a_color;attribute vec4 a_lifeAndSize;attribute vec2 a_rotation;attribute vec3 a_uv;attribute vec2 a_normalizedUv;uniform float u_time;uniform bool u_once;uniform mat4 renderer_MVPMat;varying vec4 v_color;varying float v_lifeLeft;varying vec2 v_uv;\n#ifdef is2d\nuniform mat4 camera_ViewInvMat;uniform mat4 camera_ProjMat;uniform mat4 camera_ViewMat;uniform mat4 renderer_ModelMat;\n#endif\nmat2 rotation2d(float angle){float s=sin(angle);float c=cos(angle);return mat2(c,-s,s,c);}void main(){v_color=a_color;v_uv=a_uv.xy;float life=a_lifeAndSize.y;float startTime=a_lifeAndSize.x;float deltaTime=max(mod(u_time-startTime,life),0.0);if((u_once&&u_time>life+startTime)){deltaTime=0.0;}v_lifeLeft=1.0-deltaTime/life;float scale=a_lifeAndSize.z;vec3 position=a_position+(a_velocity+a_acceleration*deltaTime*0.5)*deltaTime;\n#ifdef isScaleByLifetime\nscale*=v_lifeLeft;\n#else\nscale*=pow(a_lifeAndSize.w,deltaTime);\n#endif\n#ifdef rotateToVelocity\nvec3 v=a_velocity+a_acceleration*deltaTime;float angle=atan(v.z,v.x)*2.0;\n#else\nfloat deltaAngle=deltaTime*a_rotation.y;float angle=a_rotation.x+deltaAngle;\n#endif\n#ifdef is2d\nvec2 rotatedPoint=rotation2d(angle)*vec2(a_normalizedUv.x,a_normalizedUv.y*a_uv.z);vec3 basisX=camera_ViewInvMat[0].xyz;vec3 basisZ=camera_ViewInvMat[1].xyz;vec3 localPosition=vec3(basisX*rotatedPoint.x+basisZ*rotatedPoint.y)*scale+position;gl_Position=camera_ProjMat*camera_ViewMat*vec4(localPosition+renderer_ModelMat[3].xyz,1.);\n#else\n#ifdef rotateToVelocity\nfloat s=sin(angle);float c=cos(angle);\n#else\nfloat s=sin(angle);float c=cos(angle);\n#endif\nvec4 rotatedPoint=vec4((a_normalizedUv.x*c+a_normalizedUv.y*a_uv.z*s)*scale,0.,(a_normalizedUv.x*s-a_normalizedUv.y*a_uv.z*c)*scale,1.);vec4 orientation=vec4(0,0,0,1);vec4 q2=orientation+orientation;vec4 qx=orientation.xxxw*q2.xyzx;vec4 qy=orientation.xyyw*q2.xyzy;vec4 qz=orientation.xxzw*q2.xxzz;mat4 localMatrix=mat4((1.0-qy.y)-qz.z,qx.y+qz.w,qx.z-qy.w,0,qx.y-qz.w,(1.0-qx.x)-qz.z,qy.z+qx.w,0,qx.z+qy.w,qy.z-qx.w,(1.0-qx.x)-qy.y,0,position.x,position.y,position.z,1);rotatedPoint=localMatrix*rotatedPoint;gl_Position=renderer_MVPMat*rotatedPoint;\n#endif\n}"; // eslint-disable-line

var pbrSpecularFs = "#define GLSLIFY 1\n#include <common>\n#include <camera_declare>\n#include <FogFragmentDeclaration>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var pbrFs = "#define GLSLIFY 1\n#define IS_METALLIC_WORKFLOW\n#include <common>\n#include <camera_declare>\n#include <FogFragmentDeclaration>\n#include <uv_share>\n#include <normal_share>\n#include <color_share>\n#include <worldpos_share>\n#include <light_frag_define>\n#include <pbr_frag_define>\n#include <pbr_helper>\nvoid main(){\n#include <pbr_frag>\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var pbrVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <color_share>\n#include <normal_share>\n#include <worldpos_share>\n#include <ShadowVertexDeclaration>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <color_vert>\n#include <normal_vert>\n#include <worldpos_vert>\n#include <position_vert>\n#include <ShadowVertex>\n#include <FogVertex>\n}"; // eslint-disable-line

var shadowMapFs = "#define GLSLIFY 1\n#ifdef ENGINE_NO_DEPTH_TEXTURE\nvec4 pack(float depth){const vec4 bitShift=vec4(1.0,256.0,256.0*256.0,256.0*256.0*256.0);const vec4 bitMask=vec4(1.0/256.0,1.0/256.0,1.0/256.0,0.0);vec4 rgbaDepth=fract(depth*bitShift);rgbaDepth-=rgbaDepth.gbaa*bitMask;return rgbaDepth;}\n#endif\nvoid main(){\n#ifdef ENGINE_NO_DEPTH_TEXTURE\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\n#endif\n}"; // eslint-disable-line

var shadowMapVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <normal_share>\nuniform mat4 camera_VPMat;uniform vec2 scene_ShadowBias;uniform vec3 scene_LightDirection;vec3 applyShadowBias(vec3 positionWS){positionWS-=scene_LightDirection*scene_ShadowBias.x;return positionWS;}vec3 applyShadowNormalBias(vec3 positionWS,vec3 normalWS){float invNdotL=1.0-clamp(dot(-scene_LightDirection,normalWS),0.0,1.0);float scale=invNdotL*scene_ShadowBias.y;positionWS+=normalWS*vec3(scale);return positionWS;}void main(){\n#include <begin_position_vert>\n#include <begin_normal_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\nvec4 positionWS=renderer_ModelMat*position;positionWS.xyz=applyShadowBias(positionWS.xyz);\n#ifndef MATERIAL_OMIT_NORMAL\n#ifdef RENDERER_HAS_NORMAL\nvec3 normalWS=normalize(mat3(renderer_NormalMat)*normal);positionWS.xyz=applyShadowNormalBias(positionWS.xyz,normalWS);\n#endif\n#endif\nvec4 positionCS=camera_VPMat*positionWS;positionCS.z=max(positionCS.z,-1.0);gl_Position=positionCS;}"; // eslint-disable-line

var skyboxFs = "#define GLSLIFY 1\n#include <common>\nuniform samplerCube material_CubeTexture;varying vec3 v_cubeUV;uniform float material_Exposure;uniform vec4 material_TintColor;void main(){vec4 textureColor=textureCube(material_CubeTexture,v_cubeUV);\n#ifdef MATERIAL_IS_DECODE_SKY_RGBM\ntextureColor=RGBMToLinear(textureColor,5.0);\n#elif !defined(ENGINE_IS_COLORSPACE_GAMMA)\ntextureColor=gammaToLinear(textureColor);\n#endif\ntextureColor.rgb*=material_Exposure*material_TintColor.rgb;gl_FragColor=textureColor;\n#if defined(MATERIAL_IS_DECODE_SKY_RGBM) || !defined(ENGINE_IS_COLORSPACE_GAMMA)\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var skyboxVs = "#define GLSLIFY 1\n#include <common_vert>\nuniform mat4 camera_VPMat;varying vec3 v_cubeUV;uniform float material_Rotation;vec4 rotateY(vec4 v,float angle){const float deg2rad=3.1415926/180.0;float radian=angle*deg2rad;float sina=sin(radian);float cosa=cos(radian);mat2 m=mat2(cosa,-sina,sina,cosa);return vec4(m*v.xz,v.yw).xzyw;}void main(){v_cubeUV=vec3(-POSITION.x,POSITION.yz);gl_Position=camera_VPMat*rotateY(vec4(POSITION,1.0),material_Rotation);}"; // eslint-disable-line

var skyProceduralFs = "#define GLSLIFY 1\n#include <common>\nconst float MIE_G=-0.990;const float MIE_G2=0.9801;const float SKY_GROUND_THRESHOLD=0.02;uniform float material_SunSize;uniform float material_SunSizeConvergence;uniform vec4 scene_SunlightColor;uniform vec3 scene_SunlightDirection;varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\n#if defined(ENGINE_IS_COLORSPACE_GAMMA)\n#define LINEAR_2_OUTPUT(color) sqrt(color)\n#endif\nfloat getMiePhase(float eyeCos,float eyeCos2){float temp=1.0+MIE_G2-2.0*MIE_G*eyeCos;temp=pow(temp,pow(material_SunSize,0.65)*10.0);temp=max(temp,1.0e-4);temp=1.5*((1.0-MIE_G2)/(2.0+MIE_G2))*(1.0+eyeCos2)/temp;return temp;}float calcSunAttenuation(vec3 lightPos,vec3 ray){\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nfloat focusedEyeCos=pow(clamp(dot(lightPos,ray),0.0,1.0),material_SunSizeConvergence);return getMiePhase(-focusedEyeCos,focusedEyeCos*focusedEyeCos);\n#else\nvec3 delta=lightPos-ray;float dist=length(delta);float spot=1.0-smoothstep(0.0,material_SunSize,dist);return spot*spot;\n#endif\n}void main(){vec3 col=vec3(0.0,0.0,0.0);\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvec3 ray=normalize(v_Vertex);float y=ray.y/SKY_GROUND_THRESHOLD;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvec3 ray=v_RayDir;float y=ray.y/SKY_GROUND_THRESHOLD;\n#else\nfloat y=v_SkyGroundFactor;\n#endif\ncol=mix(v_SkyColor,v_GroundColor,clamp(y,0.0,1.0));\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nif(y<0.0)col+=v_SunColor*calcSunAttenuation(-scene_SunlightDirection,-ray);\n#endif\n#ifdef ENGINE_IS_COLORSPACE_GAMMA\ncol=LINEAR_2_OUTPUT(col);\n#endif\ngl_FragColor=vec4(col,1.0);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var skyProceduralVs = "#define GLSLIFY 1\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(material_AtmosphereThickness,2.5)))\n#define MIE 0.0010\n#define SUN_BRIGHTNESS 20.0\n#define MAX_SCATTER 50.0\nconst float SKY_GROUND_THRESHOLD=0.02;const float outerRadius=OUTER_RADIUS;const float outerRadius2=OUTER_RADIUS*OUTER_RADIUS;const float innerRadius=1.0;const float innerRadius2=1.0;const float cameraHeight=0.0001;const float HDSundiskIntensityFactor=15.0;const float simpleSundiskIntensityFactor=27.0;const float sunScale=400.0*SUN_BRIGHTNESS;const float kmESun=MIE*SUN_BRIGHTNESS;const float km4PI=MIE*4.0*3.14159265;const float scale=1.0/(OUTER_RADIUS-1.0);const float scaleDepth=0.25;const float scaleOverScaleDepth=(1.0/(OUTER_RADIUS-1.0))/0.25;const float samples=2.0;const vec3 c_DefaultScatteringWavelength=vec3(0.65,0.57,0.475);const vec3 c_VariableRangeForScatteringWavelength=vec3(0.15,0.15,0.15);attribute vec4 POSITION;uniform mat4 camera_VPMat;uniform vec3 material_SkyTint;uniform vec3 material_GroundTint;uniform float material_Exposure;uniform float material_AtmosphereThickness;uniform vec4 scene_SunlightColor;uniform vec3 scene_SunlightDirection;varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(MATERIAL_SUN_HIGH_QUALITY)||defined(MATERIAL_SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\n#if defined(ENGINE_IS_COLORSPACE_GAMMA)\n#define COLOR_2_GAMMA(color) color\n#define COLOR_2_LINEAR(color) color*color\n#else\n#define GAMMA 2.2\n#define COLOR_2_GAMMA(color) pow(color,vec3(1.0/GAMMA))\n#define COLOR_2_LINEAR(color) color\n#endif\nfloat getRayleighPhase(vec3 light,vec3 ray){float eyeCos=dot(light,ray);return 0.75+0.75*eyeCos*eyeCos;}float scaleAngle(float inCos){float x=1.0-inCos;return 0.25*exp(-0.00287+x*(0.459+x*(3.83+x*(-6.80+x*5.25))));}void main(){gl_Position=camera_VPMat*vec4(POSITION.xyz,1.0);vec3 skyTintInGammaSpace=COLOR_2_GAMMA(material_SkyTint);vec3 scatteringWavelength=mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0)-skyTintInGammaSpace);vec3 invWavelength=1.0/pow(scatteringWavelength,vec3(4.0));float krESun=RAYLEIGH*SUN_BRIGHTNESS;float kr4PI=RAYLEIGH*4.0*3.14159265;vec3 cameraPos=vec3(0.0,innerRadius+cameraHeight,0.0);vec3 eyeRay=normalize(POSITION.xyz);float far=0.0;vec3 cIn,cOut;if(eyeRay.y>=0.0){far=sqrt(outerRadius2+innerRadius2*eyeRay.y*eyeRay.y-innerRadius2)-innerRadius*eyeRay.y;float height=innerRadius+cameraHeight;float depth=exp(scaleOverScaleDepth*-cameraHeight);float startAngle=dot(eyeRay,cameraPos)/height;float startOffset=depth*scaleAngle(startAngle);float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0);{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-scene_SunlightDirection,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-scene_SunlightDirection,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun);cOut=frontColor*kmESun;}else{far=(-cameraHeight)/(min(-0.001,eyeRay.y));vec3 pos=cameraPos+far*eyeRay;float depth=exp((-cameraHeight)*(1.0/scaleDepth));float cameraAngle=dot(-eyeRay,pos);float lightAngle=dot(-scene_SunlightDirection,pos);float cameraScale=scaleAngle(cameraAngle);float lightScale=scaleAngle(lightAngle);float cameraOffset=depth*cameraScale;float temp=lightScale+cameraScale;float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0,0.0,0.0);vec3 attenuate;{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float scatter=depth*temp-cameraOffset;attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun+kmESun);cOut=clamp(attenuate,0.0,1.0);}\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nv_Vertex=-POSITION.xyz;\n#elif defined(MATERIAL_SUN_SIMPLE)\nv_RayDir=-eyeRay;\n#else\nv_SkyGroundFactor=-eyeRay.y/SKY_GROUND_THRESHOLD;\n#endif\nv_GroundColor=material_Exposure*(cIn+COLOR_2_LINEAR(material_GroundTint)*cOut);v_SkyColor=material_Exposure*(cIn*getRayleighPhase(-scene_SunlightDirection,-eyeRay));float lightColorIntensity=clamp(length(scene_SunlightColor.xyz),0.25,1.0);\n#ifdef MATERIAL_SUN_HIGH_QUALITY\nv_SunColor=HDSundiskIntensityFactor*clamp(cOut,0.0,1.0)*scene_SunlightColor.xyz/lightColorIntensity;\n#elif defined(MATERIAL_SUN_SIMPLE)\nv_SunColor=simpleSundiskIntensityFactor*clamp(cOut*sunScale,0.0,1.0)*scene_SunlightColor.xyz/lightColorIntensity;\n#endif\n}"; // eslint-disable-line

var spriteMaskFs = "#define GLSLIFY 1\nuniform sampler2D renderer_MaskTexture;uniform float renderer_MaskAlphaCutoff;varying vec2 v_uv;void main(){vec4 color=texture2D(renderer_MaskTexture,v_uv);if(color.a<renderer_MaskAlphaCutoff){discard;}gl_FragColor=color;}"; // eslint-disable-line

var spriteMaskVs = "#define GLSLIFY 1\nuniform mat4 camera_VPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;void main(){gl_Position=camera_VPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

var spriteFs = "#define GLSLIFY 1\nuniform sampler2D renderer_SpriteTexture;varying vec2 v_uv;varying vec4 v_color;void main(){vec4 baseColor=texture2D(renderer_SpriteTexture,v_uv);gl_FragColor=baseColor*v_color;}"; // eslint-disable-line

var spriteVs = "#define GLSLIFY 1\nuniform mat4 renderer_MVPMat;attribute vec3 POSITION;attribute vec2 TEXCOORD_0;attribute vec4 COLOR_0;varying vec2 v_uv;varying vec4 v_color;void main(){gl_Position=renderer_MVPMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;v_color=COLOR_0;}"; // eslint-disable-line

var unlitFs = "#define GLSLIFY 1\n#include <common>\n#include <uv_share>\n#include <FogFragmentDeclaration>\nuniform vec4 material_BaseColor;uniform float material_AlphaCutoff;\n#ifdef MATERIAL_HAS_BASETEXTURE\nuniform sampler2D material_BaseTexture;\n#endif\nvoid main(){vec4 baseColor=material_BaseColor;\n#ifdef MATERIAL_HAS_BASETEXTURE\nvec4 textureColor=texture2D(material_BaseTexture,v_uv);\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ntextureColor=gammaToLinear(textureColor);\n#endif\nbaseColor*=textureColor;\n#endif\n#ifdef MATERIAL_IS_ALPHA_CUTOFF\nif(baseColor.a<material_AlphaCutoff){discard;}\n#endif\ngl_FragColor=baseColor;\n#ifndef MATERIAL_IS_TRANSPARENT\ngl_FragColor.a=1.0;\n#endif\n#include <FogFragment>\n#ifndef ENGINE_IS_COLORSPACE_GAMMA\ngl_FragColor=linearToGamma(gl_FragColor);\n#endif\n}"; // eslint-disable-line

var unlitVs = "#define GLSLIFY 1\n#include <common>\n#include <common_vert>\n#include <blendShape_input>\n#include <uv_share>\n#include <FogVertexDeclaration>\nvoid main(){\n#include <begin_position_vert>\n#include <blendShape_vert>\n#include <skinning_vert>\n#include <uv_vert>\n#include <position_vert>\n#include <FogVertex>\n}"; // eslint-disable-line

/**
 * Internal shader pool.
 * @internal
 */ var ShaderPool = /*#__PURE__*/ function() {
    function ShaderPool() {}
    ShaderPool.init = function init() {
        var shadowCasterPassTags = {
            pipelineStage: PipelineStage.ShadowCaster
        };
        var forwardPassTags = {
            pipelineStage: PipelineStage.Forward
        };
        var shadowCasterPass = new ShaderPass(shadowMapVs, shadowMapFs, shadowCasterPassTags);
        Shader.create("blinn-phong", [
            new ShaderPass(blinnPhongVs, blinnPhongFs, forwardPassTags),
            shadowCasterPass
        ]);
        Shader.create("pbr", [
            new ShaderPass(pbrVs, pbrFs, forwardPassTags),
            shadowCasterPass
        ]);
        Shader.create("pbr-specular", [
            new ShaderPass(pbrVs, pbrSpecularFs, forwardPassTags),
            shadowCasterPass
        ]);
        Shader.create("unlit", [
            new ShaderPass(unlitVs, unlitFs, forwardPassTags),
            shadowCasterPass
        ]);
        Shader.create("skybox", [
            new ShaderPass(skyboxVs, skyboxFs, forwardPassTags)
        ]);
        Shader.create("SkyProcedural", [
            new ShaderPass(skyProceduralVs, skyProceduralFs, forwardPassTags)
        ]);
        Shader.create("particle-shader", [
            new ShaderPass(particleVs, particleFs, forwardPassTags)
        ]);
        Shader.create("SpriteMask", [
            new ShaderPass(spriteMaskVs, spriteMaskFs, forwardPassTags)
        ]);
        Shader.create("Sprite", [
            new ShaderPass(spriteVs, spriteFs, forwardPassTags)
        ]);
        Shader.create("background-texture", [
            new ShaderPass(backgroundTextureVs, backgroundTextureFs, forwardPassTags)
        ]);
    };
    return ShaderPool;
}();

/**
 * Shader program pool.
 * @internal
 */ var ShaderProgramPool = /*#__PURE__*/ function() {
    function ShaderProgramPool() {
        this._cacheHierarchy = 1;
        this._cacheMap = Object.create(null);
    }
    var _proto = ShaderProgramPool.prototype;
    /**
   * Get shader program by macro collection.
   * @param macros - macro collection
   * @returns shader program
   */ _proto.get = function get(macros) {
        var cacheMap = this._cacheMap;
        var maskLength = macros._length;
        if (maskLength > this._cacheHierarchy) {
            this._resizeCacheMapHierarchy(cacheMap, 0, maskLength);
        }
        var mask = macros._mask;
        var endIndex = macros._length - 1;
        var maxEndIndex = this._cacheHierarchy - 1;
        for(var i = 0; i < maxEndIndex; i++){
            var subMask = endIndex < i ? 0 : mask[i];
            var subCacheShaders = cacheMap[subMask];
            subCacheShaders || (cacheMap[subMask] = subCacheShaders = Object.create(null));
            cacheMap = subCacheShaders;
        }
        var cacheKey = endIndex < maxEndIndex ? 0 : mask[maxEndIndex];
        var shader = cacheMap[cacheKey];
        if (!shader) {
            this._lastQueryKey = cacheKey;
            this._lastQueryMap = cacheMap;
        }
        return shader;
    };
    /**
   * Cache the shader program.
   *
   * @remarks
   * The method must return an empty value after calling get() to run normally.
   *
   * @param shaderProgram - shader program
   */ _proto.cache = function cache(shaderProgram) {
        this._lastQueryMap[this._lastQueryKey] = shaderProgram;
    };
    _proto._resizeCacheMapHierarchy = function _resizeCacheMapHierarchy(cacheMap, hierarchy, resizeLength) {
        // only expand but not shrink.
        var end = this._cacheHierarchy - 1;
        if (hierarchy == end) {
            for(var k in cacheMap){
                var shader = cacheMap[k];
                var subCacheMap = cacheMap;
                for(var i = 0, n = resizeLength - end; i < n; i++){
                    if (i == n - 1) {
                        subCacheMap[0] = shader;
                    } else {
                        subCacheMap = subCacheMap[i == 0 ? k : 0] = Object.create(null);
                    }
                }
            }
            this._cacheHierarchy = resizeLength;
        } else {
            for(var k1 in cacheMap){
                this._resizeCacheMapHierarchy(cacheMap[k1], ++hierarchy, resizeLength);
            }
        }
    };
    return ShaderProgramPool;
}();

ShaderPool.init();
/**
 * Engine.
 */ var Engine = /*#__PURE__*/ function(EventDispatcher) {
    _inherits$2(Engine, EventDispatcher);
    function Engine(canvas, hardwareRenderer, configuration) {
        var _this;
        _this = EventDispatcher.call(this) || this;
        /* @internal */ _this._lightManager = new LightManager();
        /* @internal */ _this._componentsManager = new ComponentsManager();
        /* @internal */ _this._lastRenderState = new RenderState();
        /* @internal */ _this._renderElementPool = new ClassPool(RenderElement);
        /* @internal */ _this._meshRenderDataPool = new ClassPool(MeshRenderData);
        /* @internal */ _this._spriteRenderDataPool = new ClassPool(SpriteRenderData);
        /* @internal */ _this._spriteMaskRenderDataPool = new ClassPool(SpriteMaskRenderData);
        /* @internal */ _this._textRenderDataPool = new ClassPool(TextRenderData);
        /* @internal */ _this._renderContext = new RenderContext();
        /* @internal */ _this._renderCount = 0;
        /* @internal */ _this._shaderProgramPools = [];
        /** @internal */ _this._canSpriteBatch = true;
        /** @internal */ _this._fontMap = {};
        /** @internal @todo: temporary solution */ _this._macroCollection = new ShaderMacroCollection();
        _this._settings = {};
        _this._resourceManager = new ResourceManager(_assert_this_initialized(_this));
        _this._sceneManager = new SceneManager(_assert_this_initialized(_this));
        _this._vSyncCount = 1;
        _this._targetFrameRate = 60;
        _this._time = new Time();
        _this._isPaused = true;
        _this._vSyncCounter = 1;
        _this._targetFrameInterval = 1000 / 60;
        _this._destroyed = false;
        _this._frameInProcess = false;
        _this._waitingDestroy = false;
        _this._isDeviceLost = false;
        _this._waitingGC = false;
        _this._animate = function() {
            if (_this._vSyncCount) {
                _this._requestId = PlatformManager$1.polyfill.requestAnimationFrame(_this._animate);
                if (_this._vSyncCounter++ % _this._vSyncCount === 0) {
                    _this.update();
                    _this._vSyncCounter = 1;
                }
            } else {
                _this._timeoutId = PlatformManager$1.polyfill.window.setTimeout(_this._animate, _this._targetFrameInterval);
                _this.update();
            }
        };
        _this._hardwareRenderer = hardwareRenderer;
        _this._hardwareRenderer.init(canvas, _this._onDeviceLost.bind(_assert_this_initialized(_this)), _this._onDeviceRestored.bind(_assert_this_initialized(_this)));
        _this.physicsManager = new PhysicsManager(_assert_this_initialized(_this));
        _this._canvas = canvas;
        _this._sceneManager.activeScene = new Scene(_assert_this_initialized(_this), "DefaultScene");
        _this._spriteMaskManager = new SpriteMaskManager(_assert_this_initialized(_this));
        _this._spriteDefaultMaterial = _this._createSpriteMaterial();
        _this._spriteMaskDefaultMaterial = _this._createSpriteMaskMaterial();
        _this._textDefaultFont = Font.createFromOS(_assert_this_initialized(_this), "Arial");
        _this._textDefaultFont.isGCIgnored = true;
        _this.inputManager = new InputManager(_assert_this_initialized(_this));
        _this._initMagentaTextures(hardwareRenderer);
        if (!hardwareRenderer.canIUse(GLCapabilityType.depthTexture)) {
            _this._macroCollection.enable(Engine._noDepthTextureMacro);
        } else {
            var depthTexture2D = new Texture2D(_assert_this_initialized(_this), 1, 1, TextureFormat.Depth16, false);
            depthTexture2D.isGCIgnored = true;
            _this._depthTexture2D = depthTexture2D;
        }
        var magentaMaterial = new Material(_assert_this_initialized(_this), Shader.find("unlit"));
        magentaMaterial.isGCIgnored = true;
        magentaMaterial.shaderData.setColor("material_BaseColor", new Color(1.0, 0.0, 1.01, 1.0));
        _this._magentaMaterial = magentaMaterial;
        var backgroundTextureMaterial = new Material(_assert_this_initialized(_this), Shader.find("background-texture"));
        backgroundTextureMaterial.isGCIgnored = true;
        backgroundTextureMaterial.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        _this._backgroundTextureMaterial = backgroundTextureMaterial;
        var innerSettings = _this._settings;
        var colorSpace = configuration.colorSpace || ColorSpace.Linear;
        colorSpace === ColorSpace.Gamma && _this._macroCollection.enable(Engine._gammaMacro);
        innerSettings.colorSpace = colorSpace;
        return _this;
    }
    var _proto = Engine.prototype;
    /**
   * Create an entity.
   * @param name - The name of the entity
   * @returns Entity
   */ _proto.createEntity = function createEntity(name) {
        return new Entity(this, name);
    };
    /**
   * Pause the engine.
   */ _proto.pause = function pause() {
        this._isPaused = true;
        PlatformManager$1.polyfill.cancelAnimationFrame(this._requestId);
        clearTimeout(this._timeoutId);
    };
    /**
   * Resume the engine.
   */ _proto.resume = function resume() {
        if (!this._isPaused) return;
        this._isPaused = false;
        this.time._reset();
        this._requestId = PlatformManager$1.polyfill.requestAnimationFrame(this._animate);
    };
    /**
   * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
   */ _proto.update = function update() {
        if (this._isDeviceLost) {
            return;
        }
        var time = this._time;
        time._update();
        var deltaTime = time.deltaTime;
        this._frameInProcess = true;
        this._renderElementPool.resetPool();
        this._meshRenderDataPool.resetPool();
        this._spriteRenderDataPool.resetPool();
        this._spriteMaskRenderDataPool.resetPool();
        this._textRenderDataPool.resetPool();
        var scene = this._sceneManager._activeScene;
        var componentsManager = this._componentsManager;
        if (scene) {
            scene._activeCameras.sort(function(camera1, camera2) {
                return camera1.priority - camera2.priority;
            });
            componentsManager.callScriptOnStart();
            this.physicsManager._initialized && this.physicsManager._update(deltaTime);
            this.inputManager._update();
            componentsManager.callScriptOnUpdate(deltaTime);
            componentsManager.callAnimationUpdate(deltaTime);
            componentsManager.callScriptOnLateUpdate(deltaTime);
            this._render(scene);
        }
        if (!this._waitingDestroy) {
            componentsManager.handlingInvalidScripts();
        }
        if (this._waitingDestroy) {
            this._destroy();
        }
        if (this._waitingGC) {
            this._gc();
            this._waitingGC = false;
        }
        this._frameInProcess = false;
    };
    /**
   * Execution engine loop.
   */ _proto.run = function run() {
        this.resume();
        this.dispatch("run", this);
    };
    /**
   * Force lose graphic device.
   * @remarks Used to simulate the phenomenon after the real loss of device.
   */ _proto.forceLoseDevice = function forceLoseDevice() {
        this._hardwareRenderer.forceLoseDevice();
    };
    /**
   * Force restore graphic device.
   * @remarks Used to simulate the phenomenon after the real restore of device.
   */ _proto.forceRestoreDevice = function forceRestoreDevice() {
        this._hardwareRenderer.forceRestoreDevice();
    };
    _proto._destroy = function _destroy() {
        this._sceneManager._destroyAllScene();
        this._componentsManager.handlingInvalidScripts();
        this._resourceManager._destroy();
        this._magentaTexture2D.destroy(true);
        this._magentaTextureCube.destroy(true);
        this._textDefaultFont = null;
        this._fontMap = null;
        this.inputManager._destroy();
        this.dispatch("shutdown", this);
        // Cancel animation
        this.pause();
        this._spriteMaskManager.destroy();
        this._hardwareRenderer.destroy();
        this.removeAllEventListeners();
        this._animate = null;
        this._sceneManager = null;
        this._resourceManager = null;
        this._canvas = null;
        this._time = null;
        this._waitingDestroy = false;
        this._destroyed = true;
    };
    /**
   * Destroy engine.
   * @remarks If call during frame execution will delay until the end of the frame
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        if (this._frameInProcess) {
            this._waitingDestroy = true;
        } else {
            this._destroy();
        }
    };
    /**
   * @internal
   */ _proto._getShaderProgramPool = function _getShaderProgramPool(shaderPass) {
        var index = shaderPass._shaderPassId;
        var shaderProgramPools = this._shaderProgramPools;
        var pool = shaderProgramPools[index];
        if (!pool) {
            var length = index + 1;
            if (length > shaderProgramPools.length) {
                shaderProgramPools.length = length;
            }
            shaderProgramPools[index] = pool = new ShaderProgramPool();
        }
        return pool;
    };
    /**
   * @internal
   */ _proto._render = function _render(scene) {
        var cameras = scene._activeCameras;
        var componentsManager = this._componentsManager;
        var deltaTime = this.time.deltaTime;
        componentsManager.callRendererOnUpdate(deltaTime);
        scene._updateShaderData();
        if (cameras.length > 0) {
            for(var i = 0, n = cameras.length; i < n; i++){
                var camera = cameras[i];
                componentsManager.callCameraOnBeginRender(camera);
                camera.render();
                componentsManager.callCameraOnEndRender(camera);
                // Temp solution for webgl implement bug
                if (this._hardwareRenderer._options._forceFlush) {
                    this._hardwareRenderer.flush();
                }
            }
        } else {
            Logger.debug("NO active camera.");
        }
    };
    /**
   * @internal
   * Standalone for CanvasRenderer plugin.
   */ _proto._initMagentaTextures = function _initMagentaTextures(hardwareRenderer) {
        var magentaPixel = new Uint8Array([
            255,
            0,
            255,
            255
        ]);
        var magentaTexture2D = new Texture2D(this, 1, 1, TextureFormat.R8G8B8A8, false);
        magentaTexture2D.setPixelBuffer(magentaPixel);
        magentaTexture2D.isGCIgnored = true;
        this.resourceManager.addContentRestorer(new /*#__PURE__*/ (function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, magentaTexture2D);
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                this.resource.setPixelBuffer(magentaPixel);
            };
            return _class;
        }(ContentRestorer))());
        var magentaTextureCube = new TextureCube(this, 1, TextureFormat.R8G8B8A8, false);
        for(var i = 0; i < 6; i++){
            magentaTextureCube.setPixelBuffer(TextureCubeFace.PositiveX + i, magentaPixel);
        }
        magentaTextureCube.isGCIgnored = true;
        this.resourceManager.addContentRestorer(new /*#__PURE__*/ (function(ContentRestorer) {
            _inherits$2(_class, ContentRestorer);
            function _class() {
                return ContentRestorer.call(this, magentaTextureCube);
            }
            var _proto = _class.prototype;
            _proto.restoreContent = function restoreContent() {
                for(var i = 0; i < 6; i++){
                    this.resource.setPixelBuffer(TextureCubeFace.PositiveX + i, magentaPixel);
                }
            };
            return _class;
        }(ContentRestorer))());
        this._magentaTexture2D = magentaTexture2D;
        this._magentaTextureCube = magentaTextureCube;
        if (hardwareRenderer.isWebGL2) {
            var magentaTexture2DArray = new Texture2DArray(this, 1, 1, 1, TextureFormat.R8G8B8A8, false);
            magentaTexture2DArray.setPixelBuffer(0, magentaPixel);
            magentaTexture2DArray.isGCIgnored = true;
            this.resourceManager.addContentRestorer(new /*#__PURE__*/ (function(ContentRestorer) {
                _inherits$2(_class, ContentRestorer);
                function _class() {
                    return ContentRestorer.call(this, magentaTexture2DArray);
                }
                var _proto = _class.prototype;
                _proto.restoreContent = function restoreContent() {
                    this.resource.setPixelBuffer(0, magentaPixel);
                };
                return _class;
            }(ContentRestorer))());
            this._magentaTexture2DArray = magentaTexture2DArray;
        }
    };
    /**
   * @internal
   */ _proto._pendingGC = function _pendingGC() {
        if (this._frameInProcess) {
            this._waitingGC = true;
        } else {
            this._gc();
        }
    };
    /**
   * @internal
   */ _proto._initialize = function _initialize(configuration) {
        var _this = this;
        var physics = configuration.physics;
        if (physics) {
            return physics.initialize().then(function() {
                _this.physicsManager._initialize(physics);
                return _this;
            });
        } else {
            return Promise.resolve(this);
        }
    };
    _proto._createSpriteMaterial = function _createSpriteMaterial() {
        var material = new Material(this, Shader.find("Sprite"));
        var renderState = material.renderState;
        var target = renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
        renderState.depthState.writeEnabled = false;
        renderState.rasterState.cullMode = CullMode.Off;
        material.renderState.renderQueueType = RenderQueueType.Transparent;
        material.isGCIgnored = true;
        return material;
    };
    _proto._createSpriteMaskMaterial = function _createSpriteMaskMaterial() {
        var material = new Material(this, Shader.find("SpriteMask"));
        var renderState = material.renderState;
        renderState.blendState.targetBlendState.colorWriteMask = ColorWriteMask.None;
        renderState.rasterState.cullMode = CullMode.Off;
        renderState.stencilState.enabled = true;
        renderState.depthState.enabled = false;
        material.isGCIgnored = true;
        return material;
    };
    _proto._onDeviceLost = function _onDeviceLost() {
        this._isDeviceLost = true;
        console.log("Device lost.");
        this.dispatch("devicelost", this);
    };
    _proto._onDeviceRestored = function _onDeviceRestored() {
        var _this = this;
        this._hardwareRenderer.resetState();
        this._lastRenderState = new RenderState();
        // Clear shader pools
        this._shaderProgramPools.length = 0;
        var resourceManager = this.resourceManager;
        // Restore graphic resources
        resourceManager._restoreGraphicResources();
        console.log("Graphic resource restored.");
        // Restore resources content
        resourceManager._restoreResourcesContent().then(function() {
            console.log("Graphic resource content restored.\n\n" + "Device restored.");
            _this.dispatch("devicerestored", _this);
            _this._isDeviceLost = false;
        }).catch(function(error) {
            console.error(error);
        });
    };
    _proto._gc = function _gc() {
        this._renderElementPool.garbageCollection();
        this._meshRenderDataPool.garbageCollection();
        this._spriteRenderDataPool.garbageCollection();
        this._spriteMaskRenderDataPool.garbageCollection();
        this._textRenderDataPool.garbageCollection();
        this._componentsManager._gc();
        this._lightManager._gc();
        this.physicsManager._gc();
    };
    _create_class$3(Engine, [
        {
            key: "settings",
            get: /**
   * Settings of Engine.
   */ function get() {
                return this._settings;
            }
        },
        {
            key: "canvas",
            get: /**
   * The canvas to use for rendering.
   */ function get() {
                return this._canvas;
            }
        },
        {
            key: "resourceManager",
            get: /**
   * The resource manager.
   */ function get() {
                return this._resourceManager;
            }
        },
        {
            key: "sceneManager",
            get: /**
   * The scene manager.
   */ function get() {
                return this._sceneManager;
            }
        },
        {
            key: "time",
            get: /**
   * The time information of the engine.
   */ function get() {
                return this._time;
            }
        },
        {
            key: "isPaused",
            get: /**
   * Whether the engine is paused.
   */ function get() {
                return this._isPaused;
            }
        },
        {
            key: "vSyncCount",
            get: /**
   * The number of vertical synchronization means the number of vertical blanking for one frame.
   * @remarks 0 means that the vertical synchronization is turned off.
   */ function get() {
                return this._vSyncCount;
            },
            set: function set(value) {
                this._vSyncCount = Math.max(0, Math.floor(value));
            }
        },
        {
            key: "targetFrameRate",
            get: /**
   * Set the target frame rate you want to achieve.
   * @remarks
   * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
   * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
   */ function get() {
                return this._targetFrameRate;
            },
            set: function set(value) {
                value = Math.max(0.000001, value);
                this._targetFrameRate = value;
                this._targetFrameInterval = 1000 / value;
            }
        },
        {
            key: "destroyed",
            get: /**
   * Indicates whether the engine is destroyed.
   */ function get() {
                return this._destroyed;
            }
        }
    ]);
    return Engine;
}(EventDispatcher);
(function() {
    /** @internal */ Engine._gammaMacro = ShaderMacro.getByName("ENGINE_IS_COLORSPACE_GAMMA");
})();
(function() {
    /** @internal */ Engine._noDepthTextureMacro = ShaderMacro.getByName("ENGINE_NO_DEPTH_TEXTURE");
})();
(function() {
    /** @internal Conversion of space units to pixel units for 2D. */ Engine._pixelsPerUnit = 100;
})();

/**
 * Script class, used for logic writing.
 */ var Script = /*#__PURE__*/ function(Component) {
    _inherits$2(Script, Component);
    function Script() {
        var _this;
        _this = Component.apply(this, arguments) || this;
        /** @internal */ _this._started = false;
        /** @internal */ _this._onStartIndex = -1;
        /** @internal */ _this._onUpdateIndex = -1;
        /** @internal */ _this._onLateUpdateIndex = -1;
        /** @internal */ _this._onPhysicsUpdateIndex = -1;
        /** @internal */ _this._onPreRenderIndex = -1;
        /** @internal */ _this._onPostRenderIndex = -1;
        _this._entityScriptsIndex = -1;
        _this._waitHandlingInValid = false;
        return _this;
    }
    var _proto = Script.prototype;
    /**
   * Called when be enabled first time, only once.
   */ _proto.onAwake = function onAwake() {};
    /**
   * Called when be enabled.
   */ _proto.onEnable = function onEnable() {};
    /**
   * Called before the frame-level loop start for the first time, only once.
   */ _proto.onStart = function onStart() {};
    /**
   * The main loop, called frame by frame.
   * @param deltaTime - The delta time since last frame in seconds
   */ _proto.onUpdate = function onUpdate(deltaTime) {};
    /**
   * Called after the onUpdate finished, called frame by frame.
   * @param deltaTime - The delta time since last frame in seconds
   */ _proto.onLateUpdate = function onLateUpdate(deltaTime) {};
    /**
   * Called before camera rendering, called per camera.
   * @param camera - Current camera.
   */ _proto.onBeginRender = function onBeginRender(camera) {};
    /**
   * Called after camera rendering, called per camera.
   * @param camera - Current camera.
   */ _proto.onEndRender = function onEndRender(camera) {};
    /**
   * Called before physics calculations, the number of times is related to the physical update frequency.
   */ _proto.onPhysicsUpdate = function onPhysicsUpdate() {};
    /**
   * Called when the trigger enter.
   * @param other - ColliderShape
   */ _proto.onTriggerEnter = function onTriggerEnter(other) {};
    /**
   * Called when the trigger exit.
   * @param other - ColliderShape
   */ _proto.onTriggerExit = function onTriggerExit(other) {};
    /**
   * Called when the trigger stay.
   * @remarks onTriggerStay is called every frame while the trigger stay.
   * @param other - ColliderShape
   */ _proto.onTriggerStay = function onTriggerStay(other) {};
    /**
   * Called when the collision enter.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionEnter = function onCollisionEnter(other) {};
    /**
   * Called when the collision exit.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionExit = function onCollisionExit(other) {};
    /**
   * Called when the collision stay.
   * @param other - The Collision data associated with this collision event
   * @remarks The Collision data will be invalid after this call, you should copy the data if needed.
   */ _proto.onCollisionStay = function onCollisionStay(other) {};
    /**
   * Called when the pointer is down while over the ColliderShape.
   * @param pointer - The pointer that triggered
   */ _proto.onPointerDown = function onPointerDown(pointer) {};
    /**
   * Called when the pointer is up while over the ColliderShape.
   * @param pointer - The pointer that triggered
   */ _proto.onPointerUp = function onPointerUp(pointer) {};
    /**
   * Called when the pointer is down and up with the same collider.
   * @param pointer - The pointer that triggered
   */ _proto.onPointerClick = function onPointerClick(pointer) {};
    /**
   * Called when the pointer is enters the ColliderShape.
   * @param pointer - The pointer that triggered
   */ _proto.onPointerEnter = function onPointerEnter(pointer) {};
    /**
   * Called when the pointer is no longer over the ColliderShape.
   * @param pointer - The pointer that triggered
   */ _proto.onPointerExit = function onPointerExit(pointer) {};
    /**
   * Called when the pointer is down while over the ColliderShape and is still holding down.
   * @param pointer - The pointer that triggered
   * @remarks onPointerDrag is called every frame while the pointer is down.
   */ _proto.onPointerDrag = function onPointerDrag(pointer) {};
    /**
   * Called when be disabled.
   */ _proto.onDisable = function onDisable() {};
    /**
   * Called at the end of the destroyed frame.
   */ _proto.onDestroy = function onDestroy() {};
    /**
   * @internal
   * @inheritDoc
   */ _proto._onAwake = function _onAwake() {
        this.onAwake();
    };
    /**
   * @internal
   * @inheritDoc
   */ _proto._onEnable = function _onEnable() {
        if (this._waitHandlingInValid) {
            this._waitHandlingInValid = false;
        } else {
            var _this_engine = this.engine, componentsManager = _this_engine._componentsManager;
            var prototype = Script.prototype;
            if (!this._started) {
                componentsManager.addOnStartScript(this);
            }
            if (this.onUpdate !== prototype.onUpdate) {
                componentsManager.addOnUpdateScript(this);
            }
            if (this.onLateUpdate !== prototype.onLateUpdate) {
                componentsManager.addOnLateUpdateScript(this);
            }
            if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
                componentsManager.addOnPhysicsUpdateScript(this);
            }
            this._entity._addScript(this);
        }
        this.onEnable();
    };
    /**
   * @internal
   * @inheritDoc
   */ _proto._onDisable = function _onDisable() {
        this._waitHandlingInValid = true;
        this._engine._componentsManager.addDisableScript(this);
        this.onDisable();
    };
    /**
   * @internal
   */ _proto._handlingInValid = function _handlingInValid() {
        var componentsManager = this.engine._componentsManager;
        var prototype = Script.prototype;
        if (this.onUpdate !== prototype.onUpdate) {
            componentsManager.removeOnUpdateScript(this);
        }
        if (this.onLateUpdate !== prototype.onLateUpdate) {
            componentsManager.removeOnLateUpdateScript(this);
        }
        if (this.onPhysicsUpdate !== prototype.onPhysicsUpdate) {
            componentsManager.removeOnPhysicsUpdateScript(this);
        }
        this._entity._removeScript(this);
        this._waitHandlingInValid = false;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Component.prototype._onDestroy.call(this);
        this._engine._componentsManager.addPendingDestroyScript(this);
    };
    return Script;
}(Component);
__decorate$1([
    ignoreClone
], Script.prototype, "_started", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onStartIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onLateUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPhysicsUpdateIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPreRenderIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_onPostRenderIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_entityScriptsIndex", void 0);
__decorate$1([
    ignoreClone
], Script.prototype, "_waitHandlingInValid", void 0);

/**
 * @internal
 */ var SpriteBatcher = /*#__PURE__*/ function(Basic2DBatcher1) {
    _inherits$2(SpriteBatcher, Basic2DBatcher1);
    function SpriteBatcher() {
        return Basic2DBatcher1.apply(this, arguments);
    }
    var _proto = SpriteBatcher.prototype;
    _proto.createVertexElements = function createVertexElements(vertexElements) {
        vertexElements[0] = new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0);
        vertexElements[1] = new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0);
        vertexElements[2] = new VertexElement("COLOR_0", 20, VertexElementFormat.Vector4, 0);
        return 36;
    };
    _proto.canBatch = function canBatch(preElement, curElement) {
        if (!this._engine._canSpriteBatch || curElement.shaderPass.getTagValue(Basic2DBatcher._disableBatchTag) === true) {
            return false;
        }
        var preSpriteData = preElement.data;
        var curSpriteData = curElement.data;
        var preRenderer = preSpriteData.component;
        var curRenderer = curSpriteData.component;
        // Compare mask
        if (!this.checkBatchWithMask(preRenderer, curRenderer)) {
            return false;
        }
        // Compare texture
        if (preSpriteData.texture !== curSpriteData.texture) {
            return false;
        }
        // Compare material
        return preSpriteData.material === curSpriteData.material;
    };
    _proto.checkBatchWithMask = function checkBatchWithMask(left, right) {
        var leftMaskInteraction = left.maskInteraction;
        if (leftMaskInteraction !== right.maskInteraction) {
            return false;
        }
        if (leftMaskInteraction === SpriteMaskInteraction.None) {
            return true;
        }
        return left.maskLayer === right.maskLayer;
    };
    _proto.updateVertices = function updateVertices(element, vertices, vertexIndex) {
        var _element_verticesData = element.verticesData, positions = _element_verticesData.positions, uvs = _element_verticesData.uvs, color = _element_verticesData.color, vertexCount = _element_verticesData.vertexCount;
        for(var i = 0; i < vertexCount; i++){
            var curPos = positions[i];
            var curUV = uvs[i];
            vertices[vertexIndex++] = curPos.x;
            vertices[vertexIndex++] = curPos.y;
            vertices[vertexIndex++] = curPos.z;
            vertices[vertexIndex++] = curUV.x;
            vertices[vertexIndex++] = curUV.y;
            vertices[vertexIndex++] = color.r;
            vertices[vertexIndex++] = color.g;
            vertices[vertexIndex++] = color.b;
            vertices[vertexIndex++] = color.a;
        }
        return vertexIndex;
    };
    _proto.drawBatches = function drawBatches(camera) {
        var _this = this, engine = _this._engine, batchedQueue = _this._batchedQueue;
        var mesh = this._meshes[this._flushId];
        var subMeshes = mesh.subMeshes;
        var maskManager = engine._spriteMaskManager;
        var sceneData = camera.scene.shaderData;
        var cameraData = camera.shaderData;
        for(var i = 0, len = subMeshes.length; i < len; i++){
            var subMesh = subMeshes[i];
            var spriteElement = batchedQueue[i];
            var spriteData = spriteElement.data;
            if (!subMesh || !spriteElement) {
                return;
            }
            var renderer = spriteData.component;
            var material = spriteData.material;
            maskManager.preRender(camera, renderer);
            var compileMacros = Shader._compileMacros;
            // union render global macro and material self macro.
            ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, material.shaderData._macroCollection, compileMacros);
            var program = spriteElement.shaderPass._getShaderProgram(engine, compileMacros);
            if (!program.isValid) {
                return;
            }
            renderer.shaderData.setTexture(SpriteBatcher._textureProperty, spriteData.texture);
            program.bind();
            program.groupingOtherUniformBlock();
            program.uploadAll(program.sceneUniformBlock, sceneData);
            program.uploadAll(program.cameraUniformBlock, cameraData);
            program.uploadAll(program.rendererUniformBlock, renderer.shaderData);
            program.uploadAll(program.materialUniformBlock, material.shaderData);
            spriteElement.renderState._apply(engine, false);
            engine._hardwareRenderer.drawPrimitive(mesh, subMesh, program);
            maskManager.postRender(renderer);
        }
    };
    _proto.destroy = function destroy() {
        this._batchedQueue = null;
        var _this = this, meshes = _this._meshes, vertexBuffers = _this._vertexBuffers, indiceBuffers = _this._indiceBuffers;
        for(var i = 0, n = meshes.length; i < n; ++i){
            meshes[i].destroy();
        }
        this._meshes = null;
        for(var i1 = 0, n1 = vertexBuffers.length; i1 < n1; ++i1){
            vertexBuffers[i1].destroy();
        }
        this._vertexBuffers = null;
        for(var i2 = 0, n2 = indiceBuffers.length; i2 < n2; ++i2){
            indiceBuffers[i2].destroy();
        }
        this._indiceBuffers = null;
    };
    return SpriteBatcher;
}(Basic2DBatcher);
(function() {
    SpriteBatcher._textureProperty = ShaderProperty.getByName("renderer_SpriteTexture");
})();

/**
 * Render queue.
 */ var RenderQueue = /*#__PURE__*/ function() {
    function RenderQueue(engine) {
        this.elements = [];
        this._initSpriteBatcher(engine);
    }
    var _proto = RenderQueue.prototype;
    /**
   * Push a render element.
   */ _proto.pushRenderElement = function pushRenderElement(element) {
        this.elements.push(element);
    };
    _proto.render = function render(camera, mask) {
        var elements = this.elements;
        if (elements.length === 0) {
            return;
        }
        var engine = camera.engine, scene = camera.scene;
        var renderCount = engine._renderCount;
        var rhi = engine._hardwareRenderer;
        var sceneData = scene.shaderData;
        var cameraData = camera.shaderData;
        for(var i = 0, n = elements.length; i < n; i++){
            var element = elements[i];
            var data = element.data;
            var renderPassFlag = data.component.entity.layer;
            if (!(renderPassFlag & mask)) {
                continue;
            }
            if (!!data.mesh) {
                this._spriteBatcher.flush(camera);
                var compileMacros = Shader._compileMacros;
                var meshData = data;
                var renderer = meshData.component;
                var material = meshData.material.destroyed ? engine._magentaMaterial : meshData.material;
                var rendererData = renderer.shaderData;
                var materialData = material.shaderData;
                // union render global macro and material self macro.
                ShaderMacroCollection.unionCollection(renderer._globalShaderMacro, materialData._macroCollection, compileMacros);
                var program = element.shaderPass._getShaderProgram(engine, compileMacros);
                if (!program.isValid) {
                    continue;
                }
                var switchProgram = program.bind();
                var switchRenderCount = renderCount !== program._uploadRenderCount;
                if (switchRenderCount) {
                    program.groupingOtherUniformBlock();
                    program.uploadAll(program.sceneUniformBlock, sceneData);
                    program.uploadAll(program.cameraUniformBlock, cameraData);
                    program.uploadAll(program.rendererUniformBlock, rendererData);
                    program.uploadAll(program.materialUniformBlock, materialData);
                    // UnGroup textures should upload default value, texture uint maybe change by logic of texture bind.
                    program.uploadUnGroupTextures();
                    program._uploadScene = scene;
                    program._uploadCamera = camera;
                    program._uploadRenderer = renderer;
                    program._uploadMaterial = material;
                    program._uploadRenderCount = renderCount;
                } else {
                    if (program._uploadScene !== scene) {
                        program.uploadAll(program.sceneUniformBlock, sceneData);
                        program._uploadScene = scene;
                    } else if (switchProgram) {
                        program.uploadTextures(program.sceneUniformBlock, sceneData);
                    }
                    if (program._uploadCamera !== camera) {
                        program.uploadAll(program.cameraUniformBlock, cameraData);
                        program._uploadCamera = camera;
                    } else if (switchProgram) {
                        program.uploadTextures(program.cameraUniformBlock, cameraData);
                    }
                    if (program._uploadRenderer !== renderer) {
                        program.uploadAll(program.rendererUniformBlock, rendererData);
                        program._uploadRenderer = renderer;
                    } else if (switchProgram) {
                        program.uploadTextures(program.rendererUniformBlock, rendererData);
                    }
                    if (program._uploadMaterial !== material) {
                        program.uploadAll(program.materialUniformBlock, materialData);
                        program._uploadMaterial = material;
                    } else if (switchProgram) {
                        program.uploadTextures(program.materialUniformBlock, materialData);
                    }
                    // We only consider switchProgram case, because UnGroup texture's value is always default.
                    if (switchProgram) {
                        program.uploadUnGroupTextures();
                    }
                }
                element.renderState._apply(engine, renderer.entity.transform._isFrontFaceInvert());
                rhi.drawPrimitive(meshData.mesh, meshData.subMesh, program);
            } else {
                this._spriteBatcher.drawElement(element, camera);
            }
        }
        this._spriteBatcher.flush(camera);
    };
    /**
   * Clear collection.
   */ _proto.clear = function clear() {
        this.elements.length = 0;
        this._spriteBatcher.clear();
    };
    /**
   * Destroy internal resources.
   */ _proto.destroy = function destroy() {
        this._spriteBatcher.destroy();
        this._spriteBatcher = null;
    };
    /**
   * Sort the elements.
   */ _proto.sort = function sort(compareFunc) {
        this._quickSort(this.elements, 0, this.elements.length, compareFunc);
    };
    /**
   * @internal
   * Standalone for CanvasRenderer plugin.
   */ _proto._initSpriteBatcher = function _initSpriteBatcher(engine) {
        this._spriteBatcher = new SpriteBatcher(engine);
    };
    /**
   * @remarks
   * Modified based on v8.
   * https://github.com/v8/v8/blob/7.2-lkgr/src/js/array.js
   */ _proto._quickSort = function _quickSort(a, from, to, compareFunc) {
        while(true){
            // Insertion sort is faster for short arrays.
            if (to - from <= 10) {
                this._insertionSort(a, from, to, compareFunc);
                return;
            }
            var third_index = from + to >> 1;
            // Find a pivot as the median of first, last and middle element.
            var v0 = a[from];
            var v1 = a[to - 1];
            var v2 = a[third_index];
            var c01 = compareFunc(v0, v1);
            if (c01 > 0) {
                // v1 < v0, so swap them.
                var tmp = v0;
                v0 = v1;
                v1 = tmp;
            } // v0 <= v1.
            var c02 = compareFunc(v0, v2);
            if (c02 >= 0) {
                // v2 <= v0 <= v1.
                var tmp1 = v0;
                v0 = v2;
                v2 = v1;
                v1 = tmp1;
            } else {
                // v0 <= v1 && v0 < v2
                var c12 = compareFunc(v1, v2);
                if (c12 > 0) {
                    // v0 <= v2 < v1
                    var tmp2 = v1;
                    v1 = v2;
                    v2 = tmp2;
                }
            }
            // v0 <= v1 <= v2
            a[from] = v0;
            a[to - 1] = v2;
            var pivot = v1;
            var low_end = from + 1; // Upper bound of elements lower than pivot.
            var high_start = to - 1; // Lower bound of elements greater than pivot.
            a[third_index] = a[low_end];
            a[low_end] = pivot;
            // From low_end to i are elements equal to pivot.
            // From i to high_start are elements that haven't been compared yet.
            partition: for(var i = low_end + 1; i < high_start; i++){
                var element = a[i];
                var order = compareFunc(element, pivot);
                if (order < 0) {
                    a[i] = a[low_end];
                    a[low_end] = element;
                    low_end++;
                } else if (order > 0) {
                    do {
                        high_start--;
                        if (high_start == i) break partition;
                        var top_elem = a[high_start];
                        order = compareFunc(top_elem, pivot);
                    }while (order > 0);
                    a[i] = a[high_start];
                    a[high_start] = element;
                    if (order < 0) {
                        element = a[i];
                        a[i] = a[low_end];
                        a[low_end] = element;
                        low_end++;
                    }
                }
            }
            if (to - high_start < low_end - from) {
                this._quickSort(a, high_start, to, compareFunc);
                to = low_end;
            } else {
                this._quickSort(a, from, low_end, compareFunc);
                from = high_start;
            }
        }
    };
    _proto._insertionSort = function _insertionSort(a, from, to, compareFunc) {
        for(var i = from + 1; i < to; i++){
            var j = void 0;
            var element = a[i];
            for(j = i - 1; j >= from; j--){
                var tmp = a[j];
                var order = compareFunc(tmp, element);
                if (order > 0) {
                    a[j + 1] = tmp;
                } else {
                    break;
                }
            }
            a[j + 1] = element;
        }
    };
    /**
   * @internal
   */ RenderQueue._compareFromNearToFar = function _compareFromNearToFar(a, b) {
        return a.data.component.priority - b.data.component.priority || a.data.component._distanceForSort - b.data.component._distanceForSort;
    };
    /**
   * @internal
   */ RenderQueue._compareFromFarToNear = function _compareFromFarToNear(a, b) {
        return a.data.component.priority - b.data.component.priority || b.data.component._distanceForSort - a.data.component._distanceForSort;
    };
    return RenderQueue;
}();

/**
 * @internal
 */ var VirtualCamera = function VirtualCamera() {
    this.position = new Vector3();
    this.isOrthographic = false;
    this.viewMatrix = new Matrix();
    this.projectionMatrix = new Matrix();
    this.viewProjectionMatrix = new Matrix();
    /** Only orth mode use. */ this.forward = new Vector3();
};

/**
 * @internal
 */ var ShadowSliceData = function ShadowSliceData() {
    this.virtualCamera = new VirtualCamera();
    this.cullPlanes = [
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3()),
        new Plane(new Vector3())
    ];
    // bounding sphere
    this.splitBoundSphere = new BoundingSphere(new Vector3(), 0.0);
};

var /**
 * @internal
 */ FrustumCorner;
(function(FrustumCorner) {
    FrustumCorner[FrustumCorner["FarBottomLeft"] = 0] = "FarBottomLeft";
    FrustumCorner[FrustumCorner["FarTopLeft"] = 1] = "FarTopLeft";
    FrustumCorner[FrustumCorner["FarTopRight"] = 2] = "FarTopRight";
    FrustumCorner[FrustumCorner["FarBottomRight"] = 3] = "FarBottomRight";
    FrustumCorner[FrustumCorner["nearBottomLeft"] = 4] = "nearBottomLeft";
    FrustumCorner[FrustumCorner["nearTopLeft"] = 5] = "nearTopLeft";
    FrustumCorner[FrustumCorner["nearTopRight"] = 6] = "nearTopRight";
    FrustumCorner[FrustumCorner["nearBottomRight"] = 7] = "nearBottomRight";
    FrustumCorner[FrustumCorner["unknown"] = 8] = "unknown";
})(FrustumCorner || (FrustumCorner = {}));
/**
 * @internal
 */ var ShadowUtils = /*#__PURE__*/ function() {
    function ShadowUtils() {}
    ShadowUtils.shadowResolution = function shadowResolution(value) {
        switch(value){
            case ShadowResolution.Low:
                return 512;
            case ShadowResolution.Medium:
                return 1024;
            case ShadowResolution.High:
                return 2048;
            case ShadowResolution.VeryHigh:
                return 4096;
        }
    };
    ShadowUtils.shadowDepthFormat = function shadowDepthFormat(value, supportDepthTexture) {
        if (supportDepthTexture) {
            return TextureFormat.Depth16;
        } else {
            return TextureFormat.R8G8B8A8;
        }
    };
    ShadowUtils.cullingRenderBounds = function cullingRenderBounds(bounds, cullPlaneCount, cullPlanes) {
        var min = bounds.min, max = bounds.max;
        for(var i = 0; i < cullPlaneCount; i++){
            var plane = cullPlanes[i];
            var normal = plane.normal;
            if (normal.x * (normal.x >= 0.0 ? max.x : min.x) + normal.y * (normal.y >= 0.0 ? max.y : min.y) + normal.z * (normal.z >= 0.0 ? max.z : min.z) < -plane.distance) {
                return false;
            }
        }
        return true;
    };
    ShadowUtils.shadowCullFrustum = function shadowCullFrustum(context, light, renderer, shadowSliceData) {
        var layer = renderer._entity.layer;
        // filter by camera culling mask
        if (context.camera.cullingMask & layer && light.cullingMask & layer) {
            if (renderer.castShadows && ShadowUtils.cullingRenderBounds(renderer.bounds, shadowSliceData.cullPlaneCount, shadowSliceData.cullPlanes)) {
                renderer._renderFrameCount = renderer.engine.time.frameCount;
                renderer._prepareRender(context);
            }
        }
    };
    ShadowUtils.getBoundSphereByFrustum = function getBoundSphereByFrustum(near, far, camera, forward, shadowSliceData) {
        var aspectRatio = camera.aspectRatio, fieldOfView = camera.fieldOfView;
        // https://lxjk.github.io/2017/04/15/Calculate-Minimal-Bounding-Sphere-of-Frustum.html
        var centerZ;
        var radius;
        var k = Math.sqrt(1.0 + aspectRatio * aspectRatio) * Math.tan(MathUtil$1.degreeToRadian(fieldOfView) / 2.0);
        var k2 = k * k;
        var farSNear = far - near;
        var farANear = far + near;
        if (k2 > farSNear / farANear) {
            centerZ = far;
            radius = far * k;
        } else {
            centerZ = 0.5 * farANear * (1 + k2);
            radius = 0.5 * Math.sqrt(farSNear * farSNear + 2.0 * (far * far + near * near) * k2 + farANear * farANear * k2 * k2);
        }
        var center = shadowSliceData.splitBoundSphere.center;
        shadowSliceData.splitBoundSphere.radius = radius;
        Vector3.scale(forward, centerZ, center);
        Vector3.add(camera.entity.transform.worldPosition, center, center);
        shadowSliceData.sphereCenterZ = centerZ;
    };
    ShadowUtils.getDirectionLightShadowCullPlanes = function getDirectionLightShadowCullPlanes(cameraFrustum, splitDistance, cameraNear, direction, shadowSliceData) {
        // http://lspiroengine.com/?p=187
        var frustumCorners = ShadowUtils._frustumCorners;
        var backPlaneFaces = ShadowUtils._backPlaneFaces;
        var planeNeighbors = ShadowUtils._frustumPlaneNeighbors;
        var twoPlaneCorners = ShadowUtils._frustumTwoPlaneCorners;
        var edgePlanePoint2 = ShadowUtils._edgePlanePoint2;
        var out = shadowSliceData.cullPlanes;
        // cameraFrustumPlanes is share
        var near = cameraFrustum.getPlane(FrustumFace.Near);
        var far = cameraFrustum.getPlane(FrustumFace.Far);
        var left = cameraFrustum.getPlane(FrustumFace.Left);
        var right = cameraFrustum.getPlane(FrustumFace.Right);
        var bottom = cameraFrustum.getPlane(FrustumFace.Bottom);
        var top = cameraFrustum.getPlane(FrustumFace.Top);
        // adjustment the near/far plane
        var splitNearDistance = splitDistance - cameraNear;
        var splitNear = ShadowUtils._adjustNearPlane;
        var splitFar = ShadowUtils._adjustFarPlane;
        splitNear.normal.copyFrom(near.normal);
        splitFar.normal.copyFrom(far.normal);
        splitNear.distance = near.distance - splitNearDistance;
        // do a clamp if the sphere is out of range the far plane
        splitFar.distance = Math.min(-near.distance + shadowSliceData.sphereCenterZ + shadowSliceData.splitBoundSphere.radius, far.distance);
        CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, right, frustumCorners[7]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, top, right, frustumCorners[6]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, top, left, frustumCorners[5]);
        CollisionUtil.intersectionPointThreePlanes(splitNear, bottom, left, frustumCorners[4]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, right, frustumCorners[3]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, top, right, frustumCorners[2]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, top, left, frustumCorners[1]);
        CollisionUtil.intersectionPointThreePlanes(splitFar, bottom, left, frustumCorners[0]);
        var backIndex = 0;
        for(var i = 0; i < 6; i++){
            // maybe 3ã€4ã€5(light eye is at far, forward is near, or orthographic camera is any axis)
            var plane = void 0;
            switch(i){
                case FrustumFace.Near:
                    plane = splitNear;
                    break;
                case FrustumFace.Far:
                    plane = splitFar;
                    break;
                default:
                    plane = cameraFrustum.getPlane(i);
                    break;
            }
            if (Vector3.dot(plane.normal, direction) < 0.0) {
                out[backIndex].copyFrom(plane);
                backPlaneFaces[backIndex] = i;
                backIndex++;
            }
        }
        var edgeIndex = backIndex;
        for(var i1 = 0; i1 < backIndex; i1++){
            var backFace = backPlaneFaces[i1];
            var neighborFaces = planeNeighbors[backFace];
            for(var j = 0; j < 4; j++){
                var neighborFace = neighborFaces[j];
                var notBackFace = true;
                for(var k = 0; k < backIndex; k++)if (neighborFace == backPlaneFaces[k]) {
                    notBackFace = false;
                    break;
                }
                if (notBackFace) {
                    var corners = twoPlaneCorners[backFace][neighborFace];
                    var point0 = frustumCorners[corners[0]];
                    var point1 = frustumCorners[corners[1]];
                    Vector3.add(point0, direction, edgePlanePoint2);
                    Plane.fromPoints(point0, point1, edgePlanePoint2, out[edgeIndex++]);
                }
            }
        }
        shadowSliceData.cullPlaneCount = edgeIndex;
    };
    ShadowUtils.getDirectionalLightMatrices = function getDirectionalLightMatrices(lightUp, lightSide, lightForward, cascadeIndex, nearPlane, shadowResolution, shadowSliceData, outShadowMatrices) {
        var boundSphere = shadowSliceData.splitBoundSphere;
        shadowSliceData.resolution = shadowResolution;
        // To solve shadow swimming problem.
        var center = boundSphere.center;
        var radius = boundSphere.radius;
        var halfShadowResolution = shadowResolution / 2;
        // Add border to project edge pixel PCF.
        // Improve:the clip planes not consider the border,but I think is OK,because the object can clip is not continuous.
        var borderRadius = radius * halfShadowResolution / (halfShadowResolution - ShadowUtils.atlasBorderSize);
        var borderDiam = borderRadius * 2.0;
        var sizeUnit = shadowResolution / borderDiam;
        var radiusUnit = borderDiam / shadowResolution;
        var upLen = Math.ceil(Vector3.dot(center, lightUp) * sizeUnit) * radiusUnit;
        var sideLen = Math.ceil(Vector3.dot(center, lightSide) * sizeUnit) * radiusUnit;
        var forwardLen = Vector3.dot(center, lightForward);
        center.x = lightUp.x * upLen + lightSide.x * sideLen + lightForward.x * forwardLen;
        center.y = lightUp.y * upLen + lightSide.y * sideLen + lightForward.y * forwardLen;
        center.z = lightUp.z * upLen + lightSide.z * sideLen + lightForward.z * forwardLen;
        // Direction light use shadow pancaking tech,do special dispose with nearPlane.
        var virtualCamera = shadowSliceData.virtualCamera;
        var position = virtualCamera.position;
        var viewMatrix = virtualCamera.viewMatrix;
        var projectMatrix = virtualCamera.projectionMatrix;
        Vector3.scale(lightForward, radius + nearPlane, position);
        Vector3.subtract(center, position, position);
        Matrix.lookAt(position, center, lightUp, viewMatrix);
        Matrix.ortho(-borderRadius, borderRadius, -borderRadius, borderRadius, 0.0, radius * 2.0 + nearPlane, projectMatrix);
        var viewProjectionMatrix = virtualCamera.viewProjectionMatrix;
        Matrix.multiply(projectMatrix, viewMatrix, viewProjectionMatrix);
        Utils._floatMatrixMultiply(ShadowUtils._shadowMapCoordMatrix, viewProjectionMatrix.elements, 0, outShadowMatrices, cascadeIndex * 16);
    };
    ShadowUtils.getMaxTileResolutionInAtlas = function getMaxTileResolutionInAtlas(atlasWidth, atlasHeight, tileCount) {
        var resolution = Math.min(atlasWidth, atlasHeight);
        var currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
        while(currentTileCount < tileCount){
            resolution = Math.floor(resolution >> 1);
            currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
        }
        return resolution;
    };
    ShadowUtils.getShadowBias = function getShadowBias(light, projectionMatrix, shadowResolution, out) {
        // Frustum size is guaranteed to be a cube as we wrap shadow frustum around a sphere
        // elements[0] = 2.0 / (right - left)
        var frustumSize = 2.0 / projectionMatrix.elements[0];
        // depth and normal bias scale is in shadowmap texel size in world space
        var texelSize = frustumSize / shadowResolution;
        var depthBias = -light.shadowBias * texelSize;
        var normalBias = -light.shadowNormalBias * texelSize;
        if (light.shadowType == exports.ShadowType.SoftHigh) {
            // TODO: depth and normal bias assume sample is no more than 1 texel away from shadowmap
            // This is not true with PCF. Ideally we need to do either
            // cone base bias (based on distance to center sample)
            // or receiver place bias based on derivatives.
            // For now we scale it by the PCF kernel size (5x5)
            var kernelRadius = 2.5;
            depthBias *= kernelRadius;
            normalBias *= kernelRadius;
        }
        out.set(depthBias, normalBias);
    };
    /**
   * Apply shadow slice scale and offset
   */ ShadowUtils.applySliceTransform = function applySliceTransform(tileSize, atlasWidth, atlasHeight, cascadeIndex, atlasOffset, outShadowMatrices) {
        var sliceMatrix = ShadowUtils._tempMatrix0;
        var slice = sliceMatrix.elements;
        var oneOverAtlasWidth = 1.0 / atlasWidth;
        var oneOverAtlasHeight = 1.0 / atlasHeight;
        var scaleX = tileSize * oneOverAtlasWidth;
        var scaleY = tileSize * oneOverAtlasHeight;
        var offsetX = atlasOffset.x * oneOverAtlasWidth;
        var offsetY = atlasOffset.y * oneOverAtlasHeight;
        slice[0] = scaleX, slice[1] = 0, slice[2] = 0, slice[3] = 0;
        slice[4] = 0, slice[5] = scaleY, slice[6] = 0, slice[7] = 0;
        slice[8] = 0, slice[9] = 0, slice[10] = 1, slice[11] = 0;
        slice[12] = offsetX, slice[13] = offsetY, slice[14] = 0, slice[15] = 1;
        var offset = cascadeIndex * 16;
        Utils._floatMatrixMultiply(sliceMatrix, outShadowMatrices, offset, outShadowMatrices, offset);
    };
    return ShadowUtils;
}();
(function() {
    ShadowUtils._tempMatrix0 = new Matrix();
})();
(function() {
    // prettier-ignore
    /** @internal */ ShadowUtils._shadowMapCoordMatrix = new Matrix(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
})();
(function() {
    ShadowUtils._frustumCorners = [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
    ];
})();
(function() {
    ShadowUtils._adjustNearPlane = new Plane(new Vector3());
})();
(function() {
    ShadowUtils._adjustFarPlane = new Plane(new Vector3());
})();
(function() {
    ShadowUtils._backPlaneFaces = new Array(5);
})();
(function() {
    ShadowUtils._edgePlanePoint2 = new Vector3();
})();
(function() {
    /** near, far, left, right, bottom, top  */ ShadowUtils._frustumPlaneNeighbors = [
        [
            FrustumFace.Left,
            FrustumFace.Right,
            FrustumFace.Top,
            FrustumFace.Bottom
        ],
        [
            FrustumFace.Left,
            FrustumFace.Right,
            FrustumFace.Top,
            FrustumFace.Bottom
        ],
        [
            FrustumFace.Near,
            FrustumFace.Far,
            FrustumFace.Top,
            FrustumFace.Bottom
        ],
        [
            FrustumFace.Near,
            FrustumFace.Far,
            FrustumFace.Top,
            FrustumFace.Bottom
        ],
        [
            FrustumFace.Near,
            FrustumFace.Far,
            FrustumFace.Left,
            FrustumFace.Right
        ],
        [
            FrustumFace.Near,
            FrustumFace.Far,
            FrustumFace.Left,
            FrustumFace.Right
        ]
    ];
})();
(function() {
    /** near, far, left, right, bottom, top  */ ShadowUtils._frustumTwoPlaneCorners = [
        [
            // near, far, left, right, bottom, top
            [
                8,
                8
            ],
            [
                8,
                8
            ],
            [
                4,
                5
            ],
            [
                6,
                7
            ],
            [
                7,
                4
            ],
            [
                5,
                6
            ]
        ],
        [
            // near, far, left, right, bottom, top
            [
                8,
                8
            ],
            [
                8,
                8
            ],
            [
                1,
                0
            ],
            [
                3,
                2
            ],
            [
                0,
                3
            ],
            [
                2,
                1
            ]
        ],
        [
            // near, far, left, right, bottom, top
            [
                5,
                4
            ],
            [
                0,
                1
            ],
            [
                8,
                8
            ],
            [
                8,
                8
            ],
            [
                4,
                0
            ],
            [
                1,
                5
            ]
        ],
        [
            // near, far, left, right, bottom, top
            [
                7,
                6
            ],
            [
                2,
                3
            ],
            [
                8,
                8
            ],
            [
                8,
                8
            ],
            [
                3,
                7
            ],
            [
                6,
                2
            ]
        ],
        [
            // near, far, left, right, bottom, top
            [
                4,
                7
            ],
            [
                3,
                0
            ],
            [
                0,
                4
            ],
            [
                7,
                3
            ],
            [
                8,
                8
            ],
            [
                8,
                8
            ]
        ],
        [
            // near, far, left, right, bottom, top
            [
                6,
                5
            ],
            [
                1,
                2
            ],
            [
                5,
                1
            ],
            [
                2,
                6
            ],
            [
                8,
                8
            ],
            [
                8,
                8
            ]
        ]
    ];
})();
(function() {
    //now max shadow sample tent is 5x5, atlas borderSize at least 3=ceil(2.5),and +1 pixel is for global border for no cascade mode.
    ShadowUtils.atlasBorderSize = 4.0;
})();

/**
 * Cascade shadow caster.
 */ var CascadedShadowCasterPass = /*#__PURE__*/ function() {
    function CascadedShadowCasterPass(camera) {
        this._shadowMapSize = new Vector4();
        this._shadowBias = new Vector2();
        this._shadowSliceData = new ShadowSliceData();
        this._lightUp = new Vector3();
        this._lightSide = new Vector3();
        this._existShadowMap = false;
        this._splitBoundSpheres = new Float32Array(CascadedShadowCasterPass._maxCascades * 4);
        /** The end is project prcision problem in shader. */ this._shadowMatrices = new Float32Array((CascadedShadowCasterPass._maxCascades + 1) * 16);
        // strength, null, lightIndex
        this._shadowInfos = new Vector3();
        this._viewportOffsets = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ];
        this._camera = camera;
        this._engine = camera.engine;
        this._supportDepthTexture = camera.engine._hardwareRenderer.canIUse(GLCapabilityType.depthTexture);
        this._shadowSliceData.virtualCamera.isOrthographic = true;
    }
    var _proto = CascadedShadowCasterPass.prototype;
    /**
   * @internal
   */ _proto._render = function _render(context) {
        this._updateShadowSettings();
        this._existShadowMap = false;
        this._renderDirectShadowMap(context);
        if (this._existShadowMap) {
            this._updateReceiversShaderData();
        }
    };
    _proto._renderDirectShadowMap = function _renderDirectShadowMap(context) {
        var _this = this, engine = _this._engine, camera = _this._camera, viewports = _this._viewportOffsets, shadowSliceData = _this._shadowSliceData, splitBoundSpheres = _this._splitBoundSpheres, shadowMatrices = _this._shadowMatrices;
        var _camera__renderPipeline = camera._renderPipeline, opaqueQueue = _camera__renderPipeline._opaqueQueue, alphaTestQueue = _camera__renderPipeline._alphaTestQueue, transparentQueue = _camera__renderPipeline._transparentQueue;
        var componentsManager = engine._componentsManager;
        var rhi = engine._hardwareRenderer;
        var shadowCascades = camera.scene.shadowCascades;
        var splitDistance = CascadedShadowCasterPass._cascadesSplitDistance;
        var boundSphere = shadowSliceData.splitBoundSphere;
        var lightWorld = CascadedShadowCasterPass._tempMatrix0;
        var lightWorldE = lightWorld.elements;
        var lightUp = this._lightUp;
        var lightSide = this._lightSide;
        var lightForward = shadowSliceData.virtualCamera.forward;
        var sunLightIndex = engine._lightManager._getSunLightIndex();
        if (sunLightIndex !== -1) {
            var light = camera.scene._sunLight;
            var shadowFar = Math.min(camera.scene.shadowDistance, camera.farClipPlane);
            this._getCascadesSplitDistance(shadowFar);
            // prepare render target
            var renderTarget = this._getAvailableRenderTarget();
            // @todo: shouldn't set viewport and scissor in activeRenderTarget
            rhi.activeRenderTarget(renderTarget, CascadedShadowCasterPass._viewport, 0);
            if (this._supportDepthTexture) {
                rhi.clearRenderTarget(engine, CameraClearFlags.Depth, null);
            } else {
                rhi.clearRenderTarget(engine, CameraClearFlags.All, CascadedShadowCasterPass._clearColor);
            }
            this._shadowInfos.x = light.shadowStrength;
            this._shadowInfos.z = sunLightIndex;
            // prepare light and camera direction
            Matrix.rotationQuaternion(light.entity.transform.worldRotationQuaternion, lightWorld);
            lightSide.set(lightWorldE[0], lightWorldE[1], lightWorldE[2]);
            lightUp.set(lightWorldE[4], lightWorldE[5], lightWorldE[6]);
            lightForward.set(-lightWorldE[8], -lightWorldE[9], -lightWorldE[10]);
            var cameraForward = CascadedShadowCasterPass._tempVector;
            cameraForward.copyFrom(camera.entity.transform.worldForward);
            var shadowTileResolution = this._shadowTileResolution;
            for(var j = 0; j < shadowCascades; j++){
                ShadowUtils.getBoundSphereByFrustum(splitDistance[j], splitDistance[j + 1], camera, cameraForward, shadowSliceData);
                ShadowUtils.getDirectionLightShadowCullPlanes(camera._frustum, splitDistance[j], camera.nearClipPlane, lightForward, shadowSliceData);
                ShadowUtils.getDirectionalLightMatrices(lightUp, lightSide, lightForward, j, light.shadowNearPlane, shadowTileResolution, shadowSliceData, shadowMatrices);
                if (shadowCascades > 1) {
                    var shadowMapSize = this._shadowMapSize;
                    ShadowUtils.applySliceTransform(shadowTileResolution, shadowMapSize.z, shadowMapSize.w, j, this._viewportOffsets[j], shadowMatrices);
                }
                this._updateSingleShadowCasterShaderData(light, shadowSliceData, context);
                // upload pre-cascade infos.
                var center = boundSphere.center;
                var radius = boundSphere.radius;
                var offset = j * 4;
                splitBoundSpheres[offset] = center.x;
                splitBoundSpheres[offset + 1] = center.y;
                splitBoundSpheres[offset + 2] = center.z;
                splitBoundSpheres[offset + 3] = radius * radius;
                opaqueQueue.clear();
                alphaTestQueue.clear();
                transparentQueue.clear();
                var renderers = componentsManager._renderers;
                var elements = renderers._elements;
                for(var k = renderers.length - 1; k >= 0; --k){
                    ShadowUtils.shadowCullFrustum(context, light, elements[k], shadowSliceData);
                }
                if (opaqueQueue.elements.length || alphaTestQueue.elements.length) {
                    opaqueQueue.sort(RenderQueue._compareFromNearToFar);
                    alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
                    var _viewports_j = viewports[j], x = _viewports_j.x, y = _viewports_j.y;
                    rhi.setGlobalDepthBias(1.0, 1.0);
                    rhi.viewport(x, y, shadowTileResolution, shadowTileResolution);
                    // for no cascade is for the edge,for cascade is for the beyond maxCascade pixel can use (0,0,0) trick sample the shadowMap
                    rhi.scissor(x + 1, y + 1, shadowTileResolution - 2, shadowTileResolution - 2);
                    engine._renderCount++;
                    opaqueQueue.render(camera, Layer.Everything);
                    alphaTestQueue.render(camera, Layer.Everything);
                    rhi.setGlobalDepthBias(0, 0);
                }
            }
            this._existShadowMap = true;
        }
    };
    _proto._updateReceiversShaderData = function _updateReceiversShaderData() {
        var scene = this._camera.scene;
        var splitBoundSpheres = this._splitBoundSpheres;
        var shadowMatrices = this._shadowMatrices;
        var shadowCascades = scene.shadowCascades;
        // set zero matrix to project the index out of max cascade
        if (shadowCascades > 1) {
            for(var i = shadowCascades * 4, n = splitBoundSpheres.length; i < n; i++){
                splitBoundSpheres[i] = 0.0;
            }
        }
        // set zero matrix to project the index out of max cascade
        for(var i1 = shadowCascades * 16, n1 = shadowMatrices.length; i1 < n1; i1++){
            shadowMatrices[i1] = 0.0;
        }
        var shaderData = scene.shaderData;
        shaderData.setFloatArray(CascadedShadowCasterPass._shadowMatricesProperty, this._shadowMatrices);
        shaderData.setVector3(CascadedShadowCasterPass._shadowInfosProperty, this._shadowInfos);
        shaderData.setTexture(CascadedShadowCasterPass._shadowMapsProperty, this._depthTexture);
        shaderData.setFloatArray(CascadedShadowCasterPass._shadowSplitSpheresProperty, this._splitBoundSpheres);
        shaderData.setVector4(CascadedShadowCasterPass._shadowMapSize, this._shadowMapSize);
    };
    _proto._getCascadesSplitDistance = function _getCascadesSplitDistance(shadowFar) {
        var cascadesSplitDistance = CascadedShadowCasterPass._cascadesSplitDistance;
        var _this__camera_scene = this._camera.scene, shadowTwoCascadeSplits = _this__camera_scene.shadowTwoCascadeSplits, shadowFourCascadeSplits = _this__camera_scene.shadowFourCascadeSplits, shadowCascades = _this__camera_scene.shadowCascades;
        var _this__camera = this._camera, nearClipPlane = _this__camera.nearClipPlane, aspectRatio = _this__camera.aspectRatio, fieldOfView = _this__camera.fieldOfView;
        cascadesSplitDistance[0] = nearClipPlane;
        var range = shadowFar - nearClipPlane;
        var tFov = Math.tan(MathUtil$1.degreeToRadian(fieldOfView) * 0.5);
        var denominator = 1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0);
        switch(shadowCascades){
            case ShadowCascadesMode.NoCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(shadowFar, denominator);
                break;
            case ShadowCascadesMode.TwoCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowTwoCascadeSplits, denominator);
                cascadesSplitDistance[2] = this._getFarWithRadius(shadowFar, denominator);
                break;
            case ShadowCascadesMode.FourCascades:
                cascadesSplitDistance[1] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.x, denominator);
                cascadesSplitDistance[2] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.y, denominator);
                cascadesSplitDistance[3] = this._getFarWithRadius(nearClipPlane + range * shadowFourCascadeSplits.z, denominator);
                cascadesSplitDistance[4] = this._getFarWithRadius(shadowFar, denominator);
                break;
        }
    };
    _proto._getFarWithRadius = function _getFarWithRadius(radius, denominator) {
        // use the frustum side as the radius and get the far distance form camera.
        // var tFov: number = Math.tan(fov * 0.5);// get this the equation using Pythagorean
        // return Math.sqrt(radius * radius / (1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0)));
        return Math.sqrt(radius * radius / denominator);
    };
    _proto._getAvailableRenderTarget = function _getAvailableRenderTarget() {
        var engine = this._engine;
        var format = this._shadowMapFormat;
        var _this__shadowMapSize = this._shadowMapSize, width = _this__shadowMapSize.z, height = _this__shadowMapSize.w;
        var depthTexture = this._depthTexture;
        var renderTarget = this._renderTargets;
        if (renderTarget == null || (depthTexture == null ? void 0 : depthTexture.width) !== width || (depthTexture == null ? void 0 : depthTexture.height) !== height || (depthTexture == null ? void 0 : depthTexture.format) !== format) {
            depthTexture = this._depthTexture = new Texture2D(engine, width, height, format, false);
            depthTexture.wrapModeV = depthTexture.wrapModeU = TextureWrapMode$1.Clamp;
            if (engine._hardwareRenderer._isWebGL2) {
                depthTexture.depthCompareFunction = TextureDepthCompareFunction.Less;
            }
            renderTarget == null ? void 0 : renderTarget._addReferCount(-1);
            if (this._supportDepthTexture) {
                renderTarget = this._renderTargets = new RenderTarget(engine, width, height, null, depthTexture);
            } else {
                renderTarget = this._renderTargets = new RenderTarget(engine, width, height, depthTexture);
            }
            renderTarget._addReferCount(1);
        }
        return renderTarget;
    };
    _proto._updateShadowSettings = function _updateShadowSettings() {
        var scene = this._camera.scene;
        var shadowFormat = ShadowUtils.shadowDepthFormat(scene.shadowResolution, this._supportDepthTexture);
        var shadowResolution = ShadowUtils.shadowResolution(scene.shadowResolution);
        var shadowCascades = scene.shadowCascades;
        if (shadowFormat !== this._shadowMapFormat || shadowResolution !== this._shadowMapResolution || shadowCascades !== this._shadowCascadeMode) {
            this._shadowMapFormat = shadowFormat;
            this._shadowMapResolution = shadowResolution;
            this._shadowCascadeMode = shadowCascades;
            if (shadowCascades == ShadowCascadesMode.NoCascades) {
                this._shadowTileResolution = shadowResolution;
                this._shadowMapSize.set(1 / shadowResolution, 1 / shadowResolution, shadowResolution, shadowResolution);
            } else {
                var shadowTileResolution = ShadowUtils.getMaxTileResolutionInAtlas(shadowResolution, shadowResolution, shadowCascades);
                this._shadowTileResolution = shadowTileResolution;
                var width = shadowTileResolution * 2;
                var height = shadowCascades == ShadowCascadesMode.TwoCascades ? shadowTileResolution : shadowTileResolution * 2;
                this._shadowMapSize.set(1.0 / width, 1.0 / height, width, height);
            }
            var renderTargets = this._renderTargets;
            if (renderTargets) {
                renderTargets._addReferCount(-1);
                renderTargets.destroy();
                this._renderTargets = null;
            }
            var viewportOffset = this._viewportOffsets;
            var shadowTileResolution1 = this._shadowTileResolution;
            switch(shadowCascades){
                case ShadowCascadesMode.NoCascades:
                    viewportOffset[0].set(0, 0);
                    break;
                case ShadowCascadesMode.TwoCascades:
                    viewportOffset[0].set(0, 0);
                    viewportOffset[1].set(shadowTileResolution1, 0);
                    break;
                case ShadowCascadesMode.FourCascades:
                    viewportOffset[0].set(0, 0);
                    viewportOffset[1].set(shadowTileResolution1, 0);
                    viewportOffset[2].set(0, shadowTileResolution1);
                    viewportOffset[3].set(shadowTileResolution1, shadowTileResolution1);
            }
        }
    };
    _proto._updateSingleShadowCasterShaderData = function _updateSingleShadowCasterShaderData(light, shadowSliceData, context) {
        var virtualCamera = shadowSliceData.virtualCamera;
        ShadowUtils.getShadowBias(light, virtualCamera.projectionMatrix, this._shadowTileResolution, this._shadowBias);
        var sceneShaderData = this._camera.scene.shaderData;
        sceneShaderData.setVector2(CascadedShadowCasterPass._lightShadowBiasProperty, this._shadowBias);
        sceneShaderData.setVector3(CascadedShadowCasterPass._lightDirectionProperty, light.direction);
        context.applyVirtualCamera(virtualCamera);
    };
    return CascadedShadowCasterPass;
}();
(function() {
    CascadedShadowCasterPass._lightShadowBiasProperty = ShaderProperty.getByName("scene_ShadowBias");
})();
(function() {
    CascadedShadowCasterPass._lightDirectionProperty = ShaderProperty.getByName("scene_LightDirection");
})();
(function() {
    CascadedShadowCasterPass._shadowMatricesProperty = ShaderProperty.getByName("scene_ShadowMatrices");
})();
(function() {
    CascadedShadowCasterPass._shadowMapSize = ShaderProperty.getByName("scene_ShadowMapSize");
})();
(function() {
    CascadedShadowCasterPass._shadowInfosProperty = ShaderProperty.getByName("scene_ShadowInfo");
})();
(function() {
    CascadedShadowCasterPass._shadowMapsProperty = ShaderProperty.getByName("scene_ShadowMap");
})();
(function() {
    CascadedShadowCasterPass._shadowSplitSpheresProperty = ShaderProperty.getByName("scene_ShadowSplitSpheres");
})();
(function() {
    CascadedShadowCasterPass._maxCascades = 4;
})();
(function() {
    CascadedShadowCasterPass._cascadesSplitDistance = new Array(CascadedShadowCasterPass._maxCascades + 1);
})();
(function() {
    CascadedShadowCasterPass._viewport = new Vector4(0, 0, 1, 1);
})();
(function() {
    CascadedShadowCasterPass._clearColor = new Color$1(1, 1, 1, 1);
})();
(function() {
    CascadedShadowCasterPass._tempVector = new Vector3();
})();
(function() {
    CascadedShadowCasterPass._tempMatrix0 = new Matrix();
})();

var passNum = 0;
/**
 * RenderPass.
 */ var RenderPass = /*#__PURE__*/ function() {
    function RenderPass(name, priority, renderTarget, replaceMaterial, mask) {
        if (name === void 0) name = "RENDER_PASS" + passNum++;
        if (priority === void 0) priority = 0;
        if (renderTarget === void 0) renderTarget = null;
        if (replaceMaterial === void 0) replaceMaterial = null;
        if (mask === void 0) mask = null;
        this.name = name;
        this.enabled = true;
        this.priority = priority;
        this.renderTarget = renderTarget;
        this.replaceMaterial = replaceMaterial;
        this.mask = mask || Layer.Everything;
        this.renderOverride = false; // If renderOverride is set to true, you need to implement the render method
    }
    var _proto = RenderPass.prototype;
    /**
   * Rendering callback, will be executed if renderOverride is set to true.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */ _proto.render = function render(camera, opaqueQueue, alphaTestQueue, transparentQueue) {};
    /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */ _proto.preRender = function preRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {};
    /**
   * Post rendering callback.
   * @param camera - Camera
   * @param opaqueQueue - Opaque queue
   * @param alphaTestQueue - Alpha test queue
   * @param transparentQueue - Transparent queue
   */ _proto.postRender = function postRender(camera, opaqueQueue, alphaTestQueue, transparentQueue) {};
    return RenderPass;
}();

/**
 * Basic render pipeline.
 */ var BasicRenderPipeline = /*#__PURE__*/ function() {
    function BasicRenderPipeline(camera) {
        /** @internal */ this._allSpriteMasks = new DisorderedArray();
        this._lastCanvasSize = new Vector2();
        this._camera = camera;
        var engine = camera.engine;
        this._opaqueQueue = new RenderQueue(engine);
        this._alphaTestQueue = new RenderQueue(engine);
        this._transparentQueue = new RenderQueue(engine);
        this._cascadedShadowCaster = new CascadedShadowCasterPass(camera);
        this._renderPassArray = [];
        this._defaultPass = new RenderPass("default", 0, null, null, 0);
        this.addRenderPass(this._defaultPass);
    }
    var _proto = BasicRenderPipeline.prototype;
    /**
   * Add render pass.
   * @param nameOrPass - The name of this Pass or RenderPass object. When it is a name, the following parameters need to be provided
   * @param priority - Priority, less than 0 before the default pass, greater than 0 after the default pass
   * @param renderTarget - The specified Render Target
   * @param replaceMaterial -  Replaced material
   * @param mask - Perform bit and operations with Entity.Layer to filter the objects that this Pass needs to render
   */ _proto.addRenderPass = function addRenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask) {
        if (priority === void 0) priority = null;
        if (renderTarget === void 0) renderTarget = null;
        if (replaceMaterial === void 0) replaceMaterial = null;
        if (mask === void 0) mask = null;
        if (typeof nameOrPass === "string") {
            var renderPass = new RenderPass(nameOrPass, priority, renderTarget, replaceMaterial, mask);
            this._renderPassArray.push(renderPass);
        } else if (_instanceof$2(nameOrPass, RenderPass)) {
            this._renderPassArray.push(nameOrPass);
        }
        this._renderPassArray.sort(function(p1, p2) {
            return p1.priority - p2.priority;
        });
    };
    /**
   * Remove render pass by name or render pass object.
   * @param nameOrPass - Render pass name or render pass object
   */ _proto.removeRenderPass = function removeRenderPass(nameOrPass) {
        var pass;
        if (typeof nameOrPass === "string") pass = this.getRenderPass(nameOrPass);
        else if (_instanceof$2(nameOrPass, RenderPass)) pass = nameOrPass;
        if (pass) {
            var idx = this._renderPassArray.indexOf(pass);
            this._renderPassArray.splice(idx, 1);
        }
    };
    /**
   * Get render pass by name.
   * @param  name - Render pass name
   */ _proto.getRenderPass = function getRenderPass(name) {
        for(var i = 0, len = this._renderPassArray.length; i < len; i++){
            var pass = this._renderPassArray[i];
            if (pass.name === name) return pass;
        }
        return null;
    };
    /**
   * Destroy internal resources.
   */ _proto.destroy = function destroy() {
        this._opaqueQueue.destroy();
        this._alphaTestQueue.destroy();
        this._transparentQueue.destroy();
        this._allSpriteMasks = null;
        this._renderPassArray = null;
        this._defaultPass = null;
        this._camera = null;
    };
    /**
   * Perform scene rendering.
   * @param context - Render context
   * @param cubeFace - Render surface of cube texture
   * @param mipLevel - Set mip level the data want to write
   */ _proto.render = function render(context, cubeFace, mipLevel) {
        var _scene__sunLight;
        var camera = this._camera;
        var scene = camera.scene;
        var opaqueQueue = this._opaqueQueue;
        var alphaTestQueue = this._alphaTestQueue;
        var transparentQueue = this._transparentQueue;
        camera.engine._spriteMaskManager.clear();
        context.pipelineStageTagValue = BasicRenderPipeline._shadowCasterPipelineStageTagValue;
        if (scene.castShadows && ((_scene__sunLight = scene._sunLight) == null ? void 0 : _scene__sunLight.shadowType) !== exports.ShadowType.None) {
            this._cascadedShadowCaster._render(context);
        }
        opaqueQueue.clear();
        alphaTestQueue.clear();
        transparentQueue.clear();
        this._allSpriteMasks.length = 0;
        context.applyVirtualCamera(camera._virtualCamera);
        context.pipelineStageTagValue = BasicRenderPipeline._forwardPipelineStageTagValue;
        this._callRender(context);
        opaqueQueue.sort(RenderQueue._compareFromNearToFar);
        alphaTestQueue.sort(RenderQueue._compareFromNearToFar);
        transparentQueue.sort(RenderQueue._compareFromFarToNear);
        for(var i = 0, len = this._renderPassArray.length; i < len; i++){
            this._drawRenderPass(context, this._renderPassArray[i], camera, cubeFace, mipLevel);
        }
    };
    _proto._drawRenderPass = function _drawRenderPass(context, pass, camera, cubeFace, mipLevel) {
        pass.preRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
        if (pass.enabled) {
            var engine = camera.engine, scene = camera.scene;
            var background = scene.background;
            var rhi = engine._hardwareRenderer;
            var renderTarget = camera.renderTarget || pass.renderTarget;
            rhi.activeRenderTarget(renderTarget, camera.viewport, mipLevel);
            renderTarget == null ? void 0 : renderTarget._setRenderTargetInfo(cubeFace, mipLevel);
            var _pass_clearFlags;
            var clearFlags = (_pass_clearFlags = pass.clearFlags) != null ? _pass_clearFlags : camera.clearFlags;
            var _pass_clearColor;
            var color = (_pass_clearColor = pass.clearColor) != null ? _pass_clearColor : background.solidColor;
            if (clearFlags !== CameraClearFlags.None) {
                rhi.clearRenderTarget(camera.engine, clearFlags, color);
            }
            if (pass.renderOverride) {
                pass.render(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
            } else {
                this._opaqueQueue.render(camera, pass.mask);
                this._alphaTestQueue.render(camera, pass.mask);
                if (camera.clearFlags & CameraClearFlags.Color) {
                    if (background.mode === BackgroundMode.Sky) {
                        background.sky._render(context);
                    } else if (background.mode === BackgroundMode.Texture && background.texture) {
                        this._drawBackgroundTexture(engine, background);
                    }
                }
                this._transparentQueue.render(camera, pass.mask);
            }
            renderTarget == null ? void 0 : renderTarget._blitRenderTarget();
            renderTarget == null ? void 0 : renderTarget.generateMipmaps();
        }
        pass.postRender(camera, this._opaqueQueue, this._alphaTestQueue, this._transparentQueue);
    };
    /**
   * Push render data to render queue.
   * @param context - Render context
   * @param data - Render data
   */ _proto.pushRenderData = function pushRenderData(context, data) {
        var material = data.material;
        var renderStates = material.renderStates;
        var materialSubShader = material.shader.subShaders[0];
        var replacementShader = context.replacementShader;
        if (replacementShader) {
            var replacementSubShaders = replacementShader.subShaders;
            var replacementTagKey = context.replacementTag;
            if (replacementTagKey) {
                for(var i = 0, n = replacementSubShaders.length; i < n; i++){
                    var subShader = replacementSubShaders[i];
                    if (subShader.getTagValue(replacementTagKey) === materialSubShader.getTagValue(replacementTagKey)) {
                        this.pushRenderDataWihShader(context, data, subShader.passes, renderStates);
                        break;
                    }
                }
            } else {
                this.pushRenderDataWihShader(context, data, replacementSubShaders[0].passes, renderStates);
            }
        } else {
            this.pushRenderDataWihShader(context, data, materialSubShader.passes, renderStates);
        }
    };
    _proto.pushRenderDataWihShader = function pushRenderDataWihShader(context, element, shaderPasses, renderStates) {
        var pipelineStage = context.pipelineStageTagValue;
        var renderElementPool = context.camera.engine._renderElementPool;
        for(var i = 0, n = shaderPasses.length; i < n; i++){
            var shaderPass = shaderPasses[i];
            if (shaderPass.getTagValue(RenderContext.pipelineStageKey) === pipelineStage) {
                var renderElement = renderElementPool.getFromPool();
                renderElement.set(element, shaderPass, renderStates[i]);
                switch(renderElement.renderState.renderQueueType){
                    case RenderQueueType.Transparent:
                        this._transparentQueue.pushRenderElement(renderElement);
                        break;
                    case RenderQueueType.AlphaTest:
                        this._alphaTestQueue.pushRenderElement(renderElement);
                        break;
                    case RenderQueueType.Opaque:
                        this._opaqueQueue.pushRenderElement(renderElement);
                        break;
                }
            }
        }
    };
    _proto._drawBackgroundTexture = function _drawBackgroundTexture(engine, background) {
        var rhi = engine._hardwareRenderer;
        var _backgroundTextureMaterial = engine._backgroundTextureMaterial, canvas = engine.canvas;
        var mesh = background._mesh;
        if ((this._lastCanvasSize.x !== canvas.width || this._lastCanvasSize.y !== canvas.height) && background._textureFillMode !== BackgroundTextureFillMode.Fill) {
            this._lastCanvasSize.set(canvas.width, canvas.height);
            background._resizeBackgroundTexture();
        }
        var program = _backgroundTextureMaterial.shader.subShaders[0].passes[0]._getShaderProgram(engine, Shader._compileMacros);
        program.bind();
        program.uploadAll(program.materialUniformBlock, _backgroundTextureMaterial.shaderData);
        program.uploadUnGroupTextures();
        _backgroundTextureMaterial.renderState._apply(engine, false);
        rhi.drawPrimitive(mesh, mesh.subMesh, program);
    };
    _proto._callRender = function _callRender(context) {
        var engine = context.camera.engine;
        var renderers = engine._componentsManager._renderers;
        var camera = context.camera;
        var elements = renderers._elements;
        for(var i = renderers.length - 1; i >= 0; --i){
            var renderer = elements[i];
            // filter by camera culling mask.
            if (!(camera.cullingMask & renderer._entity.layer)) {
                continue;
            }
            // filter by camera frustum.
            if (camera.enableFrustumCulling) {
                if (!camera._frustum.intersectsBox(renderer.bounds)) {
                    continue;
                }
            }
            renderer._renderFrameCount = engine.time.frameCount;
            renderer._prepareRender(context);
        }
    };
    _create_class$3(BasicRenderPipeline, [
        {
            key: "defaultRenderPass",
            get: /**
   * Default render pass.
   */ function get() {
                return this._defaultPass;
            }
        }
    ]);
    return BasicRenderPipeline;
}();
(function() {
    BasicRenderPipeline._shadowCasterPipelineStageTagValue = PipelineStage.ShadowCaster;
})();
(function() {
    BasicRenderPipeline._forwardPipelineStageTagValue = PipelineStage.Forward;
})();

var _Camera;
var MathTemp = function MathTemp() {
};
(function() {
    MathTemp.tempVec4 = new Vector4();
})();
(function() {
    MathTemp.tempVec3 = new Vector3();
})();
(function() {
    MathTemp.tempVec2 = new Vector2();
})();
exports.Camera = (_Camera = /*#__PURE__*/ function(Component) {
    _inherits$2(Camera1, Component);
    function Camera1(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        /** Rendering priority - A Camera with higher priority will be rendered on top of a camera with lower priority. */ _this.priority = 0;
        /** Whether to enable frustum culling, it is enabled by default. */ _this.enableFrustumCulling = true;
        /**
   * Determining what to clear when rendering by a Camera.
   * @defaultValue `CameraClearFlags.All`
   */ _this.clearFlags = CameraClearFlags.All;
        /**
   * Culling mask - which layers the camera renders.
   * @remarks Support bit manipulation, corresponding to `Layer`.
   */ _this.cullingMask = Layer.Everything;
        /** @internal */ _this._globalShaderMacro = new ShaderMacroCollection();
        /** @internal */ _this._frustum = new BoundingFrustum();
        /** @internal */ _this._virtualCamera = new VirtualCamera();
        /** @internal */ _this._replacementShader = null;
        /** @internal */ _this._replacementSubShaderTag = null;
        _this._shaderData = new ShaderData(ShaderDataGroup.Camera);
        _this._isProjMatSetting = false;
        _this._nearClipPlane = 0.1;
        _this._farClipPlane = 100;
        _this._fieldOfView = 45;
        _this._orthographicSize = 10;
        _this._isProjectionDirty = true;
        _this._isInvProjMatDirty = true;
        _this._isFrustumProjectDirty = true;
        _this._customAspectRatio = undefined;
        _this._renderTarget = null;
        _this._viewport = new Vector4(0, 0, 1, 1);
        _this._inverseProjectionMatrix = new Matrix();
        _this._lastAspectSize = new Vector2(0, 0);
        _this._invViewProjMat = new Matrix();
        var transform = _this.entity.transform;
        _this._transform = transform;
        _this._isViewMatrixDirty = transform.registerWorldChangeFlag();
        _this._isInvViewProjDirty = transform.registerWorldChangeFlag();
        _this._frustumViewChangeFlag = transform.registerWorldChangeFlag();
        _this._renderPipeline = new BasicRenderPipeline(_assert_this_initialized(_this));
        _this.shaderData._addReferCount(1);
        return _this;
    }
    var _proto = Camera1.prototype;
    /**
   * Restore the automatic calculation of projection matrix through fieldOfView, nearClipPlane and farClipPlane.
   */ _proto.resetProjectionMatrix = function resetProjectionMatrix() {
        this._isProjMatSetting = false;
        this._projMatChange();
    };
    /**
   * Restore the automatic calculation of the aspect ratio through the viewport aspect ratio.
   */ _proto.resetAspectRatio = function resetAspectRatio() {
        this._customAspectRatio = undefined;
        this._projMatChange();
    };
    /**
   * Transform a point from world space to viewport space.
   * @param point - Point in world space
   * @param out - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @returns Point in viewport space
   */ _proto.worldToViewportPoint = function worldToViewportPoint(point, out) {
        var cameraPoint = MathTemp.tempVec3;
        var viewportPoint = MathTemp.tempVec4;
        Vector3.transformCoordinate(point, this.viewMatrix, cameraPoint);
        Vector3.transformToVec4(cameraPoint, this.projectionMatrix, viewportPoint);
        var w = viewportPoint.w;
        out.set((viewportPoint.x / w + 1.0) * 0.5, (1.0 - viewportPoint.y / w) * 0.5, -cameraPoint.z);
        return out;
    };
    /**
   * Transform a point from viewport space to world space.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates, Z is in world space units from the plane that camera forward is normal to
   * @param out - Point in world space
   * @returns Point in world space
   */ _proto.viewportToWorldPoint = function viewportToWorldPoint(point, out) {
        var _this = this, nearClipPlane = _this.nearClipPlane, farClipPlane = _this.farClipPlane;
        var nf = 1 / (nearClipPlane - farClipPlane);
        var z;
        if (this.isOrthographic) {
            z = -point.z * 2 * nf;
            z += (farClipPlane + nearClipPlane) * nf;
        } else {
            var pointZ = point.z;
            z = -pointZ * (nearClipPlane + farClipPlane) * nf;
            z += 2 * nearClipPlane * farClipPlane * nf;
            z = z / pointZ;
        }
        this._innerViewportToWorldPoint(point.x, point.y, (z + 1.0) / 2.0, this._getInvViewProjMat(), out);
        return out;
    };
    /**
   * Generate a ray by a point in viewport.
   * @param point - Point in viewport space, X and Y are the camera viewport space coordinates
   * @param out - Ray
   * @returns Ray
   */ _proto.viewportPointToRay = function viewportPointToRay(point, out) {
        var invViewProjMat = this._getInvViewProjMat();
        // Use the intersection of the near clipping plane as the origin point.
        var origin = this._innerViewportToWorldPoint(point.x, point.y, 0.0, invViewProjMat, out.origin);
        // Use the intersection of the far clipping plane as the origin point.
        var direction = this._innerViewportToWorldPoint(point.x, point.y, 1.0, invViewProjMat, out.direction);
        Vector3.subtract(direction, origin, direction);
        direction.normalize();
        return out;
    };
    /**
   * Transform the X and Y coordinates of a point from screen space to viewport space
   * @param point - Point in screen space
   * @param out - Point in viewport space
   * @returns Point in viewport space
   */ _proto.screenToViewportPoint = function screenToViewportPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (point.x / canvas.width - viewport.x) / viewport.z;
        out.y = (point.y / canvas.height - viewport.y) / viewport.w;
        point.z !== undefined && (out.z = point.z);
        return out;
    };
    /**
   * Transform the X and Y coordinates of a point from viewport space to screen space.
   * @param point - Point in viewport space
   * @param out - Point in screen space
   * @returns Point in screen space
   */ _proto.viewportToScreenPoint = function viewportToScreenPoint(point, out) {
        var canvas = this.engine.canvas;
        var viewport = this.viewport;
        out.x = (viewport.x + point.x * viewport.z) * canvas.width;
        out.y = (viewport.y + point.y * viewport.w) * canvas.height;
        point.z !== undefined && (out.z = point.z);
        return out;
    };
    /**
   * Transform a point from world space to screen space.
   *
   * @remarks
   * Screen space is defined in pixels, the left-top of the screen is (0,0), the right-top is (canvasPixelWidth,canvasPixelHeight).
   *
   * @param point - Point in world space
   * @param out - The result will be stored
   * @returns X and Y are the coordinates of the point in screen space, Z is the distance from the camera in world space
   */ _proto.worldToScreenPoint = function worldToScreenPoint(point, out) {
        this.worldToViewportPoint(point, out);
        return this.viewportToScreenPoint(out, out);
    };
    /**
   * Transform a point from screen space to world space.
   *
   * @param point - Screen space point, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight), The z position is in world units from the camera
   * @param out - Point in world space
   * @returns Point in world space
   */ _proto.screenToWorldPoint = function screenToWorldPoint(point, out) {
        this.screenToViewportPoint(point, out);
        return this.viewportToWorldPoint(out, out);
    };
    /**
   * Generate a ray by a point in screen.
   * @param point - Point in screen space, the top-left of the screen is (0,0), the right-bottom is (pixelWidth,pixelHeight)
   * @param out - Ray
   * @returns Ray
   */ _proto.screenPointToRay = function screenPointToRay(point, out) {
        var viewportPoint = MathTemp.tempVec2;
        this.screenToViewportPoint(point, viewportPoint);
        return this.viewportPointToRay(viewportPoint, out);
    };
    /**
   * Manually call the rendering of the camera.
   * @param cubeFace - Cube rendering surface collection
   * @param mipLevel - Set mip level the data want to write, only take effect in webgl2.0
   */ _proto.render = function render(cubeFace, mipLevel) {
        if (mipLevel === void 0) mipLevel = 0;
        var context = this.engine._renderContext;
        var virtualCamera = this._virtualCamera;
        var transform = this.entity.transform;
        Matrix.multiply(this.projectionMatrix, this.viewMatrix, virtualCamera.viewProjectionMatrix);
        virtualCamera.position.copyFrom(transform.worldPosition);
        if (virtualCamera.isOrthographic) {
            virtualCamera.forward.copyFrom(transform.worldForward);
        }
        context.camera = this;
        context.virtualCamera = virtualCamera;
        context.replacementShader = this._replacementShader;
        context.replacementTag = this._replacementSubShaderTag;
        // compute cull frustum.
        if (this.enableFrustumCulling && (this._frustumViewChangeFlag.flag || this._isFrustumProjectDirty)) {
            this._frustum.calculateFromMatrix(virtualCamera.viewProjectionMatrix);
            this._frustumViewChangeFlag.flag = false;
            this._isFrustumProjectDirty = false;
        }
        this._updateShaderData();
        // union scene and camera macro.
        ShaderMacroCollection.unionCollection(this.scene._globalShaderMacro, this.shaderData._macroCollection, this._globalShaderMacro);
        if (mipLevel > 0 && !this.engine._hardwareRenderer.isWebGL2) {
            mipLevel = 0;
            Logger.error("mipLevel only take effect in WebGL2.0");
        }
        this._renderPipeline.render(context, cubeFace, mipLevel);
        this._engine._renderCount++;
    };
    _proto.setReplacementShader = function setReplacementShader(shader, replacementTag) {
        this._replacementShader = shader;
        this._replacementSubShaderTag = typeof replacementTag === "string" ? ShaderTagKey.getByName(replacementTag) : replacementTag;
    };
    /**
   * Reset and clear the replacement shader.
   */ _proto.resetReplacementShader = function resetReplacementShader() {
        this._replacementShader = null;
        this._replacementSubShaderTag = null;
    };
    /**
   * @inheritdoc
   */ _proto._onEnable = function _onEnable() {
        this.entity.scene._attachRenderCamera(this);
    };
    /**
   * @inheritdoc
   */ _proto._onDisable = function _onDisable() {
        this.entity.scene._detachRenderCamera(this);
    };
    /**
   * @internal
   * @inheritdoc
   */ _proto._onDestroy = function _onDestroy() {
        var _this__renderPipeline;
        Component.prototype._onDestroy.call(this);
        (_this__renderPipeline = this._renderPipeline) == null ? void 0 : _this__renderPipeline.destroy();
        this._isInvViewProjDirty.destroy();
        this._isViewMatrixDirty.destroy();
        this.shaderData._addReferCount(-1);
        this._entity = null;
        this._globalShaderMacro = null;
        this._frustum = null;
        this._renderPipeline = null;
        this._virtualCamera = null;
        this._shaderData = null;
        this._frustumViewChangeFlag = null;
        this._transform = null;
        this._isViewMatrixDirty = null;
        this._isInvViewProjDirty = null;
        this._viewport = null;
        this._inverseProjectionMatrix = null;
        this._lastAspectSize = null;
        this._invViewProjMat = null;
    };
    _proto._projMatChange = function _projMatChange() {
        this._isFrustumProjectDirty = true;
        this._isProjectionDirty = true;
        this._isInvProjMatDirty = true;
        this._isInvViewProjDirty.flag = true;
    };
    _proto._innerViewportToWorldPoint = function _innerViewportToWorldPoint(x, y, z, invViewProjMat, out) {
        // Depth is a normalized value, 0 is nearPlane, 1 is farClipPlane.
        // Transform to clipping space matrix
        var clipPoint = MathTemp.tempVec3;
        clipPoint.set(x * 2 - 1, 1 - y * 2, z * 2 - 1);
        Vector3.transformCoordinate(clipPoint, invViewProjMat, out);
        return out;
    };
    _proto._updateShaderData = function _updateShaderData() {
        var shaderData = this.shaderData;
        shaderData.setMatrix(exports.Camera._inverseViewMatrixProperty, this._transform.worldMatrix);
        shaderData.setVector3(exports.Camera._cameraPositionProperty, this._transform.worldPosition);
    };
    /**
   * The inverse matrix of view projection matrix.
   */ _proto._getInvViewProjMat = function _getInvViewProjMat() {
        if (this._isInvViewProjDirty.flag) {
            this._isInvViewProjDirty.flag = false;
            Matrix.multiply(this._transform.worldMatrix, this._getInverseProjectionMatrix(), this._invViewProjMat);
        }
        return this._invViewProjMat;
    };
    /**
   * The inverse of the projection matrix.
   */ _proto._getInverseProjectionMatrix = function _getInverseProjectionMatrix() {
        if (this._isInvProjMatDirty) {
            this._isInvProjMatDirty = false;
            Matrix.invert(this.projectionMatrix, this._inverseProjectionMatrix);
        }
        return this._inverseProjectionMatrix;
    };
    _create_class$3(Camera1, [
        {
            key: "shaderData",
            get: /**
   * Shader data.
   */ function get() {
                return this._shaderData;
            }
        },
        {
            key: "nearClipPlane",
            get: /**
   * Near clip plane - the closest point to the camera when rendering occurs.
   */ function get() {
                return this._nearClipPlane;
            },
            set: function set(value) {
                this._nearClipPlane = value;
                this._projMatChange();
            }
        },
        {
            key: "farClipPlane",
            get: /**
   * Far clip plane - the furthest point to the camera when rendering occurs.
   */ function get() {
                return this._farClipPlane;
            },
            set: function set(value) {
                this._farClipPlane = value;
                this._projMatChange();
            }
        },
        {
            key: "fieldOfView",
            get: /**
   * The camera's view angle. activating when camera use perspective projection.
   */ function get() {
                return this._fieldOfView;
            },
            set: function set(value) {
                this._fieldOfView = value;
                this._projMatChange();
            }
        },
        {
            key: "aspectRatio",
            get: /**
   * Aspect ratio. The default is automatically calculated by the viewport's aspect ratio. If it is manually set,
   * the manual value will be kept. Call resetAspectRatio() to restore it.
   */ function get() {
                var canvas = this._entity.engine.canvas;
                var _this__customAspectRatio;
                return (_this__customAspectRatio = this._customAspectRatio) != null ? _this__customAspectRatio : canvas.width * this._viewport.z / (canvas.height * this._viewport.w);
            },
            set: function set(value) {
                this._customAspectRatio = value;
                this._projMatChange();
            }
        },
        {
            key: "viewport",
            get: /**
   * Viewport, normalized expression, the upper left corner is (0, 0), and the lower right corner is (1, 1).
   * @remarks Re-assignment is required after modification to ensure that the modification takes effect.
   */ function get() {
                return this._viewport;
            },
            set: function set(value) {
                if (value !== this._viewport) {
                    this._viewport.copyFrom(value);
                }
                this._projMatChange();
            }
        },
        {
            key: "isOrthographic",
            get: /**
   * Whether it is orthogonal, the default is false. True will use orthographic projection, false will use perspective projection.
   */ function get() {
                return this._virtualCamera.isOrthographic;
            },
            set: function set(value) {
                this._virtualCamera.isOrthographic = value;
                this._projMatChange();
            }
        },
        {
            key: "orthographicSize",
            get: /**
   * Half the size of the camera in orthographic mode.
   */ function get() {
                return this._orthographicSize;
            },
            set: function set(value) {
                this._orthographicSize = value;
                this._projMatChange();
            }
        },
        {
            key: "viewMatrix",
            get: /**
   * View matrix.
   */ function get() {
                var viewMatrix = this._virtualCamera.viewMatrix;
                if (this._isViewMatrixDirty.flag) {
                    this._isViewMatrixDirty.flag = false;
                    // Ignore scale.
                    var transform = this._transform;
                    Matrix.rotationTranslation(transform.worldRotationQuaternion, transform.worldPosition, viewMatrix);
                    viewMatrix.invert();
                }
                return viewMatrix;
            }
        },
        {
            key: "projectionMatrix",
            get: function get() {
                var virtualCamera = this._virtualCamera;
                var projectionMatrix = virtualCamera.projectionMatrix;
                var canvas = this._entity.engine.canvas;
                if ((!this._isProjectionDirty || this._isProjMatSetting) && this._lastAspectSize.x === canvas.width && this._lastAspectSize.y === canvas.height) {
                    return projectionMatrix;
                }
                this._isProjectionDirty = false;
                this._lastAspectSize.x = canvas.width;
                this._lastAspectSize.y = canvas.height;
                var aspectRatio = this.aspectRatio;
                if (!virtualCamera.isOrthographic) {
                    Matrix.perspective(MathUtil$1.degreeToRadian(this._fieldOfView), aspectRatio, this._nearClipPlane, this._farClipPlane, projectionMatrix);
                } else {
                    var width = this._orthographicSize * aspectRatio;
                    var height = this._orthographicSize;
                    Matrix.ortho(-width, width, -height, height, this._nearClipPlane, this._farClipPlane, projectionMatrix);
                }
                return projectionMatrix;
            },
            set: /**
   * The projection matrix is â€‹â€‹calculated by the relevant parameters of the camera by default.
   * If it is manually set, the manual value will be maintained. Call resetProjectionMatrix() to restore it.
   */ function set(value) {
                this._virtualCamera.projectionMatrix.copyFrom(value);
                this._isProjMatSetting = true;
                this._projMatChange();
            }
        },
        {
            key: "enableHDR",
            get: /**
   * Whether to enable HDR.
   * @todo When render pipeline modification
   */ function get() {
                console.log("not implementation");
                return false;
            },
            set: function set(value) {
                console.log("not implementation");
            }
        },
        {
            key: "renderTarget",
            get: /**
   * RenderTarget. After setting, it will be rendered to the renderTarget. If it is empty, it will be rendered to the main canvas.
   */ function get() {
                return this._renderTarget;
            },
            set: function set(value) {
                if (this._renderTarget !== value) {
                    var _this__renderTarget;
                    value == null ? void 0 : value._addReferCount(1);
                    (_this__renderTarget = this._renderTarget) == null ? void 0 : _this__renderTarget._addReferCount(-1);
                    this._renderTarget = value;
                }
            }
        }
    ]);
    return Camera1;
}(Component), function() {
    /** @internal */ _Camera._inverseViewMatrixProperty = ShaderProperty.getByName("camera_ViewInvMat");
}(), function() {
    /** @internal */ _Camera._cameraPositionProperty = ShaderProperty.getByName("camera_Position");
}(), _Camera);
__decorate$1([
    deepClone
], exports.Camera.prototype, "_frustum", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_renderPipeline", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_virtualCamera", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_frustumViewChangeFlag", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_transform", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_isViewMatrixDirty", void 0);
__decorate$1([
    ignoreClone
], exports.Camera.prototype, "_isInvViewProjDirty", void 0);
__decorate$1([
    deepClone
], exports.Camera.prototype, "_viewport", void 0);
__decorate$1([
    deepClone
], exports.Camera.prototype, "_inverseProjectionMatrix", void 0);
__decorate$1([
    deepClone
], exports.Camera.prototype, "_lastAspectSize", void 0);
__decorate$1([
    deepClone
], exports.Camera.prototype, "_invViewProjMat", void 0);
exports.Camera = __decorate$1([
    dependentComponents(Transform, DependentMode.CheckOnly)
], exports.Camera);

var mimeType = {
    json: "json",
    gltf: "json",
    mtl: "json",
    prefab: "json",
    txt: "text",
    bin: "arraybuffer",
    png: "image",
    webp: "image",
    jpg: "image"
};
var defaultRetryCount = 1;
var defaultTimeout = Infinity;
var defaultInterval = 500;
/**
 * Web request.
 * @param url - The link
 * @param config - Load configuration
 */ function request(url, config) {
    if (config === void 0) config = {};
    return new AssetPromise(function(resolve, reject, setProgress) {
        var _config_retryCount;
        var retryCount = (_config_retryCount = config.retryCount) != null ? _config_retryCount : defaultRetryCount;
        var _config_retryInterval;
        var retryInterval = (_config_retryInterval = config.retryInterval) != null ? _config_retryInterval : defaultInterval;
        var _config_timeout;
        config.timeout = (_config_timeout = config.timeout) != null ? _config_timeout : defaultTimeout;
        var _config_type;
        config.type = (_config_type = config.type) != null ? _config_type : getMimeTypeFromUrl(url);
        var realRequest = config.type === "image" ? requestImage : requestRes;
        var lastError;
        var executor = new MultiExecutor(function() {
            return realRequest(url, config).onProgress(setProgress).then(function(res) {
                resolve(res);
                executor.stop();
            }).catch(function(err) {
                return lastError = err;
            });
        }, retryCount, retryInterval);
        executor.start(function() {
            reject(lastError);
        });
    });
}
function requestImage(url, config) {
    return new AssetPromise(function(resolve, reject) {
        var timeout = config.timeout;
        var img = new PlatformManager$1.polyfill.Image();
        var onerror = function() {
            reject(new Error("request " + url + " fail"));
        };
        img.onerror = onerror;
        img.onabort = onerror;
        var timeoutId = -1;
        if (timeout != Infinity) {
            timeoutId = PlatformManager$1.polyfill.window.setTimeout(function() {
                reject(new Error("request " + url + " timeout"));
            }, timeout);
        }
        img.onload = function(timeoutId) {
            return function() {
                // Call requestAnimationFrame to avoid iOS's bug.
                PlatformManager$1.polyfill.requestAnimationFrame(function() {
                    //@ts-ignore
                    resolve(img);
                    img.onload = null;
                    img.onerror = null;
                    img.onabort = null;
                });
                clearTimeout(timeoutId);
            };
        }(timeoutId);
        img.crossOrigin = "anonymous";
        img.src = url;
    });
}
function requestRes(url, config) {
    return new AssetPromise(function(resolve, reject, setProgress) {
        var xhr = new PlatformManager$1.polyfill.XMLHttpRequest();
        xhr.timeout = config.timeout;
        var _config_method;
        config.method = (_config_method = config.method) != null ? _config_method : "get";
        xhr.onload = function() {
            if (xhr.status < 200 || xhr.status >= 300) {
                reject(new Error("request failed from: " + url));
                return;
            }
            var _xhr_response;
            var result = (_xhr_response = xhr.response) != null ? _xhr_response : xhr.responseText;
            resolve(result);
        };
        xhr.onerror = function() {
            reject(new Error("request failed from: " + url));
        };
        xhr.ontimeout = function() {
            reject(new Error("request timeout from: " + url));
        };
        xhr.onprogress = function(e) {
            setProgress(e.loaded / e.total);
        };
        xhr.open(config.method, url, true);
        xhr.withCredentials = config.credentials === "include";
        //@ts-ignore
        xhr.responseType = config.type;
        var headers = config.headers;
        if (headers) {
            Object.keys(headers).forEach(function(name) {
                xhr.setRequestHeader(name, headers[name]);
            });
        }
        // @ts-ignore
        xhr.send(config.body);
    });
}
function getMimeTypeFromUrl(url) {
    var extname = url.substring(url.lastIndexOf(".") + 1);
    return mimeType[extname];
}
var MultiExecutor = /*#__PURE__*/ function() {
    function MultiExecutor(execFunc, totalCount, interval) {
        this.execFunc = execFunc;
        this.totalCount = totalCount;
        this.interval = interval;
        this._timeoutId = -100;
        this._currentCount = 0;
        this.exec = this.exec.bind(this);
    }
    var _proto = MultiExecutor.prototype;
    _proto.start = function start(done) {
        this.done = done;
        this.exec();
    };
    _proto.stop = function stop() {
        clearTimeout(this._timeoutId);
    };
    _proto.exec = function exec() {
        var _this = this;
        if (this._currentCount >= this.totalCount) {
            this.done && this.done();
            return;
        }
        this._currentCount++;
        this.execFunc(this._currentCount).then(function() {
            //@ts-ignore
            _this._timeoutId = setTimeout(_this.exec, _this.interval);
        });
    };
    return MultiExecutor;
}();

/**
 * Loader abstract class.
 */ var Loader = /*#__PURE__*/ function() {
    function Loader(useCache) {
        this.useCache = useCache;
        this.request = request;
    }
    /**
   * Register a class with a string name for serialization and deserialization.
   * @param key - class name
   * @param obj - class object
   */ Loader.registerClass = function registerClass(className, classDefine) {
        this._engineObjects[className] = classDefine;
    };
    /**
   * Get the class object by class name.
   * @param key - class name
   * @returns class object
   */ Loader.getClass = function getClass(className) {
        return this._engineObjects[className];
    };
    return Loader;
}();
(function() {
    Loader._engineObjects = {};
})();

/**
 * Asset Type.
 */ exports.AssetType = void 0;
(function(AssetType) {
    AssetType[/**
   * Plain text.
   * @remarks Will not be cached based on url in ResourceManager.
   */ "Text"] = "Text";
    AssetType[/**
   * JSON.
   * @remarks Will not be cached based on url in ResourceManager.
   */ "JSON"] = "JSON";
    AssetType[/**
   * ArrayBuffer.
   * @remarks Will not be cached based on url in ResourceManager.
   */ "Buffer"] = "Buffer";
    AssetType[/** 2D Texture. */ "Texture2D"] = "Texture2D";
    AssetType[/** Cube Texture. */ "TextureCube"] = "TextureCube";
    AssetType[/** Material. */ "Material"] = "Material";
    AssetType[/** Mesh. */ "Mesh"] = "Mesh";
    AssetType[/** AnimationClip. */ "AnimationClip"] = "AnimationClip";
    AssetType[/** AnimatorController. */ "AnimatorController"] = "AnimatorController";
    AssetType[/** Prefab.*/ "GLTF"] = "GLTF";
    AssetType[/** Compress Texture. */ "KTX"] = "KTX";
    AssetType[/** Cube Compress Texture. */ "KTXCube"] = "KTXCube";
    AssetType[/** Sprite. */ "Sprite"] = "Sprite";
    AssetType[/** Sprite Atlas. */ "SpriteAtlas"] = "SpriteAtlas";
    AssetType[/** Ambient light. */ "Env"] = "Environment";
    AssetType[/** Scene. */ "Scene"] = "Scene";
    AssetType[/** HDR to cube. */ "HDR"] = "HDR";
    AssetType[/** Font. */ "Font"] = "Font";
    AssetType[/** Source Font, include ttfã€ otf and woff. */ "SourceFont"] = "SourceFont";
})(exports.AssetType || (exports.AssetType = {}));

/**
 * Alpha blend mode.
 */ var BlendMode;
(function(BlendMode) {
    BlendMode[BlendMode[/** SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */ "Normal"] = 0] = "Normal";
    BlendMode[BlendMode[/** SRC ALPHA * SRC + ONE * DEST */ "Additive"] = 1] = "Additive";
})(BlendMode || (BlendMode = {}));

/**
 * Set which face for render.
 */ var RenderFace;
(function(RenderFace) {
    RenderFace[RenderFace[/** Render front face. */ "Front"] = 0] = "Front";
    RenderFace[RenderFace[/** Render back face. */ "Back"] = 1] = "Back";
    RenderFace[RenderFace[/** Render double face. */ "Double"] = 2] = "Double";
})(RenderFace || (RenderFace = {}));

var BaseMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(BaseMaterial, Material);
    function BaseMaterial(engine, shader) {
        var _this;
        _this = Material.call(this, engine, shader) || this;
        _this._renderFace = RenderFace.Front;
        _this._isTransparent = false;
        _this._blendMode = BlendMode.Normal;
        _this.shaderData.setFloat(BaseMaterial._alphaCutoffProp, 0);
        return _this;
    }
    var _proto = BaseMaterial.prototype;
    /**
   * Set if is transparent of the shader pass render state.
   * @param passIndex - Shader pass index
   * @param isTransparent - If is transparent
   */ _proto.setIsTransparent = function setIsTransparent(passIndex, isTransparent) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        var renderState = renderStates[passIndex];
        if (isTransparent) {
            renderState.blendState.targetBlendState.enabled = true;
            renderState.depthState.writeEnabled = false;
            renderState.renderQueueType = RenderQueueType.Transparent;
            this.shaderData.enableMacro(BaseMaterial._transparentMacro);
        } else {
            renderState.blendState.targetBlendState.enabled = false;
            renderState.depthState.writeEnabled = true;
            renderState.renderQueueType = this.shaderData.getFloat(BaseMaterial._alphaCutoffProp) ? RenderQueueType.AlphaTest : RenderQueueType.Opaque;
            this.shaderData.disableMacro(BaseMaterial._transparentMacro);
        }
    };
    /**
   * Set the blend mode of shader pass render state.
   * @param passIndex - Shader pass index
   * @param blendMode - Blend mode
   */ _proto.setBlendMode = function setBlendMode(passIndex, blendMode) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        var _renderStates_passIndex_blendState = renderStates[passIndex].blendState, target = _renderStates_passIndex_blendState.targetBlendState;
        switch(blendMode){
            case BlendMode.Normal:
                target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
                target.sourceAlphaBlendFactor = BlendFactor.One;
                target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
                target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
                break;
            case BlendMode.Additive:
                target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                target.destinationColorBlendFactor = BlendFactor.One;
                target.sourceAlphaBlendFactor = BlendFactor.One;
                target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
                target.colorBlendOperation = target.alphaBlendOperation = BlendOperation.Add;
                break;
        }
    };
    /**
   * Set the render face of shader pass render state.
   * @param passIndex - Shader pass index
   * @param renderFace - Render face
   */ _proto.setRenderFace = function setRenderFace(passIndex, renderFace) {
        var renderStates = this.renderStates;
        if (renderStates.length < passIndex) {
            throw "Pass should less than pass count.";
        }
        switch(renderFace){
            case RenderFace.Front:
                renderStates[passIndex].rasterState.cullMode = CullMode.Back;
                break;
            case RenderFace.Back:
                renderStates[passIndex].rasterState.cullMode = CullMode.Front;
                break;
            case RenderFace.Double:
                renderStates[passIndex].rasterState.cullMode = CullMode.Off;
                break;
        }
    };
    /**
   * Clone and return the instance.
   */ _proto.clone = function clone() {
        var dest = new BaseMaterial(this._engine, this.shader);
        this.cloneTo(dest);
        return dest;
    };
    /**
   * Clone to the target material.
   * @param target - target material
   */ _proto.cloneTo = function cloneTo(target) {
        Material.prototype.cloneTo.call(this, target);
        target._renderFace = this._renderFace;
        target._isTransparent = this._isTransparent;
        target._blendMode = this._blendMode;
    };
    _create_class$3(BaseMaterial, [
        {
            key: "shader",
            get: /**
   * Shader used by the material.
   */ function get() {
                return this._shader;
            },
            set: function set(value) {
                this._shader = value;
                var renderStates = this._renderStates;
                var lastStatesCount = renderStates.length;
                var maxPassCount = 0;
                var subShaders = value.subShaders;
                for(var i = 0; i < subShaders.length; i++){
                    maxPassCount = Math.max(subShaders[i].passes.length, maxPassCount);
                }
                if (lastStatesCount < maxPassCount) {
                    for(var i1 = lastStatesCount; i1 < maxPassCount; i1++){
                        renderStates.push(new RenderState());
                        this.setBlendMode(i1, BlendMode.Normal);
                    }
                } else {
                    renderStates.length = maxPassCount;
                }
            }
        },
        {
            key: "isTransparent",
            get: /**
   * Whethor transparent of first shader pass render state.
   */ function get() {
                return this._isTransparent;
            },
            set: function set(value) {
                if (value !== this._isTransparent) {
                    this.setIsTransparent(0, value);
                    this._isTransparent = value;
                }
            }
        },
        {
            key: "blendMode",
            get: /**
   * Blend mode of first shader pass render state.
   * @remarks Only take effect when `isTransparent` is `true`.
   */ function get() {
                return this._blendMode;
            },
            set: function set(value) {
                if (value !== this._blendMode) {
                    this.setBlendMode(0, value);
                    this._blendMode = value;
                }
            }
        },
        {
            key: "alphaCutoff",
            get: /**
   * Alpha cutoff value.
   * @remarks
   * Fragments with alpha channel lower than cutoff value will be discarded.
   * `0` means no fragment will be discarded.
   */ function get() {
                return this.shaderData.getFloat(BaseMaterial._alphaCutoffProp);
            },
            set: function set(value) {
                var shaderData = this.shaderData;
                if (shaderData.getFloat(BaseMaterial._alphaCutoffProp) !== value) {
                    if (value) {
                        shaderData.enableMacro(BaseMaterial._alphaCutoffMacro);
                    } else {
                        shaderData.disableMacro(BaseMaterial._alphaCutoffMacro);
                    }
                    var renderStates = this.renderStates;
                    for(var i = 0, n = renderStates.length; i < n; i++){
                        var renderState = renderStates[i];
                        if (value > 0) {
                            renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.AlphaTest;
                        } else {
                            renderState.renderQueueType = renderState.blendState.targetBlendState.enabled ? RenderQueueType.Transparent : RenderQueueType.Opaque;
                        }
                    }
                    shaderData.setFloat(BaseMaterial._alphaCutoffProp, value);
                }
            }
        },
        {
            key: "renderFace",
            get: /**
   * Face for render of first shader pass render state.
   */ function get() {
                return this._renderFace;
            },
            set: function set(value) {
                if (value !== this._renderFace) {
                    this.setRenderFace(0, value);
                    this._renderFace = value;
                }
            }
        }
    ]);
    return BaseMaterial;
}(Material);
(function() {
    BaseMaterial._baseTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_BASETEXTURE");
})();
(function() {
    BaseMaterial._normalTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_NORMALTEXTURE");
})();
(function() {
    BaseMaterial._emissiveTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_EMISSIVETEXTURE");
})();
(function() {
    BaseMaterial._transparentMacro = ShaderMacro.getByName("MATERIAL_IS_TRANSPARENT");
})();
(function() {
    BaseMaterial._baseColorProp = ShaderProperty.getByName("material_BaseColor");
})();
(function() {
    BaseMaterial._baseTextureProp = ShaderProperty.getByName("material_BaseTexture");
})();
(function() {
    BaseMaterial._tilingOffsetProp = ShaderProperty.getByName("material_TilingOffset");
})();
(function() {
    BaseMaterial._normalTextureProp = ShaderProperty.getByName("material_NormalTexture");
})();
(function() {
    BaseMaterial._normalIntensityProp = ShaderProperty.getByName("material_NormalIntensity");
})();
(function() {
    BaseMaterial._emissiveColorProp = ShaderProperty.getByName("material_EmissiveColor");
})();
(function() {
    BaseMaterial._emissiveTextureProp = ShaderProperty.getByName("material_EmissiveTexture");
})();
(function() {
    BaseMaterial._alphaCutoffProp = ShaderProperty.getByName("material_AlphaCutoff");
})();
(function() {
    BaseMaterial._alphaCutoffMacro = ShaderMacro.getByName("MATERIAL_IS_ALPHA_CUTOFF");
})();

/**
 * Blinn-phong Material.
 */ var BlinnPhongMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(BlinnPhongMaterial, BaseMaterial);
    function BlinnPhongMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("blinn-phong")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(BlinnPhongMaterial._baseColorProp, new Color$1(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial._specularColorProp, new Color$1(1, 1, 1, 1));
        shaderData.setColor(BlinnPhongMaterial._emissiveColorProp, new Color$1(0, 0, 0, 1));
        shaderData.setVector4(BlinnPhongMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        shaderData.setFloat(BlinnPhongMaterial._shininessProp, 16);
        shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, 1);
        return _this;
    }
    var _proto = BlinnPhongMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new BlinnPhongMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(BlinnPhongMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(BlinnPhongMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "specularColor",
            get: /**
   * Specular color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
            },
            set: function set(value) {
                var specularColor = this.shaderData.getColor(BlinnPhongMaterial._specularColorProp);
                if (value !== specularColor) {
                    specularColor.copyFrom(value);
                }
            }
        },
        {
            key: "specularTexture",
            get: /**
   * Specular texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._specularTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._specularTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_SPECULAR_TEXTURE");
                }
            }
        },
        {
            key: "emissiveColor",
            get: /**
   * Emissive color.
   */ function get() {
                return this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
            },
            set: function set(value) {
                var emissiveColor = this.shaderData.getColor(BlinnPhongMaterial._emissiveColorProp);
                if (value !== emissiveColor) {
                    emissiveColor.copyFrom(value);
                }
            }
        },
        {
            key: "emissiveTexture",
            get: /**
   * Emissive texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._emissiveTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._emissiveTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._emissiveTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._emissiveTextureMacro);
                }
            }
        },
        {
            key: "normalTexture",
            get: /**
   * Normal texture.
   */ function get() {
                return this.shaderData.getTexture(BlinnPhongMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(BlinnPhongMaterial._normalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(BlinnPhongMaterial._normalTextureMacro);
                } else {
                    this.shaderData.disableMacro(BlinnPhongMaterial._normalTextureMacro);
                }
            }
        },
        {
            key: "normalIntensity",
            get: /**
   * Normal texture intensity.
   */ function get() {
                return this.shaderData.getFloat(BlinnPhongMaterial._normalIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(BlinnPhongMaterial._normalIntensityProp, value);
            }
        },
        {
            key: "shininess",
            get: /**
   * Set the specular reflection coefficient, the larger the value, the more convergent the specular reflection effect.
   */ function get() {
                return this.shaderData.getFloat(BlinnPhongMaterial._shininessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(BlinnPhongMaterial._shininessProp, Math.max(value, 1e-4));
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(BlinnPhongMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        }
    ]);
    return BlinnPhongMaterial;
}(BaseMaterial);
(function() {
    BlinnPhongMaterial._specularColorProp = ShaderProperty.getByName("material_SpecularColor");
})();
(function() {
    BlinnPhongMaterial._shininessProp = ShaderProperty.getByName("material_Shininess");
})();
(function() {
    BlinnPhongMaterial._specularTextureProp = ShaderProperty.getByName("material_SpecularTexture");
})();

/**
 * Texture UV coordinate.
 */ var TextureCoordinate;
(function(TextureCoordinate) {
    TextureCoordinate[TextureCoordinate["UV0"] = 0] = "UV0";
    TextureCoordinate[TextureCoordinate["UV1"] = 1] = "UV1";
    TextureCoordinate[TextureCoordinate["UV2"] = 2] = "UV2";
    TextureCoordinate[TextureCoordinate["UV3"] = 3] = "UV3";
    TextureCoordinate[TextureCoordinate["UV4"] = 4] = "UV4";
    TextureCoordinate[TextureCoordinate["UV5"] = 5] = "UV5";
    TextureCoordinate[TextureCoordinate["UV6"] = 6] = "UV6";
    TextureCoordinate[TextureCoordinate["UV7"] = 7] = "UV7";
})(TextureCoordinate || (TextureCoordinate = {}));

/**
 * PBR (Physically-Based Rendering) Material.
 */ var PBRBaseMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(PBRBaseMaterial, BaseMaterial);
    function PBRBaseMaterial(engine, shader) {
        var _this;
        _this = BaseMaterial.call(this, engine, shader) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_NEED_WORLD_POS");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(PBRBaseMaterial._baseColorProp, new Color$1(1, 1, 1, 1));
        shaderData.setColor(PBRBaseMaterial._emissiveColorProp, new Color$1(0, 0, 0, 1));
        shaderData.setVector4(PBRBaseMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, 1);
        shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, TextureCoordinate.UV0);
        shaderData.setFloat(PBRBaseMaterial._clearCoatProp, 0);
        shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, 0);
        return _this;
    }
    _create_class$3(PBRBaseMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(PBRBaseMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "normalTexture",
            get: /**
   * Normal texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._normalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._normalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._normalTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._normalTextureMacro);
                }
            }
        },
        {
            key: "normalTextureIntensity",
            get: /**
   * Normal texture intensity.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._normalIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._normalIntensityProp, value);
            }
        },
        {
            key: "emissiveColor",
            get: /**
   * Emissive color.
   */ function get() {
                return this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
            },
            set: function set(value) {
                var emissiveColor = this.shaderData.getColor(PBRBaseMaterial._emissiveColorProp);
                if (value !== emissiveColor) {
                    emissiveColor.copyFrom(value);
                }
            }
        },
        {
            key: "emissiveTexture",
            get: /**
   * Emissive texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._emissiveTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._emissiveTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRBaseMaterial._emissiveTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRBaseMaterial._emissiveTextureMacro);
                }
            }
        },
        {
            key: "occlusionTexture",
            get: /**
   * Occlusion texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._occlusionTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._occlusionTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_OCCLUSION_TEXTURE");
                }
            }
        },
        {
            key: "occlusionTextureIntensity",
            get: /**
   * Occlusion texture intensity.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureIntensityProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureIntensityProp, value);
            }
        },
        {
            key: "occlusionTextureCoord",
            get: /**
   * Occlusion texture uv coordinate.
   * @remarks Must be UV0 or UV1.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._occlusionTextureCoordProp);
            },
            set: function set(value) {
                if (value > TextureCoordinate.UV1) {
                    Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                }
                this.shaderData.setFloat(PBRBaseMaterial._occlusionTextureCoordProp, value);
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(PBRBaseMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        },
        {
            key: "clearCoat",
            get: /**
   * The clearCoat layer intensity, default 0.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp);
            },
            set: function set(value) {
                if (!!this.shaderData.getFloat(PBRBaseMaterial._clearCoatProp) !== !!value) {
                    if (value === 0) {
                        this.shaderData.disableMacro("MATERIAL_ENABLE_CLEAR_COAT");
                    } else {
                        this.shaderData.enableMacro("MATERIAL_ENABLE_CLEAR_COAT");
                    }
                }
                this.shaderData.setFloat(PBRBaseMaterial._clearCoatProp, value);
            }
        },
        {
            key: "clearCoatTexture",
            get: /**
   * The clearCoat layer intensity texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_TEXTURE");
                }
            }
        },
        {
            key: "clearCoatRoughness",
            get: /**
   * The clearCoat layer roughness, default 0.
   */ function get() {
                return this.shaderData.getFloat(PBRBaseMaterial._clearCoatRoughnessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRBaseMaterial._clearCoatRoughnessProp, value);
            }
        },
        {
            key: "clearCoatRoughnessTexture",
            get: /**
   * The clearCoat layer roughness texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatRoughnessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_ROUGHNESS_TEXTURE");
                }
            }
        },
        {
            key: "clearCoatNormalTexture",
            get: /**
   * The clearCoat normal map texture.
   */ function get() {
                return this.shaderData.getTexture(PBRBaseMaterial._clearCoatNormalTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRBaseMaterial._clearCoatNormalTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_CLEAR_COAT_NORMAL_TEXTURE");
                }
            }
        }
    ]);
    return PBRBaseMaterial;
}(BaseMaterial);
(function() {
    PBRBaseMaterial._occlusionTextureIntensityProp = ShaderProperty.getByName("material_OcclusionIntensity");
})();
(function() {
    PBRBaseMaterial._occlusionTextureCoordProp = ShaderProperty.getByName("material_OcclusionTextureCoord");
})();
(function() {
    PBRBaseMaterial._occlusionTextureProp = ShaderProperty.getByName("material_OcclusionTexture");
})();
(function() {
    PBRBaseMaterial._clearCoatProp = ShaderProperty.getByName("material_ClearCoat");
})();
(function() {
    PBRBaseMaterial._clearCoatTextureProp = ShaderProperty.getByName("material_ClearCoatTexture");
})();
(function() {
    PBRBaseMaterial._clearCoatRoughnessProp = ShaderProperty.getByName("material_ClearCoatRoughness");
})();
(function() {
    PBRBaseMaterial._clearCoatRoughnessTextureProp = ShaderProperty.getByName("material_ClearCoatRoughnessTexture");
})();
(function() {
    PBRBaseMaterial._clearCoatNormalTextureProp = ShaderProperty.getByName("material_ClearCoatNormalTexture");
})();

/**
 * PBR (Metallic-Roughness Workflow) Material.
 */ var PBRMaterial = /*#__PURE__*/ function(PBRBaseMaterial) {
    _inherits$2(PBRMaterial, PBRBaseMaterial);
    function PBRMaterial(engine) {
        var _this;
        _this = PBRBaseMaterial.call(this, engine, Shader.find("pbr")) || this;
        _this.shaderData.setFloat(PBRMaterial._metallicProp, 1);
        _this.shaderData.setFloat(PBRMaterial._roughnessProp, 1);
        _this.shaderData.setFloat(PBRMaterial._iorProp, 1.5);
        return _this;
    }
    var _proto = PBRMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new PBRMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(PBRMaterial, [
        {
            key: "ior",
            get: /**
   * Index Of Refraction.
   * @defaultValue `1.5`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._iorProp);
            },
            set: function set(v) {
                this.shaderData.setFloat(PBRMaterial._iorProp, Math.max(v, 0));
            }
        },
        {
            key: "metallic",
            get: /**
   * Metallic.
   * @defaultValue `1.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._metallicProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRMaterial._metallicProp, value);
            }
        },
        {
            key: "roughness",
            get: /**
   * Roughness. default 1.0.
   * @defaultValue `1.0`
   */ function get() {
                return this.shaderData.getFloat(PBRMaterial._roughnessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRMaterial._roughnessProp, value);
            }
        },
        {
            key: "roughnessMetallicTexture",
            get: /**
   * Roughness metallic texture.
   * @remarks G channel is roughness, B channel is metallic
   */ function get() {
                return this.shaderData.getTexture(PBRMaterial._roughnessMetallicTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRMaterial._roughnessMetallicTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
                } else {
                    this.shaderData.disableMacro("MATERIAL_HAS_ROUGHNESS_METALLIC_TEXTURE");
                }
            }
        }
    ]);
    return PBRMaterial;
}(PBRBaseMaterial);
(function() {
    PBRMaterial._metallicProp = ShaderProperty.getByName("material_Metal");
})();
(function() {
    PBRMaterial._roughnessProp = ShaderProperty.getByName("material_Roughness");
})();
(function() {
    PBRMaterial._roughnessMetallicTextureProp = ShaderProperty.getByName("material_RoughnessMetallicTexture");
})();
(function() {
    PBRMaterial._iorProp = Shader.getPropertyByName("material_IOR");
})();

/**
 * PBR (Specular-Glossiness Workflow) Material.
 */ var PBRSpecularMaterial = /*#__PURE__*/ function(PBRBaseMaterial) {
    _inherits$2(PBRSpecularMaterial, PBRBaseMaterial);
    function PBRSpecularMaterial(engine) {
        var _this;
        _this = PBRBaseMaterial.call(this, engine, Shader.find("pbr-specular")) || this;
        _this.shaderData.setColor(PBRSpecularMaterial._specularColorProp, new Color$1(1, 1, 1, 1));
        _this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, 1.0);
        return _this;
    }
    var _proto = PBRSpecularMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new PBRSpecularMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(PBRSpecularMaterial, [
        {
            key: "specularColor",
            get: /**
   * Specular color.
   */ function get() {
                return this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
            },
            set: function set(value) {
                var specularColor = this.shaderData.getColor(PBRSpecularMaterial._specularColorProp);
                if (value !== specularColor) {
                    specularColor.copyFrom(value);
                }
            }
        },
        {
            key: "glossiness",
            get: /**
   * Glossiness.
   */ function get() {
                return this.shaderData.getFloat(PBRSpecularMaterial._glossinessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(PBRSpecularMaterial._glossinessProp, value);
            }
        },
        {
            key: "specularGlossinessTexture",
            get: /**
   * Specular glossiness texture.
   * @remarks RGB is specular, A is glossiness
   */ function get() {
                return this.shaderData.getTexture(PBRSpecularMaterial._specularGlossinessTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(PBRSpecularMaterial._specularGlossinessTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
                } else {
                    this.shaderData.disableMacro(PBRSpecularMaterial._specularGlossinessTextureMacro);
                }
            }
        }
    ]);
    return PBRSpecularMaterial;
}(PBRBaseMaterial);
(function() {
    PBRSpecularMaterial._specularColorProp = ShaderProperty.getByName("material_PBRSpecularColor");
})();
(function() {
    PBRSpecularMaterial._glossinessProp = ShaderProperty.getByName("material_Glossiness");
})();
(function() {
    PBRSpecularMaterial._specularGlossinessTextureProp = ShaderProperty.getByName("material_SpecularGlossinessTexture");
})();
(function() {
    PBRSpecularMaterial._specularGlossinessTextureMacro = ShaderMacro.getByName("MATERIAL_HAS_SPECULAR_GLOSSINESS_TEXTURE");
})();

/**
 * Unlit Material.
 */ var UnlitMaterial = /*#__PURE__*/ function(BaseMaterial) {
    _inherits$2(UnlitMaterial, BaseMaterial);
    function UnlitMaterial(engine) {
        var _this;
        _this = BaseMaterial.call(this, engine, Shader.find("unlit")) || this;
        var shaderData = _this.shaderData;
        shaderData.enableMacro("MATERIAL_OMIT_NORMAL");
        shaderData.enableMacro("MATERIAL_NEED_TILING_OFFSET");
        shaderData.setColor(UnlitMaterial._baseColorProp, new Color$1(1, 1, 1, 1));
        shaderData.setVector4(UnlitMaterial._tilingOffsetProp, new Vector4(1, 1, 0, 0));
        return _this;
    }
    var _proto = UnlitMaterial.prototype;
    /**
   * @inheritdoc
   */ _proto.clone = function clone() {
        var dest = new UnlitMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(UnlitMaterial, [
        {
            key: "baseColor",
            get: /**
   * Base color.
   */ function get() {
                return this.shaderData.getColor(UnlitMaterial._baseColorProp);
            },
            set: function set(value) {
                var baseColor = this.shaderData.getColor(UnlitMaterial._baseColorProp);
                if (value !== baseColor) {
                    baseColor.copyFrom(value);
                }
            }
        },
        {
            key: "baseTexture",
            get: /**
   * Base texture.
   */ function get() {
                return this.shaderData.getTexture(UnlitMaterial._baseTextureProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(UnlitMaterial._baseTextureProp, value);
                if (value) {
                    this.shaderData.enableMacro(UnlitMaterial._baseTextureMacro);
                } else {
                    this.shaderData.disableMacro(UnlitMaterial._baseTextureMacro);
                }
            }
        },
        {
            key: "tilingOffset",
            get: /**
   * Tiling and offset of main textures.
   */ function get() {
                return this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
            },
            set: function set(value) {
                var tilingOffset = this.shaderData.getVector4(UnlitMaterial._tilingOffsetProp);
                if (value !== tilingOffset) {
                    tilingOffset.copyFrom(value);
                }
            }
        }
    ]);
    return UnlitMaterial;
}(BaseMaterial);

/**
 * The horizontal alignment of the text.
 */ exports.TextHorizontalAlignment = void 0;
(function(TextHorizontalAlignment) {
    TextHorizontalAlignment[TextHorizontalAlignment[/** Align left horizontally */ "Left"] = 0] = "Left";
    TextHorizontalAlignment[TextHorizontalAlignment[/** Align center horizontally */ "Center"] = 1] = "Center";
    TextHorizontalAlignment[TextHorizontalAlignment[/** Align right horizontally */ "Right"] = 2] = "Right";
})(exports.TextHorizontalAlignment || (exports.TextHorizontalAlignment = {}));
var TextVerticalAlignment;
(function(TextVerticalAlignment) {
    TextVerticalAlignment[TextVerticalAlignment[/** Align top vertically */ "Top"] = 0] = "Top";
    TextVerticalAlignment[TextVerticalAlignment[/** Align center vertically */ "Center"] = 1] = "Center";
    TextVerticalAlignment[TextVerticalAlignment[/** Align bottom vertically */ "Bottom"] = 2] = "Bottom";
})(TextVerticalAlignment || (TextVerticalAlignment = {}));

/**
 * Sprite Atlas.
 */ var SpriteAtlas = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(SpriteAtlas, ReferResource);
    function SpriteAtlas(engine) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this._sprites = new Array();
        _this._spriteNamesToIndex = {};
        return _this;
    }
    var _proto = SpriteAtlas.prototype;
    /**
   * Get the last sprite named 'name' from the atlas.
   * @param name - The name of the sprite you want to find
   * @returns The sprite you want to find
   */ _proto.getSprite = function getSprite(name) {
        var sprite = this._sprites[this._spriteNamesToIndex[name]];
        if (!sprite) {
            console.warn("There is no sprite named " + name + " in the atlas.");
        }
        return sprite;
    };
    /**
   * Get all the sprite named 'name' from the atlas.
   * @param name - The name of the sprites you want to find
   * @param outSprites - This array holds the sprites found
   * @returns The sprites you want to find
   */ _proto.getSprites = function getSprites(name, outSprites) {
        outSprites.length = 0;
        var i = this._spriteNamesToIndex[name];
        if (i !== undefined) {
            var _sprites = this._sprites;
            for(; i >= 0; i--){
                var sprite = _sprites[i];
                sprite.name === name && outSprites.push(sprite);
            }
        } else {
            console.warn("The name of the sprite you want to find is not exit in SpriteAtlas.");
        }
        return outSprites;
    };
    /**
   * @internal
   */ _proto._addSprite = function _addSprite(sprite) {
        this._spriteNamesToIndex[sprite.name] = this._sprites.push(sprite) - 1;
        sprite._atlas = this;
        sprite.isGCIgnored = true;
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        var _this = this, sprites = _this._sprites;
        for(var i = 0, n = sprites.length; i < n; i++){
            sprites[i].destroy();
        }
        sprites.length = 0;
        this._sprites = null;
        this._spriteNamesToIndex = null;
    };
    _create_class$3(SpriteAtlas, [
        {
            key: "sprites",
            get: /**
   * All the sprites in the atlas.
   */ function get() {
                return this._sprites;
            }
        }
    ]);
    return SpriteAtlas;
}(ReferResource);

/**
 * Sprite's drawing mode enumeration.
 */ var SpriteDrawMode;
(function(SpriteDrawMode) {
    SpriteDrawMode[SpriteDrawMode[/** Overall scaling when modifying size. */ "Simple"] = 0] = "Simple";
    SpriteDrawMode[SpriteDrawMode[/** When modifying the size of the renderer, it scales to fill the range according to the sprite border settings. */ "Sliced"] = 1] = "Sliced";
    SpriteDrawMode[SpriteDrawMode[/** When modifying the size of the renderer, it will tile to fill the range according to the sprite border settings. */ "Tiled"] = 2] = "Tiled";
})(SpriteDrawMode || (SpriteDrawMode = {}));

/**
 * Sprite's tiling mode enumeration.
 * Only works in `SpriteDrawMode.tiled` mode.
 */ var SpriteTileMode;
(function(SpriteTileMode) {
    SpriteTileMode[SpriteTileMode[/** SpriteRenderer will tile continuously. */ "Continuous"] = 0] = "Continuous";
    SpriteTileMode[SpriteTileMode[/** When the fractional part of the tiling multiple is greater than or equal to `SpriteRenderer.tileStretchValue`,
   * a tile will be addedï¼Œand the number of tiles can only be an integer. */ "Adaptive"] = 1] = "Adaptive";
})(SpriteTileMode || (SpriteTileMode = {}));

/**
 * 2D sprite.
 */ var Sprite = /*#__PURE__*/ function(ReferResource) {
    _inherits$2(Sprite, ReferResource);
    function Sprite(engine, texture, region, pivot, border, name) {
        if (texture === void 0) texture = null;
        if (region === void 0) region = null;
        if (pivot === void 0) pivot = null;
        if (border === void 0) border = null;
        if (name === void 0) name = null;
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this._automaticWidth = 0;
        _this._automaticHeight = 0;
        _this._customWidth = undefined;
        _this._customHeight = undefined;
        _this._positions = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ];
        _this._uvs = [
            new Vector2(),
            new Vector2(),
            new Vector2(),
            new Vector2()
        ];
        _this._bounds = new BoundingBox();
        _this._texture = null;
        _this._atlasRotated = false;
        _this._atlasRegion = new Rect(0, 0, 1, 1);
        _this._atlasRegionOffset = new Vector4(0, 0, 0, 0);
        _this._region = new Rect(0, 0, 1, 1);
        _this._pivot = new Vector2(0.5, 0.5);
        _this._border = new Vector4(0, 0, 0, 0);
        _this._dirtyUpdateFlag = 0x7;
        /** @internal */ _this._updateFlagManager = new UpdateFlagManager();
        _this._texture = texture;
        region && _this._region.copyFrom(region);
        pivot && _this._pivot.copyFrom(pivot);
        border && _this._border.copyFrom(border);
        _this.name = name;
        return _this;
    }
    var _proto = Sprite.prototype;
    /**
   * Clone.
   * @returns Cloned sprite
   */ _proto.clone = function clone() {
        var cloneSprite = new Sprite(this._engine, this._texture, this._region, this._pivot, this._border, this.name);
        cloneSprite._atlasRotated = this._atlasRotated;
        cloneSprite._atlasRegion.copyFrom(this._atlasRegion);
        cloneSprite._atlasRegionOffset.copyFrom(this._atlasRegionOffset);
        return cloneSprite;
    };
    /**
   * @internal
   */ _proto._getPositions = function _getPositions() {
        this._dirtyUpdateFlag & 0x1 && this._updatePositions();
        return this._positions;
    };
    /**
   * @internal
   */ _proto._getUVs = function _getUVs() {
        this._dirtyUpdateFlag & 0x2 && this._updateUVs();
        return this._uvs;
    };
    /**
   * @internal
   */ _proto._getBounds = function _getBounds() {
        this._dirtyUpdateFlag & 0x1 && this._updatePositions();
        return this._bounds;
    };
    /**
   * @internal
   */ _proto._addReferCount = function _addReferCount(value) {
        var _this__atlas;
        ReferResource.prototype._addReferCount.call(this, value);
        (_this__atlas = this._atlas) == null ? void 0 : _this__atlas._addReferCount(value);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        ReferResource.prototype._onDestroy.call(this);
        this._positions.length = 0;
        this._positions = null;
        this._uvs.length = 0;
        this._uvs = null;
        this._atlasRegion = null;
        this._atlasRegionOffset = null;
        this._region = null;
        this._pivot = null;
        this._border = null;
        this._bounds = null;
        this._atlas = null;
        this._texture = null;
        this._updateFlagManager = null;
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        if (this._texture) {
            var _this = this, _texture = _this._texture, _atlasRegion = _this._atlasRegion, _atlasRegionOffset = _this._atlasRegionOffset, _region = _this._region;
            var pixelsPerUnitReciprocal = 1.0 / Engine._pixelsPerUnit;
            this._automaticWidth = _texture.width * _atlasRegion.width / (1 - _atlasRegionOffset.x - _atlasRegionOffset.z) * _region.width * pixelsPerUnitReciprocal;
            this._automaticHeight = _texture.height * _atlasRegion.height / (1 - _atlasRegionOffset.y - _atlasRegionOffset.w) * _region.height * pixelsPerUnitReciprocal;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= ~0x4;
    };
    _proto._updatePositions = function _updatePositions() {
        var blank = this._atlasRegionOffset;
        var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var left = Math.max(blank.x - regionX, 0) / regionW;
        var bottom = Math.max(blank.w - regionY, 0) / regionH;
        var right = 1 - Math.max(blank.z - regionRight, 0) / regionW;
        var top = 1 - Math.max(blank.y - regionBottom, 0) / regionH;
        // Update positions.
        // ---------------
        //  2 - 3
        //  |   |
        //  0 - 1
        // ---------------
        var positions = this._positions;
        positions[0].set(left, bottom);
        positions[1].set(right, bottom);
        positions[2].set(left, top);
        positions[3].set(right, top);
        var _this__bounds = this._bounds, min = _this__bounds.min, max = _this__bounds.max;
        min.set(left, bottom, 0);
        max.set(right, top, 0);
        this._dirtyUpdateFlag &= ~0x1;
    };
    _proto._updateUVs = function _updateUVs() {
        var _this = this, uv = _this._uvs, atlasRegionOffset = _this._atlasRegionOffset;
        var _this__region = this._region, regionX = _this__region.x, regionY = _this__region.y, regionW = _this__region.width, regionH = _this__region.height;
        var regionRight = 1 - regionX - regionW;
        var regionBottom = 1 - regionY - regionH;
        var _this__atlasRegion = this._atlasRegion, atlasRegionX = _this__atlasRegion.x, atlasRegionY = _this__atlasRegion.y, atlasRegionW = _this__atlasRegion.width, atlasRegionH = _this__atlasRegion.height;
        var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
        var realWidth = atlasRegionW / (1 - offsetLeft - offsetRight);
        var realHeight = atlasRegionH / (1 - offsetTop - offsetBottom);
        // Coordinates of the four boundaries.
        var left = Math.max(regionX - offsetLeft, 0) * realWidth + atlasRegionX;
        var top = Math.max(regionBottom - offsetTop, 0) * realHeight + atlasRegionY;
        var right = atlasRegionW + atlasRegionX - Math.max(regionRight - offsetRight, 0) * realWidth;
        var bottom = atlasRegionH + atlasRegionY - Math.max(regionY - offsetBottom, 0) * realHeight;
        var _this__border = this._border, borderLeft = _this__border.x, borderBottom = _this__border.y, borderRight = _this__border.z, borderTop = _this__border.w;
        // Left-Bottom
        uv[0].set(left, bottom);
        // Border ( Left-Bottom )
        uv[1].set((regionX - offsetLeft + borderLeft * regionW) * realWidth + atlasRegionX, atlasRegionH + atlasRegionY - (regionY - offsetBottom + borderBottom * regionH) * realHeight);
        // Border ( Right-Top )
        uv[2].set(atlasRegionW + atlasRegionX - (regionRight - offsetRight + borderRight * regionW) * realWidth, (regionBottom - offsetTop + borderTop * regionH) * realHeight + atlasRegionY);
        // Right-Top
        uv[3].set(right, top);
        this._dirtyUpdateFlag &= ~0x2;
    };
    _proto._dispatchSpriteChange = function _dispatchSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this._dirtyUpdateFlag |= 0x4;
                break;
            case SpriteModifyFlags.atlasRegionOffset:
            case SpriteModifyFlags.region:
                this._dirtyUpdateFlag |= 0x7;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 0x4 | 0x2;
                break;
            case SpriteModifyFlags.border:
                this._dirtyUpdateFlag |= 0x2;
                break;
        }
        this._updateFlagManager.dispatch(type);
    };
    _create_class$3(Sprite, [
        {
            key: "texture",
            get: /**
   * The reference to the used texture.
   */ function get() {
                return this._texture;
            },
            set: function set(value) {
                if (this._texture !== value) {
                    this._texture = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.texture);
                    if (this._customWidth === undefined || this._customHeight === undefined) {
                        this._dispatchSpriteChange(SpriteModifyFlags.size);
                    }
                }
            }
        },
        {
            key: "width",
            get: /**
   * The width of the sprite (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return the width calculated according to `Texture.width`, `Sprite.region`, `Sprite.atlasRegion`, `Sprite.atlasRegionOffset` and `Engine._pixelsPerUnit`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "height",
            get: /**
   * The height of the sprite (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return the height calculated according to `Texture.height`, `Sprite.region`, `Sprite.atlasRegion`, `Sprite.atlasRegionOffset` and `Engine._pixelsPerUnit`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "atlasRotated",
            get: /**
   * Is it rotated 90 degrees clockwise when packing.
   */ function get() {
                return this._atlasRotated;
            },
            set: function set(value) {
                if (this._atlasRotated != value) {
                    this._atlasRotated = value;
                }
            }
        },
        {
            key: "atlasRegion",
            get: /**
   * The rectangle region of the original texture on its atlas texture, specified in normalized.
   */ function get() {
                return this._atlasRegion;
            },
            set: function set(value) {
                var x = MathUtil$1.clamp(value.x, 0, 1);
                var y = MathUtil$1.clamp(value.y, 0, 1);
                this._atlasRegion.set(x, y, MathUtil$1.clamp(value.width, 0, 1 - x), MathUtil$1.clamp(value.height, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.atlasRegion);
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "atlasRegionOffset",
            get: /**
   * The rectangle region offset of the original texture on its atlas texture, specified in normalized.
   */ function get() {
                return this._atlasRegionOffset;
            },
            set: function set(value) {
                var x = MathUtil$1.clamp(value.x, 0, 1);
                var y = MathUtil$1.clamp(value.y, 0, 1);
                this._atlasRegionOffset.set(x, y, MathUtil$1.clamp(value.z, 0, 1 - x), MathUtil$1.clamp(value.w, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.atlasRegionOffset);
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "region",
            get: /**
   * The rectangle region of the sprite, specified in normalized.
   */ function get() {
                return this._region;
            },
            set: function set(value) {
                var region = this._region;
                var x = MathUtil$1.clamp(value.x, 0, 1);
                var y = MathUtil$1.clamp(value.y, 0, 1);
                region.set(x, y, MathUtil$1.clamp(value.width, 0, 1 - x), MathUtil$1.clamp(value.height, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.region);
                if (this._customWidth === undefined || this._customHeight === undefined) {
                    this._dispatchSpriteChange(SpriteModifyFlags.size);
                }
            }
        },
        {
            key: "pivot",
            get: /**
   * Location of the sprite's center point in the rectangle region, specified in normalized.
   * The origin is at the bottom left and the default value is (0.5, 0.5).
   */ function get() {
                return this._pivot;
            },
            set: function set(value) {
                var pivot = this._pivot;
                if (pivot === value) {
                    this._dispatchSpriteChange(SpriteModifyFlags.pivot);
                } else {
                    var x = value.x, y = value.y;
                    if (pivot.x !== x || pivot.y !== y) {
                        pivot.set(x, y);
                        this._dispatchSpriteChange(SpriteModifyFlags.pivot);
                    }
                }
            }
        },
        {
            key: "border",
            get: /**
   * Get the border of the sprite.
   *  x      y       z     w
   *  |      |       |     |
   * Left, bottom, right, top.
   * @remarks only use in sliced mode.
   */ function get() {
                return this._border;
            },
            set: function set(value) {
                var border = this._border;
                var x = MathUtil$1.clamp(value.x, 0, 1);
                var y = MathUtil$1.clamp(value.y, 0, 1);
                border.set(x, y, MathUtil$1.clamp(value.z, 0, 1 - x), MathUtil$1.clamp(value.w, 0, 1 - y));
                this._dispatchSpriteChange(SpriteModifyFlags.border);
            }
        }
    ]);
    return Sprite;
}(ReferResource);
var SpriteUpdateFlags;
(function(SpriteUpdateFlags) {
    SpriteUpdateFlags[SpriteUpdateFlags["positions"] = 0x1] = "positions";
    SpriteUpdateFlags[SpriteUpdateFlags["uvs"] = 0x2] = "uvs";
    SpriteUpdateFlags[SpriteUpdateFlags["automaticSize"] = 0x4] = "automaticSize";
    SpriteUpdateFlags[SpriteUpdateFlags["all"] = 0x7] = "all";
})(SpriteUpdateFlags || (SpriteUpdateFlags = {}));

var _SlicedSpriteAssembler;
var SlicedSpriteAssembler = (_SlicedSpriteAssembler = /*#__PURE__*/ function() {
    function SlicedSpriteAssembler1() {}
    SlicedSpriteAssembler1.resetData = function resetData(renderer) {
        var verticesData = renderer._verticesData;
        var positions = verticesData.positions, uvs = verticesData.uvs;
        if (positions.length < 16) {
            for(var i = positions.length; i < 16; i++){
                positions.push(new Vector3());
                uvs.push(new Vector2());
            }
        }
        verticesData.triangles = [];
    };
    SlicedSpriteAssembler1.updatePositions = function updatePositions(renderer) {
        var width = renderer.width, height = renderer.height, sprite = renderer.sprite;
        var _renderer__verticesData = renderer._verticesData, positions = _renderer__verticesData.positions, uvs = _renderer__verticesData.uvs, triangles = _renderer__verticesData.triangles;
        var border = sprite.border;
        var spriteUVs = sprite._getUVs();
        // Update local positions.
        var spritePositions = sprite._getPositions();
        var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
        var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
        var expectWidth = sprite.width, expectHeight = sprite.height;
        var fixedLeft = expectWidth * border.x;
        var fixedBottom = expectHeight * border.y;
        var fixedRight = expectWidth * border.z;
        var fixedTop = expectHeight * border.w;
        // ------------------------
        //     [3]
        //      |
        //     [2]
        //      |
        //     [1]
        //      |
        // row [0] - [1] - [2] - [3]
        //    column
        // ------------------------
        // Calculate row and column.
        var row, column;
        if (fixedLeft + fixedRight > width) {
            var widthScale = width / (fixedLeft + fixedRight);
            row = [
                expectWidth * left * widthScale,
                fixedLeft * widthScale,
                fixedLeft * widthScale,
                width - expectWidth * (1 - right) * widthScale
            ];
        } else {
            row = [
                expectWidth * left,
                fixedLeft,
                width - fixedRight,
                width - expectWidth * (1 - right)
            ];
        }
        if (fixedTop + fixedBottom > height) {
            var heightScale = height / (fixedTop + fixedBottom);
            column = [
                expectHeight * bottom * heightScale,
                fixedBottom * heightScale,
                fixedBottom * heightScale,
                height - expectHeight * (1 - top) * heightScale
            ];
        } else {
            column = [
                expectHeight * bottom,
                fixedBottom,
                height - fixedTop,
                height - expectHeight * (1 - top)
            ];
        }
        // Update renderer's worldMatrix.
        var _renderer_sprite_pivot = renderer.sprite.pivot, pivotX = _renderer_sprite_pivot.x, pivotY = _renderer_sprite_pivot.y;
        var localTransX = renderer.width * pivotX;
        var localTransY = renderer.height * pivotY;
        // Renderer's worldMatrix.
        var worldMatrix = SlicedSpriteAssembler._worldMatrix;
        var wE = worldMatrix.elements;
        // Parent's worldMatrix.
        var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
        var sx = renderer.flipX ? -1 : 1;
        var sy = renderer.flipY ? -1 : 1;
        wE[0] = pWE[0] * sx, wE[1] = pWE[1] * sx, wE[2] = pWE[2] * sx;
        wE[4] = pWE[4] * sy, wE[5] = pWE[5] * sy, wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
        wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
        wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
        // ------------------------
        //  3 - 7 - 11 - 15
        //  |   |   |    |
        //  2 - 6 - 10 - 14
        //  |   |   |    |
        //  1 - 5 - 9  - 13
        //  |   |   |    |
        //  0 - 4 - 8  - 12
        // ------------------------
        // Assemble position and uv.
        var vertexCount = 0;
        var realICount = 0;
        for(var i = 0; i < 4; i++){
            var rowValue = row[i];
            var rowU = spriteUVs[i].x;
            for(var j = 0; j < 4; j++){
                var columnValue = column[j];
                positions[vertexCount].set(wE[0] * rowValue + wE[4] * columnValue + wE[12], wE[1] * rowValue + wE[5] * columnValue + wE[13], wE[2] * rowValue + wE[6] * columnValue + wE[14]);
                uvs[vertexCount].set(rowU, spriteUVs[j].y);
                ++vertexCount;
            }
            ++realICount;
        }
        var realJCount = vertexCount / realICount;
        var indexOffset = 0;
        for(var i1 = 0; i1 < realICount - 1; ++i1){
            for(var j1 = 0; j1 < realJCount - 1; ++j1){
                var start = i1 * realJCount + j1;
                triangles[indexOffset++] = start;
                triangles[indexOffset++] = start + 1;
                triangles[indexOffset++] = start + realJCount;
                triangles[indexOffset++] = start + 1;
                triangles[indexOffset++] = start + realJCount + 1;
                triangles[indexOffset++] = start + realJCount;
            }
        }
        renderer._verticesData.vertexCount = realICount * realJCount;
        triangles.length = (realICount - 1) * (realJCount - 1) * 6;
        var _renderer__bounds = renderer._bounds, min = _renderer__bounds.min, max = _renderer__bounds.max;
        min.set(row[0], column[0], 0);
        max.set(row[3], column[3], 0);
        renderer._bounds.transform(worldMatrix);
    };
    SlicedSpriteAssembler1.updateUVs = function updateUVs(renderer) {};
    return SlicedSpriteAssembler1;
}(), function() {
    _SlicedSpriteAssembler._worldMatrix = new Matrix();
}(), _SlicedSpriteAssembler);
SlicedSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], SlicedSpriteAssembler);

var _TiledSpriteAssembler;
var TiledSpriteAssembler = (_TiledSpriteAssembler = /*#__PURE__*/ function() {
    function TiledSpriteAssembler1() {}
    TiledSpriteAssembler1.resetData = function resetData(renderer) {
        var _renderer__verticesData;
        (_renderer__verticesData = renderer._verticesData).triangles || (_renderer__verticesData.triangles = []);
    };
    TiledSpriteAssembler1.updatePositions = function updatePositions(renderer) {
        var width = renderer.width, height = renderer.height, sprite = renderer.sprite, tileMode = renderer.tileMode, threshold = renderer.tiledAdaptiveThreshold;
        var _renderer__verticesData = renderer._verticesData, positions = _renderer__verticesData.positions, uvs = _renderer__verticesData.uvs, triangles = _renderer__verticesData.triangles;
        // Calculate row and column
        var _this = this, posRow = _this._posRow, posColumn = _this._posColumn, uvRow = _this._uvRow, uvColumn = _this._uvColumn;
        posRow.length = posColumn.length = uvRow.length = uvColumn.length = 0;
        tileMode === SpriteTileMode.Adaptive ? this._calculateAdaptiveDividing(sprite, width, height, threshold, posRow, posColumn, uvRow, uvColumn) : this._calculateContinuousDividing(sprite, width, height, posRow, posColumn, uvRow, uvColumn);
        // Update renderer's worldMatrix
        var _renderer_sprite_pivot = renderer.sprite.pivot, pivotX = _renderer_sprite_pivot.x, pivotY = _renderer_sprite_pivot.y;
        var localTransX = renderer.width * pivotX;
        var localTransY = renderer.height * pivotY;
        // Renderer's worldMatrix
        var worldMatrix = TiledSpriteAssembler._worldMatrix;
        var wE = worldMatrix.elements;
        // Parent's worldMatrix
        var _renderer_entity_transform_worldMatrix = renderer.entity.transform.worldMatrix, pWE = _renderer_entity_transform_worldMatrix.elements;
        var sx = renderer.flipX ? -1 : 1;
        var sy = renderer.flipY ? -1 : 1;
        var wE0, wE1, wE2;
        var wE4, wE5, wE6;
        wE0 = wE[0] = pWE[0] * sx, wE1 = wE[1] = pWE[1] * sx, wE2 = wE[2] = pWE[2] * sx;
        wE4 = wE[4] = pWE[4] * sy, wE5 = wE[5] = pWE[5] * sy, wE6 = wE[6] = pWE[6] * sy;
        wE[8] = pWE[8], wE[9] = pWE[9], wE[10] = pWE[10];
        var wE12 = wE[12] = pWE[12] - localTransX * wE[0] - localTransY * wE[4];
        var wE13 = wE[13] = pWE[13] - localTransX * wE[1] - localTransY * wE[5];
        var wE14 = wE[14] = pWE[14] - localTransX * wE[2] - localTransY * wE[6];
        // Assemble position and uv
        var rowLength = posRow.length - 1;
        var columnLength = posColumn.length - 1;
        var count = 0;
        var trianglesOffset = 0;
        for(var j = 0; j < columnLength; j++){
            var doubleJ = 2 * j;
            for(var i = 0; i < rowLength; i++){
                var uvL = uvRow.get(2 * i);
                var uvB = uvColumn.get(doubleJ);
                var uvR = uvRow.get(2 * i + 1);
                var uvT = uvColumn.get(doubleJ + 1);
                if (isNaN(uvL) || isNaN(uvL) || isNaN(uvR) || isNaN(uvT)) {
                    continue;
                }
                triangles[trianglesOffset++] = count;
                triangles[trianglesOffset++] = count + 1;
                triangles[trianglesOffset++] = count + 2;
                triangles[trianglesOffset++] = count + 2;
                triangles[trianglesOffset++] = count + 1;
                triangles[trianglesOffset++] = count + 3;
                var l = posRow.get(i);
                var b = posColumn.get(j);
                var r = posRow.get(i + 1);
                var t = posColumn.get(j + 1);
                // left and bottom
                uvs[count] ? uvs[count].set(uvL, uvB) : uvs[count] = new Vector2(uvL, uvB);
                var pos = positions[count];
                if (pos) {
                    pos.set(wE0 * l + wE4 * b + wE12, wE1 * l + wE5 * b + wE13, wE2 * l + wE6 * b + wE14);
                } else {
                    positions[count] = new Vector3(wE0 * l + wE4 * b + wE12, wE1 * l + wE5 * b + wE13, wE2 * l + wE6 * b + wE14);
                }
                count++;
                // right and bottom
                uvs[count] ? uvs[count].set(uvR, uvB) : uvs[count] = new Vector2(uvR, uvB);
                pos = positions[count];
                if (pos) {
                    pos.set(wE0 * r + wE4 * b + wE12, wE1 * r + wE5 * b + wE13, wE2 * r + wE6 * b + wE14);
                } else {
                    positions[count] = new Vector3(wE0 * r + wE4 * b + wE12, wE1 * r + wE5 * b + wE13, wE2 * r + wE6 * b + wE14);
                }
                count++;
                // left and top
                uvs[count] ? uvs[count].set(uvL, uvT) : uvs[count] = new Vector2(uvL, uvT);
                pos = positions[count];
                if (pos) {
                    pos.set(wE0 * l + wE4 * t + wE12, wE1 * l + wE5 * t + wE13, wE2 * l + wE6 * t + wE14);
                } else {
                    positions[count] = new Vector3(wE0 * l + wE4 * t + wE12, wE1 * l + wE5 * t + wE13, wE2 * l + wE6 * t + wE14);
                }
                count++;
                // right and top
                uvs[count] ? uvs[count].set(uvR, uvT) : uvs[count] = new Vector2(uvR, uvT);
                pos = positions[count];
                if (pos) {
                    pos.set(wE0 * r + wE4 * t + wE12, wE1 * r + wE5 * t + wE13, wE2 * r + wE6 * t + wE14);
                } else {
                    positions[count] = new Vector3(wE0 * r + wE4 * t + wE12, wE1 * r + wE5 * t + wE13, wE2 * r + wE6 * t + wE14);
                }
                count++;
            }
        }
        renderer._verticesData.vertexCount = count;
        triangles.length = trianglesOffset;
        var _renderer__bounds = renderer._bounds, min = _renderer__bounds.min, max = _renderer__bounds.max;
        min.set(posRow.get(0), posColumn.get(0), 0);
        max.set(posRow.get(rowLength), posColumn.get(columnLength), 0);
        renderer._bounds.transform(worldMatrix);
    };
    TiledSpriteAssembler1.updateUVs = function updateUVs(renderer) {};
    TiledSpriteAssembler1._calculateAdaptiveDividing = function _calculateAdaptiveDividing(sprite, width, height, threshold, posRow, posColumn, uvRow, uvColumn) {
        var border = sprite.border;
        var spritePositions = sprite._getPositions();
        var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
        var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
        var _sprite__getUVs = sprite._getUVs(), spriteUV0 = _sprite__getUVs[0], spriteUV1 = _sprite__getUVs[1], spriteUV2 = _sprite__getUVs[2], spriteUV3 = _sprite__getUVs[3];
        var expectWidth = sprite.width, expectHeight = sprite.height;
        var fixedL = expectWidth * border.x;
        var fixedR = expectWidth * border.z;
        var fixedLR = fixedL + fixedR;
        var fixedCW = expectWidth - fixedLR;
        var fixedT = expectHeight * border.w;
        var fixedB = expectHeight * border.y;
        var fixedTB = fixedT + fixedB;
        var fixedCH = expectHeight - fixedTB;
        var scale;
        var rType, cType;
        var rVertCount, cVertCount;
        var rRepeatCount, cRepeatCount;
        if (fixedLR >= width) {
            rVertCount = 3;
            rType = 0;
        } else {
            if (fixedCW > MathUtil$1.zeroTolerance) {
                rRepeatCount = (width - fixedLR) / fixedCW;
                rRepeatCount = rRepeatCount % 1 >= threshold ? Math.ceil(rRepeatCount) : Math.floor(rRepeatCount);
                rVertCount = 4 + rRepeatCount - 1;
                rType = 2;
            } else {
                rVertCount = 4;
                rType = 1;
            }
        }
        if (fixedTB >= height) {
            cVertCount = 3;
            cType = 0;
        } else {
            if (fixedCH > MathUtil$1.zeroTolerance) {
                cRepeatCount = (height - fixedTB) / fixedCH;
                cRepeatCount = cRepeatCount % 1 >= threshold ? Math.ceil(cRepeatCount) : Math.floor(cRepeatCount);
                cVertCount = 4 + cRepeatCount - 1;
                cType = 2;
            } else {
                cVertCount = 4;
                cType = 1;
            }
        }
        if ((rVertCount - 1) * (cVertCount - 1) * 4 > Basic2DBatcher.MAX_VERTEX_COUNT) {
            posRow.add(width * left), posRow.add(width * right);
            posColumn.add(height * bottom), posColumn.add(height * top);
            uvRow.add(spriteUV0.x), uvRow.add(spriteUV3.x);
            uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV3.y);
            Logger.warn("The number of vertices exceeds the upper limit(" + Basic2DBatcher.MAX_VERTEX_COUNT + ").");
            return;
        }
        switch(rType){
            case 0:
                scale = width / fixedLR;
                posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
                posRow.add(width - expectWidth * (1 - right) * scale);
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
            case 1:
                posRow.add(expectWidth * left), posRow.add(fixedL), posRow.add(width - fixedR);
                posRow.add(width - expectWidth * (1 - right));
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(NaN), uvRow.add(NaN);
                uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
            case 2:
                scale = width / (fixedLR + rRepeatCount * fixedCW);
                posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV1.x);
                for(var i = 0, l = rRepeatCount - 1; i < l; i++){
                    posRow.add(fixedL + (i + 1) * fixedCW * scale);
                    uvRow.add(spriteUV2.x), uvRow.add(spriteUV1.x);
                }
                posRow.add(width - fixedR * scale), posRow.add(width - expectWidth * (1 - right) * scale);
                uvRow.add(spriteUV2.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
        }
        switch(cType){
            case 0:
                scale = height / fixedTB;
                posColumn.add(expectHeight * bottom * scale), posColumn.add(fixedB * scale);
                posColumn.add(height - expectHeight * (1 - top) * scale);
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
            case 1:
                posColumn.add(expectHeight * bottom), posColumn.add(fixedB), posColumn.add(height - fixedT);
                posColumn.add(height - expectHeight * (1 - top));
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(NaN), uvColumn.add(NaN);
                uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
            case 2:
                scale = height / (fixedTB + cRepeatCount * fixedCH);
                posColumn.add(expectHeight * bottom * scale), posColumn.add(fixedB * scale);
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV1.y);
                for(var i1 = 0, l1 = cRepeatCount - 1; i1 < l1; i1++){
                    posColumn.add(fixedB + (i1 + 1) * fixedCH * scale);
                    uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV1.y);
                }
                posColumn.add(height - fixedT * scale), posColumn.add(height - expectHeight * (1 - top) * scale);
                uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
        }
    };
    TiledSpriteAssembler1._calculateContinuousDividing = function _calculateContinuousDividing(sprite, width, height, posRow, posColumn, uvRow, uvColumn) {
        var border = sprite.border;
        var spritePositions = sprite._getPositions();
        var _spritePositions_ = spritePositions[0], left = _spritePositions_.x, bottom = _spritePositions_.y;
        var _spritePositions_1 = spritePositions[3], right = _spritePositions_1.x, top = _spritePositions_1.y;
        var _sprite__getUVs = sprite._getUVs(), spriteUV0 = _sprite__getUVs[0], spriteUV1 = _sprite__getUVs[1], spriteUV2 = _sprite__getUVs[2], spriteUV3 = _sprite__getUVs[3];
        var expectWidth = sprite.width, expectHeight = sprite.height;
        var fixedL = expectWidth * border.x;
        var fixedR = expectWidth * border.z;
        var fixedLR = fixedL + fixedR;
        var fixedCW = expectWidth - fixedLR;
        var fixedT = expectHeight * border.w;
        var fixedB = expectHeight * border.y;
        var fixedTB = fixedT + fixedB;
        var fixedCH = expectHeight - fixedTB;
        var rType, cType;
        var rVertCount, cVertCount;
        var rRepeatCount, cRepeatCount;
        if (fixedLR >= width) {
            rVertCount = 3;
            rType = 0;
        } else {
            if (fixedCW > MathUtil$1.zeroTolerance) {
                rRepeatCount = (width - fixedLR) / fixedCW;
                rVertCount = 4 + (rRepeatCount | 0);
                rType = 2;
            } else {
                rVertCount = 4;
                rType = 1;
            }
        }
        if (fixedTB >= height) {
            cVertCount = 3;
            cType = 0;
        } else {
            if (fixedCH > MathUtil$1.zeroTolerance) {
                cRepeatCount = (height - fixedTB) / fixedCH;
                cVertCount = 4 + (cRepeatCount | 0);
                cType = 2;
            } else {
                cVertCount = 4;
                cType = 1;
            }
        }
        if ((rVertCount - 1) * (cVertCount - 1) * 4 > Basic2DBatcher.MAX_VERTEX_COUNT) {
            posRow.add(width * left), posRow.add(width * right);
            posColumn.add(height * bottom), posColumn.add(height * top);
            uvRow.add(spriteUV0.x), uvRow.add(spriteUV3.x);
            uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV3.y);
            Logger.warn("The number of vertices exceeds the upper limit(" + Basic2DBatcher.MAX_VERTEX_COUNT + ").");
            return;
        }
        switch(rType){
            case 0:
                var scale = width / fixedLR;
                posRow.add(expectWidth * left * scale), posRow.add(fixedL * scale);
                posRow.add(width - expectWidth * (1 - right) * scale);
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
            case 1:
                posRow.add(expectWidth * left), posRow.add(fixedL), posRow.add(width - fixedR);
                posRow.add(width - expectWidth * (1 - right));
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(NaN), uvRow.add(NaN);
                uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
            case 2:
                posRow.add(expectWidth * left), posRow.add(fixedL);
                uvRow.add(spriteUV0.x), uvRow.add(spriteUV1.x), uvRow.add(spriteUV1.x);
                var countInteger = rRepeatCount | 0;
                for(var i = 0; i < countInteger; i++){
                    posRow.add(fixedL + (i + 1) * fixedCW);
                    uvRow.add(spriteUV2.x), uvRow.add(spriteUV1.x);
                }
                posRow.add(width - fixedR), posRow.add(width - expectWidth * (1 - right));
                uvRow.add((spriteUV2.x - spriteUV1.x) * (rRepeatCount - countInteger) + spriteUV1.x);
                uvRow.add(spriteUV2.x), uvRow.add(spriteUV3.x);
                break;
        }
        switch(cType){
            case 0:
                var scale1 = height / fixedTB;
                posColumn.add(expectHeight * bottom * scale1), posColumn.add(fixedB * scale1);
                posColumn.add(height - expectHeight * (1 - top) * scale1);
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
            case 1:
                posColumn.add(expectHeight * bottom), posColumn.add(fixedB), posColumn.add(height - fixedT);
                posColumn.add(height - expectHeight * (1 - top));
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(NaN), uvColumn.add(NaN);
                uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
            case 2:
                posColumn.add(expectHeight * bottom), posColumn.add(fixedB);
                uvColumn.add(spriteUV0.y), uvColumn.add(spriteUV1.y), uvColumn.add(spriteUV1.y);
                var countInteger1 = cRepeatCount | 0;
                for(var i1 = 0; i1 < countInteger1; i1++){
                    posColumn.add(fixedB + (i1 + 1) * fixedCH);
                    uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV1.y);
                }
                posColumn.add(height - fixedT), posColumn.add(height - expectHeight * (1 - top));
                uvColumn.add((spriteUV2.y - spriteUV1.y) * (cRepeatCount - countInteger1) + spriteUV1.y);
                uvColumn.add(spriteUV2.y), uvColumn.add(spriteUV3.y);
                break;
        }
    };
    return TiledSpriteAssembler1;
}(), function() {
    _TiledSpriteAssembler._worldMatrix = new Matrix();
}(), function() {
    _TiledSpriteAssembler._posRow = new DisorderedArray();
}(), function() {
    _TiledSpriteAssembler._posColumn = new DisorderedArray();
}(), function() {
    _TiledSpriteAssembler._uvRow = new DisorderedArray();
}(), function() {
    _TiledSpriteAssembler._uvColumn = new DisorderedArray();
}(), _TiledSpriteAssembler);
TiledSpriteAssembler = __decorate$1([
    StaticInterfaceImplement()
], TiledSpriteAssembler);
var TiledType;
(function(TiledType) {
    TiledType[TiledType["Compressed"] = 0] = "Compressed";
    TiledType[TiledType["WithoutTiled"] = 1] = "WithoutTiled";
    TiledType[TiledType["WithTiled"] = 2] = "WithTiled";
})(TiledType || (TiledType = {}));

/**
 * Renders a Sprite for 2D graphics.
 */ var SpriteRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(SpriteRenderer, Renderer);
    function SpriteRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this;
        _this._tileMode = SpriteTileMode.Continuous;
        _this._tiledAdaptiveThreshold = 0.5;
        _this._color = new Color$1(1, 1, 1, 1);
        _this._sprite = null;
        _this._automaticWidth = 0;
        _this._automaticHeight = 0;
        _this._customWidth = undefined;
        _this._customHeight = undefined;
        _this._flipX = false;
        _this._flipY = false;
        _this._maskLayer = SpriteMaskLayer.Layer0;
        _this._maskInteraction = SpriteMaskInteraction.None;
        _this._verticesData = new VertexData2D(4, [], [], null, _this._color);
        _this.drawMode = SpriteDrawMode.Simple;
        _this.setMaterial(_this._engine._spriteDefaultMaterial);
        _this._onSpriteChange = _this._onSpriteChange.bind(_assert_this_initialized(_this));
        return _this;
    }
    var _proto = SpriteRenderer.prototype;
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        Renderer.prototype._cloneTo.call(this, target);
        target._assembler.resetData(target);
        target.sprite = this._sprite;
        target.drawMode = this._drawMode;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(context) {
        // @ts-ignore
        this._updateTransformShaderData(context, Matrix._identity);
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        if (this.sprite) {
            this._assembler.updatePositions(this);
        } else {
            worldBounds.min.set(0, 0, 0);
            worldBounds.max.set(0, 0, 0);
        }
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        var _this_sprite;
        if (!((_this_sprite = this.sprite) == null ? void 0 : _this_sprite.texture) || !this.width || !this.height) {
            return;
        }
        // Update position
        if (this._dirtyUpdateFlag & RendererUpdateFlags.WorldVolume) {
            this._assembler.updatePositions(this);
            this._dirtyUpdateFlag &= ~RendererUpdateFlags.WorldVolume;
        }
        // Update uv
        if (this._dirtyUpdateFlag & 0x2) {
            this._assembler.updateUVs(this);
            this._dirtyUpdateFlag &= ~0x2;
        }
        // Push primitive
        var material = this.getMaterial();
        var texture = this.sprite.texture;
        var renderData = this._engine._spriteRenderDataPool.getFromPool();
        renderData.set(this, material, this._verticesData, texture);
        context.camera._renderPipeline.pushRenderData(context, renderData);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Renderer.prototype._onDestroy.call(this);
        var sprite = this._sprite;
        if (sprite) {
            sprite._addReferCount(-1);
            sprite._updateFlagManager.removeListener(this._onSpriteChange);
        }
        this._entity = null;
        this._color = null;
        this._sprite = null;
        this._assembler = null;
        this._verticesData = null;
    };
    _proto._calDefaultSize = function _calDefaultSize() {
        var sprite = this._sprite;
        if (sprite) {
            this._automaticWidth = sprite.width;
            this._automaticHeight = sprite.height;
        } else {
            this._automaticWidth = this._automaticHeight = 0;
        }
        this._dirtyUpdateFlag &= ~0x4;
    };
    _proto._updateStencilState = function _updateStencilState() {
        // Update stencil.
        var material = this.getInstanceMaterial();
        var stencilState = material.renderState.stencilState;
        var maskInteraction = this._maskInteraction;
        if (maskInteraction === SpriteMaskInteraction.None) {
            stencilState.enabled = false;
            stencilState.writeMask = 0xff;
            stencilState.referenceValue = 0;
            stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
        } else {
            stencilState.enabled = true;
            stencilState.writeMask = 0x00;
            stencilState.referenceValue = 1;
            var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
            stencilState.compareFunctionFront = compare;
            stencilState.compareFunctionBack = compare;
        }
    };
    _proto._onSpriteChange = function _onSpriteChange(type) {
        switch(type){
            case SpriteModifyFlags.texture:
                this.shaderData.setTexture(SpriteRenderer._textureProperty, this.sprite.texture);
                break;
            case SpriteModifyFlags.size:
                var _this = this, drawMode = _this._drawMode;
                this._dirtyUpdateFlag |= 0x4;
                if (this._drawMode === SpriteDrawMode.Sliced) {
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                } else if (drawMode === SpriteDrawMode.Tiled) {
                    this._dirtyUpdateFlag |= 0x3;
                } else {
                    // When the width and height of `SpriteRenderer` are `undefined`,
                    // the `size` of `Sprite` will affect the position of `SpriteRenderer`.
                    if (this._customWidth === undefined || this._customHeight === undefined) {
                        this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                    }
                }
                break;
            case SpriteModifyFlags.border:
                this._drawMode === SpriteDrawMode.Sliced && (this._dirtyUpdateFlag |= 0x3);
                break;
            case SpriteModifyFlags.region:
            case SpriteModifyFlags.atlasRegionOffset:
                this._dirtyUpdateFlag |= 0x3;
                break;
            case SpriteModifyFlags.atlasRegion:
                this._dirtyUpdateFlag |= 0x2;
                break;
            case SpriteModifyFlags.pivot:
                this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                break;
        }
    };
    _create_class$3(SpriteRenderer, [
        {
            key: "drawMode",
            get: /**
   * The draw mode of the sprite renderer.
   */ function get() {
                return this._drawMode;
            },
            set: function set(value) {
                if (this._drawMode !== value) {
                    this._drawMode = value;
                    switch(value){
                        case SpriteDrawMode.Simple:
                            this._assembler = SimpleSpriteAssembler;
                            break;
                        case SpriteDrawMode.Sliced:
                            this._assembler = SlicedSpriteAssembler;
                            break;
                        case SpriteDrawMode.Tiled:
                            this._assembler = TiledSpriteAssembler;
                            break;
                    }
                    this._assembler.resetData(this);
                    this._dirtyUpdateFlag |= 0x3;
                }
            }
        },
        {
            key: "tileMode",
            get: /**
   * The tiling mode of the sprite renderer. (Only works in tiled mode.)
   */ function get() {
                return this._tileMode;
            },
            set: function set(value) {
                if (this._tileMode !== value) {
                    this._tileMode = value;
                    if (this.drawMode === SpriteDrawMode.Tiled) {
                        this._dirtyUpdateFlag |= 0x3;
                    }
                }
            }
        },
        {
            key: "tiledAdaptiveThreshold",
            get: /**
   * Stretch Threshold in Tile Adaptive Mode, specified in normalized. (Only works in tiled adaptive mode.)
   */ function get() {
                return this._tiledAdaptiveThreshold;
            },
            set: function set(value) {
                if (value !== this._tiledAdaptiveThreshold) {
                    value = MathUtil$1.clamp(value, 0, 1);
                    this._tiledAdaptiveThreshold = value;
                    if (this.drawMode === SpriteDrawMode.Tiled) {
                        this._dirtyUpdateFlag |= 0x3;
                    }
                }
            }
        },
        {
            key: "sprite",
            get: /**
   * The Sprite to render.
   */ function get() {
                return this._sprite;
            },
            set: function set(value) {
                var lastSprite = this._sprite;
                if (lastSprite !== value) {
                    if (lastSprite) {
                        lastSprite._addReferCount(-1);
                        lastSprite._updateFlagManager.removeListener(this._onSpriteChange);
                    }
                    this._dirtyUpdateFlag |= 0x7;
                    if (value) {
                        value._addReferCount(1);
                        value._updateFlagManager.addListener(this._onSpriteChange);
                        this.shaderData.setTexture(SpriteRenderer._textureProperty, value.texture);
                    } else {
                        this.shaderData.setTexture(SpriteRenderer._textureProperty, null);
                    }
                    this._sprite = value;
                }
            }
        },
        {
            key: "color",
            get: /**
   * Rendering color for the Sprite graphic.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "width",
            get: /**
   * Render width (in world coordinates).
   *
   * @remarks
   * If width is set, return the set value,
   * otherwise return `SpriteRenderer.sprite.width`.
   */ function get() {
                if (this._customWidth !== undefined) {
                    return this._customWidth;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticWidth;
                }
            },
            set: function set(value) {
                if (this._customWidth !== value) {
                    this._customWidth = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "height",
            get: /**
   * Render height (in world coordinates).
   *
   * @remarks
   * If height is set, return the set value,
   * otherwise return `SpriteRenderer.sprite.height`.
   */ function get() {
                if (this._customHeight !== undefined) {
                    return this._customHeight;
                } else {
                    this._dirtyUpdateFlag & 0x4 && this._calDefaultSize();
                    return this._automaticHeight;
                }
            },
            set: function set(value) {
                if (this._customHeight !== value) {
                    this._customHeight = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipX",
            get: /**
   * Flips the sprite on the X axis.
   */ function get() {
                return this._flipX;
            },
            set: function set(value) {
                if (this._flipX !== value) {
                    this._flipX = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "flipY",
            get: /**
   * Flips the sprite on the Y axis.
   */ function get() {
                return this._flipY;
            },
            set: function set(value) {
                if (this._flipY !== value) {
                    this._flipY = value;
                    this._dirtyUpdateFlag |= RendererUpdateFlags.WorldVolume;
                }
            }
        },
        {
            key: "maskLayer",
            get: /**
   * The mask layer the sprite renderer belongs to.
   */ function get() {
                return this._maskLayer;
            },
            set: function set(value) {
                this._maskLayer = value;
            }
        },
        {
            key: "maskInteraction",
            get: /**
   * Interacts with the masks.
   */ function get() {
                return this._maskInteraction;
            },
            set: function set(value) {
                if (this._maskInteraction !== value) {
                    this._maskInteraction = value;
                    this._updateStencilState();
                }
            }
        }
    ]);
    return SpriteRenderer;
}(Renderer);
(function() {
    /** @internal */ SpriteRenderer._textureProperty = ShaderProperty.getByName("renderer_SpriteTexture");
})();
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_verticesData", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_drawMode", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_assembler", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_tileMode", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_tiledAdaptiveThreshold", void 0);
__decorate$1([
    deepClone
], SpriteRenderer.prototype, "_color", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_sprite", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_automaticWidth", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_automaticHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_customWidth", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_customHeight", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_flipX", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_flipY", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_maskLayer", void 0);
__decorate$1([
    assignmentClone
], SpriteRenderer.prototype, "_maskInteraction", void 0);
__decorate$1([
    ignoreClone
], SpriteRenderer.prototype, "_onSpriteChange", null);
var /**
 * @remarks Extends `RendererUpdateFlag`.
 */ SpriteRendererUpdateFlags;
(function(SpriteRendererUpdateFlags) {
    SpriteRendererUpdateFlags[SpriteRendererUpdateFlags[/** UV. */ "UV"] = 0x2] = "UV";
    SpriteRendererUpdateFlags[SpriteRendererUpdateFlags[/** WorldVolume and UV . */ "RenderData"] = 0x3] = "RenderData";
    SpriteRendererUpdateFlags[SpriteRendererUpdateFlags[/** Automatic Size. */ "AutomaticSize"] = 0x4] = "AutomaticSize";
    SpriteRendererUpdateFlags[SpriteRendererUpdateFlags[/** All. */ "All"] = 0x7] = "All";
})(SpriteRendererUpdateFlags || (SpriteRendererUpdateFlags = {}));

/**
 * @internal
 */ var CharRenderData = function CharRenderData() {
    /** x:Top y:Left z:Bottom w:Right */ this.localPositions = new Vector4();
    var positions = [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
    ];
    this.renderData = new VertexData2D(4, positions, null, CharRenderData.triangles, null);
};
(function() {
    CharRenderData.triangles = [
        0,
        2,
        1,
        2,
        0,
        3
    ];
})();

/**
 * @internal
 */ var CharRenderDataPool = /*#__PURE__*/ function() {
    function CharRenderDataPool(type, length) {
        this._elements = [];
        this._type = type;
        var elements = this._elements;
        for(var i = 0; i < length; ++i){
            elements[i] = new type();
        }
    }
    var _proto = CharRenderDataPool.prototype;
    _proto.get = function get() {
        if (this._elements.length > 0) {
            return this._elements.pop();
        }
        return new this._type();
    };
    _proto.put = function put(data) {
        this._elements.push(data);
    };
    return CharRenderDataPool;
}();

/**
 * Renders a text for 2D graphics.
 */ var TextRenderer = /*#__PURE__*/ function(Renderer) {
    _inherits$2(TextRenderer, Renderer);
    function TextRenderer(entity) {
        var _this;
        _this = Renderer.call(this, entity) || this;
        /** @internal */ _this._subFont = null;
        /** @internal */ _this._charRenderDatas = [];
        _this._dirtyFlag = 15;
        _this._color = new Color$1(1, 1, 1, 1);
        _this._text = "";
        _this._width = 0;
        _this._height = 0;
        _this._localBounds = new BoundingBox();
        _this._font = null;
        _this._fontSize = 24;
        _this._fontStyle = FontStyle.None;
        _this._lineSpacing = 0;
        _this._horizontalAlignment = exports.TextHorizontalAlignment.Center;
        _this._verticalAlignment = TextVerticalAlignment.Center;
        _this._enableWrapping = false;
        _this._overflowMode = OverflowMode.Overflow;
        _this._maskInteraction = SpriteMaskInteraction.None;
        _this._maskLayer = SpriteMaskLayer.Layer0;
        _this._init();
        return _this;
    }
    var _proto = TextRenderer.prototype;
    /**
   * @internal
   * Standalone for CanvasRenderer plugin.
   */ _proto._init = function _init() {
        var engine = this.engine;
        this._font = engine._textDefaultFont;
        this._font._addReferCount(1);
        this.setMaterial(engine._spriteDefaultMaterial);
    };
    /**
   * @internal
   */ _proto._onDestroy = function _onDestroy() {
        Renderer.prototype._onDestroy.call(this);
        // Clear render data.
        var charRenderDatas = this._charRenderDatas;
        for(var i = 0, n = charRenderDatas.length; i < n; ++i){
            TextRenderer._charRenderDataPool.put(charRenderDatas[i]);
        }
        charRenderDatas.length = 0;
        if (this._font) {
            this._font._addReferCount(-1);
            this._font = null;
        }
        this._subFont && (this._subFont = null);
    };
    /**
   * @internal
   */ _proto._cloneTo = function _cloneTo(target) {
        Renderer.prototype._cloneTo.call(this, target);
        target.font = this._font;
        target._subFont = this._subFont;
    };
    /**
   * @internal
   */ _proto._isContainDirtyFlag = function _isContainDirtyFlag(type) {
        return (this._dirtyFlag & type) != 0;
    };
    /**
   * @internal
   */ _proto._setDirtyFlagTrue = function _setDirtyFlagTrue(type) {
        this._dirtyFlag |= type;
    };
    /**
   * @internal
   */ _proto._setDirtyFlagFalse = function _setDirtyFlagFalse(type) {
        this._dirtyFlag &= ~type;
    };
    /**
   * @internal
   */ _proto._updateShaderData = function _updateShaderData(context) {
        // @ts-ignore
        this._updateTransformShaderData(context, Matrix._identity);
    };
    /**
   * @internal
   */ _proto._updateBounds = function _updateBounds(worldBounds) {
        BoundingBox.transform(this._localBounds, this._entity.transform.worldMatrix, worldBounds);
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        if (this._text === "" || this.enableWrapping && this.width <= 0 || this.overflowMode === OverflowMode.Truncate && this.height <= 0) {
            return;
        }
        if (this._isContainDirtyFlag(0x10)) {
            this._updateStencilState();
            this._setDirtyFlagFalse(0x10);
        }
        if (this._isContainDirtyFlag(0x1)) {
            this._resetSubFont();
            this._setDirtyFlagFalse(0x1);
        }
        if (this._isContainDirtyFlag(0x2)) {
            this._updateLocalData();
            this._setDirtyFlagFalse(0x2);
        }
        if (this._isContainDirtyFlag(0x4)) {
            this._updatePosition();
            this._setDirtyFlagFalse(0x4);
        }
        var spriteRenderDataPool = this._engine._spriteRenderDataPool;
        var textData = this._engine._textRenderDataPool.getFromPool();
        var charsData = textData.charsData;
        var material = this.getMaterial();
        var charRenderDatas = this._charRenderDatas;
        var charCount = charRenderDatas.length;
        textData.component = this;
        textData.material = material;
        charsData.length = charCount;
        for(var i = 0; i < charCount; ++i){
            var charRenderData = charRenderDatas[i];
            var spriteRenderData = spriteRenderDataPool.getFromPool();
            spriteRenderData.set(this, material, charRenderData.renderData, charRenderData.texture, i);
            charsData[i] = spriteRenderData;
        }
        context.camera._renderPipeline.pushRenderData(context, textData);
    };
    _proto._updateStencilState = function _updateStencilState() {
        var material = this.getInstanceMaterial();
        var stencilState = material.renderState.stencilState;
        var maskInteraction = this._maskInteraction;
        if (maskInteraction === SpriteMaskInteraction.None) {
            stencilState.enabled = false;
            stencilState.writeMask = 0xff;
            stencilState.referenceValue = 0;
            stencilState.compareFunctionFront = stencilState.compareFunctionBack = CompareFunction.Always;
        } else {
            stencilState.enabled = true;
            stencilState.writeMask = 0x00;
            stencilState.referenceValue = 1;
            var compare = maskInteraction === SpriteMaskInteraction.VisibleInsideMask ? CompareFunction.LessEqual : CompareFunction.Greater;
            stencilState.compareFunctionFront = compare;
            stencilState.compareFunctionBack = compare;
        }
    };
    _proto._resetSubFont = function _resetSubFont() {
        var font = this._font;
        this._subFont = font._getSubFont(this.fontSize, this.fontStyle);
        this._subFont.nativeFontString = TextUtils.getNativeFontString(font.name, this.fontSize, this.fontStyle);
    };
    _proto._updatePosition = function _updatePosition() {
        var transform = this.entity.transform;
        var e = transform.worldMatrix.elements;
        var charRenderDatas = this._charRenderDatas;
        // prettier-ignore
        var e0 = e[0], e1 = e[1], e2 = e[2], e4 = e[4], e5 = e[5], e6 = e[6], e12 = e[12], e13 = e[13], e14 = e[14];
        var up = TextRenderer._tempVec31.set(e4, e5, e6);
        var right = TextRenderer._tempVec30.set(e0, e1, e2);
        for(var i = 0, n = charRenderDatas.length; i < n; ++i){
            var charRenderData = charRenderDatas[i];
            var localPositions = charRenderData.localPositions;
            var positions = charRenderData.renderData.positions;
            var topLeftX = localPositions.x, topLeftY = localPositions.y;
            // Top-Left
            var worldPosition0 = positions[0];
            worldPosition0.x = topLeftX * e0 + topLeftY * e4 + e12;
            worldPosition0.y = topLeftX * e1 + topLeftY * e5 + e13;
            worldPosition0.z = topLeftX * e2 + topLeftY * e6 + e14;
            // Right offset
            var worldPosition1 = positions[1];
            Vector3.scale(right, localPositions.z - topLeftX, worldPosition1);
            // Top-Right
            Vector3.add(worldPosition0, worldPosition1, worldPosition1);
            // Up offset
            var worldPosition2 = positions[2];
            Vector3.scale(up, localPositions.w - topLeftY, worldPosition2);
            // Bottom-Left
            Vector3.add(worldPosition0, worldPosition2, positions[3]);
            // Bottom-Right
            Vector3.add(worldPosition1, worldPosition2, worldPosition2);
        }
    };
    _proto._updateLocalData = function _updateLocalData() {
        var _this = this, color = _this.color, horizontalAlignment = _this.horizontalAlignment, verticalAlignment = _this.verticalAlignment, charRenderDatas = _this._charRenderDatas;
        var _this__localBounds = this._localBounds, min = _this__localBounds.min, max = _this__localBounds.max;
        var _pixelsPerUnit = Engine._pixelsPerUnit;
        var pixelsPerUnitReciprocal = 1.0 / _pixelsPerUnit;
        var charFont = this._subFont;
        var rendererWidth = this.width * _pixelsPerUnit;
        var halfRendererWidth = rendererWidth * 0.5;
        var rendererHeight = this.height * _pixelsPerUnit;
        var textMetrics = this.enableWrapping ? TextUtils.measureTextWithWrap(this) : TextUtils.measureTextWithoutWrap(this);
        var height = textMetrics.height, lines = textMetrics.lines, lineWidths = textMetrics.lineWidths, lineHeight = textMetrics.lineHeight, lineMaxSizes = textMetrics.lineMaxSizes;
        var charRenderDataPool = TextRenderer._charRenderDataPool;
        var halfLineHeight = lineHeight * 0.5;
        var linesLen = lines.length;
        var startY = 0;
        var topDiff = lineHeight * 0.5 - lineMaxSizes[0].ascent;
        var bottomDiff = lineHeight * 0.5 - lineMaxSizes[linesLen - 1].descent - 1;
        switch(verticalAlignment){
            case TextVerticalAlignment.Top:
                startY = rendererHeight * 0.5 - halfLineHeight + topDiff;
                break;
            case TextVerticalAlignment.Center:
                startY = height * 0.5 - halfLineHeight - (bottomDiff - topDiff) * 0.5;
                break;
            case TextVerticalAlignment.Bottom:
                startY = height - rendererHeight * 0.5 - halfLineHeight - bottomDiff;
                break;
        }
        var renderDataCount = 0;
        var firstLine = -1;
        var minX = Number.MAX_SAFE_INTEGER;
        var minY = Number.MAX_SAFE_INTEGER;
        var maxX = Number.MIN_SAFE_INTEGER;
        var maxY = Number.MIN_SAFE_INTEGER;
        for(var i = 0; i < linesLen; ++i){
            var lineWidth = lineWidths[i];
            if (lineWidth > 0) {
                var line = lines[i];
                var startX = 0;
                var firstRow = -1;
                if (firstLine < 0) {
                    firstLine = i;
                }
                switch(horizontalAlignment){
                    case exports.TextHorizontalAlignment.Left:
                        startX = -halfRendererWidth;
                        break;
                    case exports.TextHorizontalAlignment.Center:
                        startX = -lineWidth * 0.5;
                        break;
                    case exports.TextHorizontalAlignment.Right:
                        startX = halfRendererWidth - lineWidth;
                        break;
                }
                for(var j = 0, n = line.length; j < n; ++j){
                    var char = line[j];
                    var charInfo = charFont._getCharInfo(char);
                    if (charInfo.h > 0) {
                        var _charRenderDatas, _ref;
                        firstRow < 0 && (firstRow = j);
                        var charRenderData = (_charRenderDatas = charRenderDatas)[_ref = renderDataCount++] || (_charRenderDatas[_ref] = charRenderDataPool.get());
                        var renderData = charRenderData.renderData, localPositions = charRenderData.localPositions;
                        charRenderData.texture = charFont._getTextureByIndex(charInfo.index);
                        renderData.color = color;
                        renderData.uvs = charInfo.uvs;
                        var w = charInfo.w, ascent = charInfo.ascent, descent = charInfo.descent;
                        var left = startX * pixelsPerUnitReciprocal;
                        var right = (startX + w) * pixelsPerUnitReciprocal;
                        var top = (startY + ascent) * pixelsPerUnitReciprocal;
                        var bottom = (startY - descent + 1) * pixelsPerUnitReciprocal;
                        localPositions.set(left, top, right, bottom);
                        i === firstLine && (maxY = Math.max(maxY, top));
                        minY = Math.min(minY, bottom);
                        j === firstRow && (minX = Math.min(minX, left));
                        maxX = Math.max(maxX, right);
                    }
                    startX += charInfo.xAdvance;
                }
            }
            startY -= lineHeight;
        }
        if (firstLine < 0) {
            min.set(0, 0, 0);
            max.set(0, 0, 0);
        } else {
            min.set(minX, minY, 0);
            max.set(maxX, maxY, 0);
        }
        // Revert excess render data to pool.
        var lastRenderDataCount = charRenderDatas.length;
        if (lastRenderDataCount > renderDataCount) {
            for(var i1 = renderDataCount; i1 < lastRenderDataCount; ++i1){
                charRenderDataPool.put(charRenderDatas[i1]);
            }
            charRenderDatas.length = renderDataCount;
        }
        charFont._getLastIndex() > 0 && charRenderDatas.sort(function(a, b) {
            return a.texture.instanceId - b.texture.instanceId;
        });
    };
    /**
   * @internal
   */ _proto._onTransformChanged = function _onTransformChanged(bit) {
        Renderer.prototype._onTransformChanged.call(this, bit);
        this._setDirtyFlagTrue(0x4 | 0x8);
    };
    _create_class$3(TextRenderer, [
        {
            key: "color",
            get: /**
   * Rendering color for the Text.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                if (this._color !== value) {
                    this._color.copyFrom(value);
                }
            }
        },
        {
            key: "text",
            get: /**
   * Rendering string for the Text.
   */ function get() {
                return this._text;
            },
            set: function set(value) {
                value = value || "";
                if (this._text !== value) {
                    this._text = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "width",
            get: /**
   * The width of the TextRenderer (in 3D world coordinates).
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                if (this._width !== value) {
                    this._width = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "height",
            get: /**
   * The height of the TextRenderer (in 3D world coordinates).
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._height = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "font",
            get: /**
   * The font of the Text.
   */ function get() {
                return this._font;
            },
            set: function set(value) {
                var lastFont = this._font;
                if (lastFont !== value) {
                    lastFont && lastFont._addReferCount(-1);
                    value && value._addReferCount(1);
                    this._font = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "fontSize",
            get: /**
   * The font size of the Text.
   */ function get() {
                return this._fontSize;
            },
            set: function set(value) {
                if (this._fontSize !== value) {
                    this._fontSize = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "fontStyle",
            get: /**
   * The style of the font.
   */ function get() {
                return this._fontStyle;
            },
            set: function set(value) {
                if (this.fontStyle !== value) {
                    this._fontStyle = value;
                    this._setDirtyFlagTrue(15);
                }
            }
        },
        {
            key: "lineSpacing",
            get: /**
   * The space between two lines (in pixels).
   */ function get() {
                return this._lineSpacing;
            },
            set: function set(value) {
                if (this._lineSpacing !== value) {
                    this._lineSpacing = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "horizontalAlignment",
            get: /**
   * The horizontal alignment.
   */ function get() {
                return this._horizontalAlignment;
            },
            set: function set(value) {
                if (this._horizontalAlignment !== value) {
                    this._horizontalAlignment = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "verticalAlignment",
            get: /**
   * The vertical alignment.
   */ function get() {
                return this._verticalAlignment;
            },
            set: function set(value) {
                if (this._verticalAlignment !== value) {
                    this._verticalAlignment = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "enableWrapping",
            get: /**
   * Whether wrap text to next line when exceeds the width of the container.
   */ function get() {
                return this._enableWrapping;
            },
            set: function set(value) {
                if (this._enableWrapping !== value) {
                    this._enableWrapping = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "overflowMode",
            get: /**
   * The overflow mode.
   */ function get() {
                return this._overflowMode;
            },
            set: function set(value) {
                if (this._overflowMode !== value) {
                    this._overflowMode = value;
                    this._setDirtyFlagTrue(14);
                }
            }
        },
        {
            key: "maskInteraction",
            get: /**
   * Interacts with the masks.
   */ function get() {
                return this._maskInteraction;
            },
            set: function set(value) {
                if (this._maskInteraction !== value) {
                    this._maskInteraction = value;
                    this._setDirtyFlagTrue(0x10);
                }
            }
        },
        {
            key: "maskLayer",
            get: /**
   * The mask layer the sprite renderer belongs to.
   */ function get() {
                return this._maskLayer;
            },
            set: function set(value) {
                this._maskLayer = value;
            }
        },
        {
            key: "bounds",
            get: /**
   * The bounding volume of the TextRenderer.
   */ function get() {
                this._isContainDirtyFlag(0x1) && this._resetSubFont();
                this._isContainDirtyFlag(0x2) && this._updateLocalData();
                this._isContainDirtyFlag(0x4) && this._updatePosition();
                this._isContainDirtyFlag(0x8) && this._updateBounds(this._bounds);
                this._setDirtyFlagFalse(15);
                return this._bounds;
            }
        }
    ]);
    return TextRenderer;
}(Renderer);
(function() {
    TextRenderer._charRenderDataPool = new CharRenderDataPool(CharRenderData, 50);
})();
(function() {
    TextRenderer._tempVec30 = new Vector3();
})();
(function() {
    TextRenderer._tempVec31 = new Vector3();
})();
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_subFont", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_charRenderDatas", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_dirtyFlag", void 0);
__decorate$1([
    deepClone
], TextRenderer.prototype, "_color", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_text", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_width", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_height", void 0);
__decorate$1([
    ignoreClone
], TextRenderer.prototype, "_localBounds", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_font", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_fontSize", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_fontStyle", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_lineSpacing", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_horizontalAlignment", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_verticalAlignment", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_enableWrapping", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_overflowMode", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_maskInteraction", void 0);
__decorate$1([
    assignmentClone
], TextRenderer.prototype, "_maskLayer", void 0);
var DirtyFlag;
(function(DirtyFlag) {
    DirtyFlag[DirtyFlag["SubFont"] = 0x1] = "SubFont";
    DirtyFlag[DirtyFlag["LocalPositionBounds"] = 0x2] = "LocalPositionBounds";
    DirtyFlag[DirtyFlag["WorldPosition"] = 0x4] = "WorldPosition";
    DirtyFlag[DirtyFlag["WorldBounds"] = 0x8] = "WorldBounds";
    DirtyFlag[DirtyFlag["MaskInteraction"] = 0x10] = "MaskInteraction";
    DirtyFlag[DirtyFlag["Position"] = 14] = "Position";
    DirtyFlag[DirtyFlag["Font"] = 15] = "Font";
})(DirtyFlag || (DirtyFlag = {}));

/**
 * @internal
 */ var UniversalAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function UniversalAnimationCurveOwnerAssembler() {}
    var _proto = UniversalAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        var mounted = owner.component;
        var properties = owner.property.split(".");
        var endIndex = properties.length - 1;
        for(var i = 0; i < endIndex; i++){
            mounted = mounted[properties[i]];
        }
        this._mounted = mounted;
        this._propertyName = properties[endIndex];
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._mounted[this._propertyName];
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._mounted[this._propertyName] = value;
    };
    return UniversalAnimationCurveOwnerAssembler;
}();

/**
 * @internal
 */ var AnimationCurveOwner = /*#__PURE__*/ function() {
    function AnimationCurveOwner(target, type, property, cureType) {
        this.baseEvaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this.crossEvaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this.updateMark = 0;
        this.target = target;
        this.type = type;
        this.property = property;
        this.component = target.getComponent(type);
        this.cureType = cureType;
        var assemblerType = AnimationCurveOwner.getAssemblerType(type, property);
        this._assembler = new assemblerType();
        this._assembler.initialize(this);
        if (cureType._isReferenceType) {
            this.referenceTargetValue = this._assembler.getTargetValue();
        }
    }
    var _proto = AnimationCurveOwner.prototype;
    _proto.evaluateValue = function evaluateValue(curve, time, additive) {
        return additive ? curve._evaluateAdditive(time, this.baseEvaluateData) : curve._evaluate(time, this.baseEvaluateData);
    };
    _proto.evaluateCrossFadeValue = function evaluateCrossFadeValue(srcCurve, destCurve, srcTime, destTime, crossWeight, additive) {
        var srcValue = srcCurve && srcCurve.keys.length ? additive ? srcCurve._evaluateAdditive(srcTime, this.baseEvaluateData) : srcCurve._evaluate(srcTime, this.baseEvaluateData) : additive ? this.cureType._getZeroValue(this.baseEvaluateData.value) : this.defaultValue;
        var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
        return this._lerpValue(srcValue, destValue, crossWeight);
    };
    _proto.crossFadeFromPoseAndApplyValue = function crossFadeFromPoseAndApplyValue(destCurve, destTime, crossWeight, additive) {
        var srcValue = additive ? this.cureType._subtractValue(this.fixedPoseValue, this.defaultValue, this.baseEvaluateData.value) : this.fixedPoseValue;
        var destValue = destCurve && destCurve.keys.length ? additive ? destCurve._evaluateAdditive(destTime, this.crossEvaluateData) : destCurve._evaluate(destTime, this.crossEvaluateData) : additive ? this.cureType._getZeroValue(this.crossEvaluateData.value) : this.defaultValue;
        return this._lerpValue(srcValue, destValue, crossWeight);
    };
    _proto.revertDefaultValue = function revertDefaultValue() {
        this._assembler.setTargetValue(this.defaultValue);
    };
    _proto.getEvaluateValue = function getEvaluateValue(out) {
        if (this.cureType._isReferenceType) {
            this.cureType._copyValue(this.baseEvaluateData.value, out);
            return out;
        } else {
            return this.baseEvaluateData.value;
        }
    };
    _proto.saveDefaultValue = function saveDefaultValue() {
        if (this.cureType._isReferenceType) {
            this.cureType._copyValue(this.referenceTargetValue, this.defaultValue);
        } else {
            this.defaultValue = this._assembler.getTargetValue();
        }
    };
    _proto.saveFixedPoseValue = function saveFixedPoseValue() {
        if (this.cureType._isReferenceType) {
            this.cureType._copyValue(this.referenceTargetValue, this.fixedPoseValue);
        } else {
            this.fixedPoseValue = this._assembler.getTargetValue();
        }
    };
    _proto.applyValue = function applyValue(value, weight, additive) {
        var cureType = this.cureType;
        if (additive) {
            if (cureType._isReferenceType) {
                cureType._additiveValue(value, weight, this.referenceTargetValue);
            } else {
                var assembler = this._assembler;
                var originValue = assembler.getTargetValue();
                var additiveValue = cureType._additiveValue(value, weight, originValue);
                assembler.setTargetValue(additiveValue);
            }
        } else {
            if (weight === 1.0) {
                if (cureType._isReferenceType) {
                    cureType._copyValue(value, this.referenceTargetValue);
                } else {
                    this._assembler.setTargetValue(value);
                }
            } else {
                if (cureType._isReferenceType) {
                    var targetValue = this.referenceTargetValue;
                    cureType._lerpValue(targetValue, value, weight, targetValue);
                } else {
                    var originValue1 = this._assembler.getTargetValue();
                    var lerpValue = cureType._lerpValue(originValue1, value, weight);
                    this._assembler.setTargetValue(lerpValue);
                }
            }
        }
    };
    _proto._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
        if (this.cureType._isReferenceType) {
            return this.cureType._lerpValue(srcValue, destValue, crossWeight, this.baseEvaluateData.value);
        } else {
            this.baseEvaluateData.value = this.cureType._lerpValue(srcValue, destValue, crossWeight);
            return this.baseEvaluateData.value;
        }
    };
    AnimationCurveOwner.registerAssembler = function registerAssembler(componentType, property, assemblerType) {
        var subMap = AnimationCurveOwner._assemblerMap.get(componentType);
        if (!subMap) {
            subMap = {};
            AnimationCurveOwner._assemblerMap.set(componentType, subMap);
        }
        subMap[property] = assemblerType;
    };
    AnimationCurveOwner.getAssemblerType = function getAssemblerType(componentType, property) {
        var subMap = AnimationCurveOwner._assemblerMap.get(componentType);
        var assemblerType = subMap ? subMap[property] : undefined;
        return assemblerType != null ? assemblerType : UniversalAnimationCurveOwnerAssembler;
    };
    return AnimationCurveOwner;
}();
(function() {
    AnimationCurveOwner._assemblerMap = new Map();
})();

/**
 * @internal
 */ var PositionAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function PositionAnimationCurveOwnerAssembler() {}
    var _proto = PositionAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.position;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.position = value;
    };
    return PositionAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "position", PositionAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var RotationAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function RotationAnimationCurveOwnerAssembler() {}
    var _proto = RotationAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.rotationQuaternion;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.rotationQuaternion = value;
    };
    return RotationAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "rotationQuaternion", RotationAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var ScaleAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function ScaleAnimationCurveOwnerAssembler() {}
    var _proto = ScaleAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._transform = owner.target.transform;
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._transform.scale;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._transform.scale = value;
    };
    return ScaleAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(Transform, "scale", ScaleAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var BlendShapeWeightsAnimationCurveOwnerAssembler = /*#__PURE__*/ function() {
    function BlendShapeWeightsAnimationCurveOwnerAssembler() {}
    var _proto = BlendShapeWeightsAnimationCurveOwnerAssembler.prototype;
    _proto.initialize = function initialize(owner) {
        this._skinnedMeshRenderer = owner.target.getComponent(SkinnedMeshRenderer);
    };
    _proto.getTargetValue = function getTargetValue() {
        return this._skinnedMeshRenderer.blendShapeWeights;
    };
    _proto.setTargetValue = function setTargetValue(value) {
        this._skinnedMeshRenderer.blendShapeWeights = value;
    };
    return BlendShapeWeightsAnimationCurveOwnerAssembler;
}();
AnimationCurveOwner.registerAssembler(SkinnedMeshRenderer, "blendShapeWeights", BlendShapeWeightsAnimationCurveOwnerAssembler);

/**
 * @internal
 */ var AnimationCurveLayerOwner = /*#__PURE__*/ function() {
    function AnimationCurveLayerOwner() {
        this.crossCurveMark = 0;
    }
    var _proto = AnimationCurveLayerOwner.prototype;
    _proto.initFinalValue = function initFinalValue() {
        var _this_curveOwner = this.curveOwner, cureType = _this_curveOwner.cureType, defaultValue = _this_curveOwner.defaultValue;
        if (cureType._isReferenceType) {
            cureType._copyValue(defaultValue, this.finalValue);
        } else {
            this.finalValue = defaultValue;
        }
    };
    _proto.saveFinalValue = function saveFinalValue() {
        this.finalValue = this.curveOwner.getEvaluateValue(this.finalValue);
    };
    return AnimationCurveLayerOwner;
}();

/**
 * Associate AnimationCurve and the Entity
 */ var AnimationClipCurveBinding = /*#__PURE__*/ function() {
    function AnimationClipCurveBinding() {
        this._tempCurveOwner = {};
    }
    var _proto = AnimationClipCurveBinding.prototype;
    /**
   * @internal
   */ _proto._createCurveOwner = function _createCurveOwner(entity) {
        var curveType = this.curve.constructor;
        var owner = new AnimationCurveOwner(entity, this.type, this.property, curveType);
        curveType._initializeOwner(owner);
        owner.saveDefaultValue();
        return owner;
    };
    /**
   * @internal
   */ _proto._createCurveLayerOwner = function _createCurveLayerOwner(owner) {
        var curveType = this.curve.constructor;
        var layerOwner = new AnimationCurveLayerOwner();
        layerOwner.curveOwner = owner;
        curveType._initializeLayerOwner(layerOwner);
        // If curve.keys.length is 0, updateFinishedState will assign 0 to the target, causing an error, so initialize by assigning defaultValue to finalValue.
        layerOwner.initFinalValue();
        return layerOwner;
    };
    /**
   * @internal
   */ _proto._getTempCurveOwner = function _getTempCurveOwner(entity) {
        var instanceId = entity.instanceId;
        if (!this._tempCurveOwner[instanceId]) {
            this._tempCurveOwner[instanceId] = this._createCurveOwner(entity);
        }
        return this._tempCurveOwner[instanceId];
    };
    return AnimationClipCurveBinding;
}();

/**
 * AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
 */ var AnimationEvent = function AnimationEvent() {
};

/**
 * Stores keyframe based animations.
 */ var AnimationClip = /*#__PURE__*/ function(EngineObject) {
    _inherits$2(AnimationClip, EngineObject);
    function AnimationClip(name) {
        var _this;
        _this = EngineObject.call(this, null) || this;
        _this.name = name;
        _this./** @internal */ _curveBindings = [];
        _this._length = 0;
        _this._events = [];
        return _this;
    }
    var _proto = AnimationClip.prototype;
    _proto.addEvent = function addEvent(param, time, parameter) {
        if (typeof param === "string") {
            var event = new AnimationEvent();
            event.functionName = param;
            event.time = time;
            event.parameter = parameter;
            this._events.push(event);
        } else {
            this._events.push(param);
        }
        this._events.sort(function(a, b) {
            return a.time - b.time;
        });
    };
    /**
   * Clears all events from the clip.
   */ _proto.clearEvents = function clearEvents() {
        this._events.length = 0;
    };
    /**
   * Add curve binding for the clip.
   * @param relativePath - Path to the game object this curve applies to. The relativePath is formatted similar to a pathname, e.g. "/root/spine/leftArm"
   * @param type- The class type of the component that is animated
   * @param propertyName - The name or path to the property being animated
   * @param curve - The animation curve
   */ _proto.addCurveBinding = function addCurveBinding(relativePath, type, propertyName, curve) {
        var curveBinding = new AnimationClipCurveBinding();
        curveBinding.relativePath = relativePath;
        curveBinding.type = type;
        curveBinding.property = propertyName;
        curveBinding.curve = curve;
        if (curve.length > this._length) {
            this._length = curve.length;
        }
        this._curveBindings.push(curveBinding);
    };
    /**
   * Clears all curve bindings from the clip.
   */ _proto.clearCurveBindings = function clearCurveBindings() {
        this._curveBindings.length = 0;
        this._length = 0;
    };
    /**
   * @internal
   * Samples an animation at a given time.
   * @param entity - The animated entity
   * @param time - The time to sample an animation
   */ _proto._sampleAnimation = function _sampleAnimation(entity, time) {
        var _this = this, curveBindings = _this._curveBindings;
        for(var i = curveBindings.length - 1; i >= 0; i--){
            var curveData = curveBindings[i];
            var targetEntity = entity.findByPath(curveData.relativePath);
            if (targetEntity) {
                var curveOwner = curveData._getTempCurveOwner(targetEntity);
                var value = curveOwner.evaluateValue(curveData.curve, time, false);
                curveOwner.applyValue(value, 1, false);
            }
        }
    };
    _create_class$3(AnimationClip, [
        {
            key: "events",
            get: /**
   * Animation events for this animation clip.
   */ function get() {
                return this._events;
            }
        },
        {
            key: "curveBindings",
            get: /**
   * Animation curve bindings for this animation clip.
   */ function get() {
                return this._curveBindings;
            }
        },
        {
            key: "length",
            get: /**
   * Animation length in seconds.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return AnimationClip;
}(EngineObject);

/**
 * Animation interpolation method.
 */ var InterpolationType;
(function(InterpolationType) {
    InterpolationType[InterpolationType[/** Linear interpolation */ "Linear"] = 0] = "Linear";
    InterpolationType[InterpolationType[/** Cubic spline interpolation */ "CubicSpine"] = 1] = "CubicSpine";
    InterpolationType[InterpolationType[/** Stepped interpolation */ "Step"] = 2] = "Step";
    InterpolationType[InterpolationType[/** Hermite interpolation */ "Hermite"] = 3] = "Hermite";
})(InterpolationType || (InterpolationType = {}));

/**
 * Store a collection of Keyframes that can be evaluated over time.
 */ var AnimationCurve = /*#__PURE__*/ function() {
    function AnimationCurve() {
        /** All keys defined in the animation curve. */ this.keys = [];
        this._evaluateData = {
            curKeyframeIndex: 0,
            value: null
        };
        this._length = 0;
        var type = this.constructor;
        this._interpolation = type._isInterpolationType ? InterpolationType.Linear : InterpolationType.Step;
        this._type = type;
    }
    var _proto = AnimationCurve.prototype;
    /**
   * Add a new key to the curve.
   * @param key - The keyframe
   */ _proto.addKey = function addKey(key) {
        var time = key.time;
        var keys = this.keys;
        if (time >= this._length) {
            keys.push(key);
            this._length = time;
        } else {
            var index = keys.length;
            while(--index >= 0 && time < keys[index].time);
            keys.splice(index + 1, 0, key);
        }
    };
    /**
   * Evaluate the curve at time.
   * @param time - The time within the curve you want to evaluate
   */ _proto.evaluate = function evaluate(time) {
        return this._evaluate(time, this._evaluateData);
    };
    /**
   * Removes a key.
   * @param index - The index of the key to remove
   */ _proto.removeKey = function removeKey(index) {
        this.keys.splice(index, 1);
        var keys = this.keys;
        var newLength = 0;
        for(var i = keys.length - 1; i >= 0; i--){
            var key = keys[i];
            if (key.time > length) {
                newLength = key.time;
            }
        }
        this._length = newLength;
    };
    /**
   * @internal
   */ _proto._evaluate = function _evaluate(time, evaluateData) {
        var length1 = this.keys.length;
        if (!length1) {
            console.warn("This curve don't have any keyframes: ", this);
            return;
        }
        var _this = this, keys = _this.keys, interpolation = _this.interpolation;
        // Compute curIndex and nextIndex.
        var curIndex = evaluateData.curKeyframeIndex;
        // Reset loop,if delete keyfranme may cause `curIndex >= length`
        if (curIndex !== -1 && (curIndex >= length1 || time < keys[curIndex].time)) {
            curIndex = -1;
        }
        var nextIndex = curIndex + 1;
        while(nextIndex < length1){
            if (time < keys[nextIndex].time) {
                break;
            }
            curIndex++;
            nextIndex++;
        }
        evaluateData.curKeyframeIndex = curIndex;
        // Evaluate value.
        var value;
        if (curIndex === -1) {
            value = this._type._copyValue(keys[0].value, evaluateData.value);
        } else if (nextIndex === length1) {
            value = this._type._copyValue(keys[curIndex].value, evaluateData.value);
        } else {
            // Time between first frame and end frame.
            var curFrame = keys[curIndex];
            var nextFrame = keys[nextIndex];
            var curFrameTime = curFrame.time;
            var duration = nextFrame.time - curFrameTime;
            var t = (time - curFrameTime) / duration;
            switch(interpolation){
                case InterpolationType.Linear:
                    value = this._type._lerpValue(curFrame.value, nextFrame.value, t, evaluateData.value);
                    break;
                case InterpolationType.Step:
                    value = this._type._copyValue(curFrame.value, evaluateData.value);
                    break;
                case InterpolationType.CubicSpine:
                case InterpolationType.Hermite:
                    value = this._type._hermiteInterpolationValue(curFrame, nextFrame, t, duration, evaluateData.value);
                    break;
            }
        }
        evaluateData.value = value;
        return value;
    };
    /**
   * @internal
   */ _proto._evaluateAdditive = function _evaluateAdditive(time, evaluateData) {
        var result = this._evaluate(time, evaluateData);
        return this._type._subtractValue(result, this.keys[0].value, evaluateData.value);
    };
    _create_class$3(AnimationCurve, [
        {
            key: "interpolation",
            get: /**
   * The interpolationType of the animation curve.
   */ function get() {
                return this._interpolation;
            },
            set: function set(value) {
                if (!this._type._isInterpolationType && value !== InterpolationType.Step) {
                    this._interpolation = InterpolationType.Step;
                    console.warn("The interpolation type must be `InterpolationType.Step`.");
                } else {
                    this._interpolation = value;
                }
            }
        },
        {
            key: "length",
            get: /**
   * Animation curve length in seconds.
   */ function get() {
                return this._length;
            }
        }
    ]);
    return AnimationCurve;
}();

var _AnimationArrayCurve;
var AnimationArrayCurve = (_AnimationArrayCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationArrayCurve, AnimationCurve);
    function AnimationArrayCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = [];
        return _this;
    }
    /**
   * @internal
   */ AnimationArrayCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = [];
        owner.fixedPoseValue = [];
        owner.baseEvaluateData.value = [];
        owner.crossEvaluateData.value = [];
    };
    /**
   * @internal
   */ AnimationArrayCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = [];
    };
    /**
   * @internal
   */ AnimationArrayCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            var src = srcValue[i];
            out[i] = src + (destValue[i] - src) * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._subtractValue = function _subtractValue(src, base, out) {
        for(var i = 0, n = src.length; i < n; i++){
            out[i] = src[i] - base[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._getZeroValue = function _getZeroValue(out) {
        for(var i = 0, n = out.length; i < n; i++){
            out[i] = 0;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._additiveValue = function _additiveValue(value, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] += value[i] * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._copyValue = function _copyValue(source, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] = source[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationArrayCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, duration, out) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        var p0 = frame.value;
        var p1 = nextFrame.value;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        for(var i = 0, n = p0.length; i < n; ++i){
            if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
                out[i] = a * p0[i] + b * t0[i] * duration + c * t1[i] * duration + d * p1[i];
            } else {
                out[i] = frame.value[i];
            }
        }
        return out;
    };
    return AnimationArrayCurve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationArrayCurve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationArrayCurve._isInterpolationType = true;
}(), _AnimationArrayCurve);
AnimationArrayCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationArrayCurve);

var _AnimationBoolCurve;
var AnimationBoolCurve = (_AnimationBoolCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationBoolCurve, AnimationCurve);
    function AnimationBoolCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = false;
        return _this;
    }
    /**
   * @internal
   */ AnimationBoolCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = false;
        owner.fixedPoseValue = false;
        owner.baseEvaluateData.value = false;
        owner.crossEvaluateData.value = false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._lerpValue = function _lerpValue(srcValue, destValue) {
        return destValue;
    };
    /**
   * @internal
   */ AnimationBoolCurve._subtractValue = function _subtractValue(src, base, out) {
        return src;
    };
    /**
   * @internal
   */ AnimationBoolCurve._getZeroValue = function _getZeroValue() {
        return false;
    };
    /**
   * @internal
   */ AnimationBoolCurve._additiveValue = function _additiveValue(value, weight, source) {
        return value;
    };
    /**
   * @internal
   */ AnimationBoolCurve._copyValue = function _copyValue(value) {
        return value;
    };
    /**
   * @internal
   */ AnimationBoolCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame) {
        return frame.value;
    };
    return AnimationBoolCurve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationBoolCurve._isReferenceType = false;
}(), function() {
    /** @internal */ _AnimationBoolCurve._isInterpolationType = false;
}(), _AnimationBoolCurve);
AnimationBoolCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationBoolCurve);

var _AnimationColorCurve;
var AnimationColorCurve = (_AnimationColorCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationColorCurve, AnimationCurve);
    function AnimationColorCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Color$1();
        return _this;
    }
    /**
   * @internal
   */ AnimationColorCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Color$1();
        owner.fixedPoseValue = new Color$1();
        owner.baseEvaluateData.value = new Color$1();
        owner.crossEvaluateData.value = new Color$1();
    };
    /**
   * @internal
   */ AnimationColorCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Color$1();
    };
    /**
   * @internal
   */ AnimationColorCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Color$1.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._subtractValue = function _subtractValue(src, base, out) {
        Color$1.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._additiveValue = function _additiveValue(value, weight, out) {
        Color$1.scale(value, weight, value);
        Color$1.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._copyValue = function _copyValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationColorCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.r = a * p0.r + b * t0 * dur + c * t1 * dur + d * p1.r;
        } else {
            out.r = p0.r;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.g = a * p0.g + b * t0 * dur + c * t1 * dur + d * p1.g;
        } else {
            out.g = p0.g;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.b = a * p0.b + b * t0 * dur + c * t1 * dur + d * p1.b;
        } else {
            out.b = p0.b;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.a = a * p0.a + b * t0 * dur + c * t1 * dur + d * p1.a;
        } else {
            out.a = p0.a;
        }
        return out;
    };
    return AnimationColorCurve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationColorCurve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationColorCurve._isInterpolationType = true;
}(), _AnimationColorCurve);
AnimationColorCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationColorCurve);

var _AnimationFloatArrayCurve;
var AnimationFloatArrayCurve = (_AnimationFloatArrayCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationFloatArrayCurve, AnimationCurve);
    function AnimationFloatArrayCurve() {
        return AnimationCurve.apply(this, arguments);
    }
    var _proto = AnimationFloatArrayCurve.prototype;
    /**
   * @inheritdoc
   */ _proto.addKey = function addKey(key) {
        AnimationCurve.prototype.addKey.call(this, key);
        var evaluateData = this._evaluateData;
        if (!evaluateData.value || evaluateData.value.length !== key.value.length) {
            var size = key.value.length;
            evaluateData.value = new Float32Array(size);
        }
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._initializeOwner = function _initializeOwner(owner) {
        var size = owner.referenceTargetValue.length;
        owner.defaultValue = new Float32Array(size);
        owner.fixedPoseValue = new Float32Array(size);
        owner.baseEvaluateData.value = new Float32Array(size);
        owner.crossEvaluateData.value = new Float32Array(size);
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        var size = owner.curveOwner.referenceTargetValue.length;
        owner.finalValue = new Float32Array(size);
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            var src = srcValue[i];
            out[i] = src + (destValue[i] - src) * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._subtractValue = function _subtractValue(src, base, out) {
        for(var i = 0, n = src.length; i < n; i++){
            out[i] = src[i] - base[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._getZeroValue = function _getZeroValue(out) {
        for(var i = 0, n = out.length; i < n; i++){
            out[i] = 0;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._additiveValue = function _additiveValue(value, weight, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] += value[i] * weight;
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._copyValue = function _copyValue(source, out) {
        for(var i = 0, n = out.length; i < n; ++i){
            out[i] = source[i];
        }
        return out;
    };
    /**
   * @internal
   */ AnimationFloatArrayCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        var p0 = frame.value;
        var p1 = nextFrame.value;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        for(var i = 0, n = p0.length; i < n; ++i){
            if (Number.isFinite(t0[i]) && Number.isFinite(t1[i])) {
                out[i] = a * p0[i] + b * t0[i] * dur + c * t1[i] * dur + d * p1[i];
            } else {
                out[i] = frame.value[i];
            }
        }
        return out;
    };
    return AnimationFloatArrayCurve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationFloatArrayCurve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationFloatArrayCurve._isInterpolationType = true;
}(), _AnimationFloatArrayCurve);
AnimationFloatArrayCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationFloatArrayCurve);

var _AnimationFloatCurve;
var AnimationFloatCurve = (_AnimationFloatCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationFloatCurve, AnimationCurve);
    function AnimationFloatCurve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = 0;
        return _this;
    }
    /**
   * @internal
   */ AnimationFloatCurve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = 0;
        owner.fixedPoseValue = 0;
        owner.baseEvaluateData.value = 0;
        owner.crossEvaluateData.value = 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._lerpValue = function _lerpValue(srcValue, destValue, crossWeight) {
        return srcValue + (destValue - srcValue) * crossWeight;
    };
    /**
   * @internal
   */ AnimationFloatCurve._additiveValue = function _additiveValue(value, weight, scource) {
        return scource += value * weight;
    };
    /**
   * @internal
   */ AnimationFloatCurve._subtractValue = function _subtractValue(src, base) {
        return src - base;
    };
    /**
   * @internal
   */ AnimationFloatCurve._getZeroValue = function _getZeroValue() {
        return 0;
    };
    /**
   * @internal
   */ AnimationFloatCurve._copyValue = function _copyValue(source) {
        return source;
    };
    /**
   * @internal
   */ AnimationFloatCurve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur) {
        var t0 = frame.outTangent;
        var t1 = nextFrame.inTangent;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
        } else {
            return frame.value;
        }
    };
    return AnimationFloatCurve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationFloatCurve._isReferenceType = false;
}(), function() {
    /** @internal */ _AnimationFloatCurve._isInterpolationType = true;
}(), _AnimationFloatCurve);
AnimationFloatCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationFloatCurve);

var _AnimationQuaternionCurve;
var AnimationQuaternionCurve = (_AnimationQuaternionCurve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationQuaternionCurve1, AnimationCurve);
    function AnimationQuaternionCurve1() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Quaternion();
        return _this;
    }
    /**
   * @internal
   */ AnimationQuaternionCurve1._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Quaternion();
        owner.fixedPoseValue = new Quaternion();
        owner.baseEvaluateData.value = new Quaternion();
        owner.crossEvaluateData.value = new Quaternion();
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Quaternion();
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._lerpValue = function _lerpValue(src, dest, weight, out) {
        Quaternion.slerp(src, dest, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._additiveValue = function _additiveValue(value, weight, out) {
        value.x = value.x * weight;
        value.y = value.y * weight;
        value.z = value.z * weight;
        value.normalize();
        out.multiply(value);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._subtractValue = function _subtractValue(src, base, out) {
        var conjugate = AnimationQuaternionCurve._tempConjugateQuat;
        Quaternion.conjugate(base, conjugate);
        Quaternion.multiply(conjugate, src, out);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 1);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._copyValue = function _copyValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationQuaternionCurve1._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
        } else {
            out.w = p0.w;
        }
        return out;
    };
    return AnimationQuaternionCurve1;
}(AnimationCurve), function() {
    /** @internal */ _AnimationQuaternionCurve._isInterpolationType = true;
}(), function() {
    /** @internal */ _AnimationQuaternionCurve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationQuaternionCurve._tempConjugateQuat = new Quaternion();
}(), _AnimationQuaternionCurve);
AnimationQuaternionCurve = __decorate$1([
    StaticInterfaceImplement()
], AnimationQuaternionCurve);

var _AnimationVector2Curve;
var AnimationVector2Curve = (_AnimationVector2Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector2Curve, AnimationCurve);
    function AnimationVector2Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector2();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector2Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector2();
        owner.fixedPoseValue = new Vector2();
        owner.baseEvaluateData.value = new Vector2();
        owner.crossEvaluateData.value = new Vector2();
    };
    /**
   * @internal
   */ AnimationVector2Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector2();
    };
    /**
   * @internal
   */ AnimationVector2Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector2.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector2.scale(value, weight, value);
        Vector2.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector2.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._copyValue = function _copyValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector2Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        return out;
    };
    return AnimationVector2Curve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationVector2Curve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationVector2Curve._isInterpolationType = true;
}(), _AnimationVector2Curve);
AnimationVector2Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector2Curve);

var _AnimationVector3Curve;
var AnimationVector3Curve = (_AnimationVector3Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector3Curve, AnimationCurve);
    function AnimationVector3Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector3();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector3Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector3();
        owner.fixedPoseValue = new Vector3();
        owner.baseEvaluateData.value = new Vector3();
        owner.crossEvaluateData.value = new Vector3();
    };
    /**
   * @internal
   */ AnimationVector3Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector3();
    };
    /**
   * @internal
   */ AnimationVector3Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector3.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._relativeBaseValue = function _relativeBaseValue(base, out) {
        Vector3.subtract(out, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector3.scale(value, weight, value);
        Vector3.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector3.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._copyValue = function _copyValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector3Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        return out;
    };
    return AnimationVector3Curve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationVector3Curve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationVector3Curve._isInterpolationType = true;
}(), _AnimationVector3Curve);
AnimationVector3Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector3Curve);

var _AnimationVector4Curve;
var AnimationVector4Curve = (_AnimationVector4Curve = /*#__PURE__*/ function(AnimationCurve) {
    _inherits$2(AnimationVector4Curve, AnimationCurve);
    function AnimationVector4Curve() {
        var _this;
        _this = AnimationCurve.call(this) || this;
        _this._evaluateData.value = new Vector4();
        return _this;
    }
    /**
   * @internal
   */ AnimationVector4Curve._initializeOwner = function _initializeOwner(owner) {
        owner.defaultValue = new Vector4();
        owner.fixedPoseValue = new Vector4();
        owner.baseEvaluateData.value = new Vector4();
        owner.crossEvaluateData.value = new Vector4();
    };
    /**
   * @internal
   */ AnimationVector4Curve._initializeLayerOwner = function _initializeLayerOwner(owner) {
        owner.finalValue = new Vector4();
    };
    /**
   * @internal
   */ AnimationVector4Curve._lerpValue = function _lerpValue(srcValue, destValue, weight, out) {
        Vector4.lerp(srcValue, destValue, weight, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._additiveValue = function _additiveValue(value, weight, out) {
        Vector4.scale(value, weight, value);
        Vector4.add(out, value, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._subtractValue = function _subtractValue(src, base, out) {
        Vector4.subtract(src, base, out);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._getZeroValue = function _getZeroValue(out) {
        out.set(0, 0, 0, 0);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._copyValue = function _copyValue(source, out) {
        out.copyFrom(source);
        return out;
    };
    /**
   * @internal
   */ AnimationVector4Curve._hermiteInterpolationValue = function _hermiteInterpolationValue(frame, nextFrame, t, dur, out) {
        var p0 = frame.value;
        var tan0 = frame.outTangent;
        var p1 = nextFrame.value;
        var tan1 = nextFrame.inTangent;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        var t0 = tan0.x, t1 = tan1.x;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
        } else {
            out.x = p0.x;
        }
        t0 = tan0.y, t1 = tan1.y;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
        } else {
            out.y = p0.y;
        }
        t0 = tan0.z, t1 = tan1.z;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
        } else {
            out.z = p0.z;
        }
        t0 = tan0.w, t1 = tan1.w;
        if (Number.isFinite(t0) && Number.isFinite(t1)) {
            out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
        } else {
            out.w = p0.w;
        }
        return out;
    };
    return AnimationVector4Curve;
}(AnimationCurve), function() {
    /** @internal */ _AnimationVector4Curve._isReferenceType = true;
}(), function() {
    /** @internal */ _AnimationVector4Curve._isInterpolationType = true;
}(), _AnimationVector4Curve);
AnimationVector4Curve = __decorate$1([
    StaticInterfaceImplement()
], AnimationVector4Curve);

/**
 * Animator culling mode.
 */ var AnimatorCullingMode;
(function(AnimatorCullingMode) {
    AnimatorCullingMode[AnimatorCullingMode[/** Disable Culling. */ "None"] = 0] = "None";
    AnimatorCullingMode[AnimatorCullingMode[/** Completely disabled when renderers are all culled. */ "Complete"] = 1] = "Complete";
})(AnimatorCullingMode || (AnimatorCullingMode = {}));

var AnimatorLayerBlendingMode;
(function(AnimatorLayerBlendingMode) {
    AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Override"] = 0] = "Override";
    AnimatorLayerBlendingMode[AnimatorLayerBlendingMode["Additive"] = 1] = "Additive";
})(AnimatorLayerBlendingMode || (AnimatorLayerBlendingMode = {}));

/**
 * @internal
 */ var AnimatorStatePlayState;
(function(AnimatorStatePlayState) {
    AnimatorStatePlayState[AnimatorStatePlayState["UnStarted"] = 0] = "UnStarted";
    AnimatorStatePlayState[AnimatorStatePlayState["Playing"] = 1] = "Playing";
    AnimatorStatePlayState[AnimatorStatePlayState["Finished"] = 2] = "Finished";
})(AnimatorStatePlayState || (AnimatorStatePlayState = {}));

/**
 * Layer state.
 */ var LayerState;
(function(LayerState) {
    LayerState[LayerState[/** Standby state. */ "Standby"] = 0] = "Standby";
    LayerState[LayerState[/** Playing state. */ "Playing"] = 1] = "Playing";
    LayerState[LayerState[/** CrossFading state. */ "CrossFading"] = 2] = "CrossFading";
    LayerState[LayerState[/** FixedCrossFading state. */ "FixedCrossFading"] = 3] = "FixedCrossFading";
    LayerState[LayerState[/** Finished state. */ "Finished"] = 4] = "Finished";
})(LayerState || (LayerState = {}));

/**
 * @internal
 */ var AnimationEventHandler = /*#__PURE__*/ function() {
    function AnimationEventHandler() {
        this.handlers = [];
    }
    var _proto = AnimationEventHandler.prototype;
    _proto.dispose = function dispose() {};
    return AnimationEventHandler;
}();

/**
 * Transitions define when and how the state machine switch from on state to another. AnimatorTransition always originate from a StateMachine or a StateMachine entry.
 */ var AnimatorStateTransition = function AnimatorStateTransition() {
    /** The duration of the transition. This is represented in normalized time. */ this.duration = 0;
    /** The time at which the destination state will start. This is represented in normalized time. */ this.offset = 0;
    /** ExitTime represents the exact time at which the transition can take effect. This is represented in normalized time. */ this.exitTime = 1;
};

/**
 * Animation wrap mode.
 */ var WrapMode;
(function(WrapMode) {
    WrapMode[WrapMode[/** Play once */ "Once"] = 0] = "Once";
    WrapMode[WrapMode[/** Loop play */ "Loop"] = 1] = "Loop";
})(WrapMode || (WrapMode = {}));

/**
 * @internal
 */ var AnimatorStatePlayData = /*#__PURE__*/ function() {
    function AnimatorStatePlayData() {}
    var _proto = AnimatorStatePlayData.prototype;
    _proto.reset = function reset(state, stateData, offsetFrameTime) {
        this.state = state;
        this.frameTime = offsetFrameTime;
        this.stateData = stateData;
        this.playState = AnimatorStatePlayState.UnStarted;
        this.clipTime = state.clipStartTime * state.clip.length;
        this.currentEventIndex = 0;
    };
    _proto.update = function update(isBackwards) {
        var state = this.state;
        var time = this.frameTime;
        var duration = state._getDuration();
        this.playState = AnimatorStatePlayState.Playing;
        if (state.wrapMode === WrapMode.Loop) {
            time = duration ? time % duration : 0;
        } else {
            if (Math.abs(time) > duration) {
                time = time < 0 ? -duration : duration;
                this.playState = AnimatorStatePlayState.Finished;
            }
        }
        if (isBackwards && time === 0) {
            this.clipTime = state.clipEndTime * state.clip.length;
        } else {
            time < 0 && (time += duration);
            this.clipTime = time + state.clipStartTime * state.clip.length;
        }
    };
    return AnimatorStatePlayData;
}();

/**
 * @internal
 */ var AnimatorLayerData = /*#__PURE__*/ function() {
    function AnimatorLayerData() {
        this.curveOwnerPool = Object.create(null);
        this.animatorStateDataMap = {};
        this.srcPlayData = new AnimatorStatePlayData();
        this.destPlayData = new AnimatorStatePlayData();
        this.layerState = LayerState.Standby;
        this.crossCurveMark = 0;
        this.manuallyTransition = new AnimatorStateTransition();
        this.crossLayerOwnerCollection = [];
    }
    var _proto = AnimatorLayerData.prototype;
    _proto.switchPlayData = function switchPlayData() {
        var srcPlayData = this.destPlayData;
        var switchTemp = this.srcPlayData;
        this.srcPlayData = srcPlayData;
        this.destPlayData = switchTemp;
    };
    return AnimatorLayerData;
}();

/**
 * @internal
 */ var AnimatorStateData = function AnimatorStateData() {
    this.curveLayerOwner = [];
    this.eventHandlers = [];
};

/**
 * The controller of the animation system.
 */ var Animator = /*#__PURE__*/ function(Component) {
    _inherits$2(Animator, Component);
    function Animator(entity) {
        var _this;
        _this = Component.call(this, entity) || this;
        /** Culling mode of this Animator. */ _this.cullingMode = AnimatorCullingMode.None;
        /** The playback speed of the Animator, 1.0 is normal playback speed. */ _this.speed = 1.0;
        _this._updateMark = 0;
        _this._animatorLayersData = [];
        _this._curveOwnerPool = Object.create(null);
        _this._animationEventHandlerPool = new ClassPool(AnimationEventHandler);
        _this._tempAnimatorStateInfo = {
            layerIndex: -1,
            state: null
        };
        _this._controlledRenderers = [];
        return _this;
    }
    var _proto = Animator.prototype;
    /**
   * Play a state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */ _proto.play = function play(stateName, layerIndex, normalizedTimeOffset) {
        if (layerIndex === void 0) layerIndex = -1;
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        var _this__controllerUpdateFlag;
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._reset();
        }
        var stateInfo = this._getAnimatorStateInfo(stateName, layerIndex);
        var state = stateInfo.state, playLayerIndex = stateInfo.layerIndex;
        if (!state) {
            return;
        }
        if (!state.clip) {
            Logger.warn("The state named " + stateName + " has no AnimationClip data.");
            return;
        }
        var animatorLayerData = this._getAnimatorLayerData(playLayerIndex);
        var animatorStateData = this._getAnimatorStateData(stateName, state, animatorLayerData, playLayerIndex);
        this._preparePlay(animatorLayerData, state);
        animatorLayerData.layerState = LayerState.Playing;
        animatorLayerData.srcPlayData.reset(state, animatorStateData, state._getDuration() * normalizedTimeOffset);
    };
    /**
   * Create a cross fade from the current state to another state.
   * @param stateName - The state name
   * @param normalizedTransitionDuration - The duration of the transition (normalized)
   * @param layerIndex - The layer index(default -1). If layer is -1, play the first state with the given state name
   * @param normalizedTimeOffset - The time offset between 0 and 1(default 0)
   */ _proto.crossFade = function crossFade(stateName, normalizedTransitionDuration, layerIndex, normalizedTimeOffset) {
        if (layerIndex === void 0) layerIndex = -1;
        if (normalizedTimeOffset === void 0) normalizedTimeOffset = 0;
        var _this__controllerUpdateFlag;
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._reset();
        }
        var _this__getAnimatorStateInfo = this._getAnimatorStateInfo(stateName, layerIndex), state = _this__getAnimatorStateInfo.state, playLayerIndex = _this__getAnimatorStateInfo.layerIndex;
        var manuallyTransition = this._getAnimatorLayerData(playLayerIndex).manuallyTransition;
        manuallyTransition.duration = normalizedTransitionDuration;
        manuallyTransition.offset = normalizedTimeOffset;
        manuallyTransition.destinationState = state;
        this._crossFadeByTransition(manuallyTransition, layerIndex);
    };
    /**
   * Evaluates the animator component based on deltaTime.
   * @param deltaTime - The deltaTime when the animation update
   */ _proto.update = function update(deltaTime) {
        var _this__controllerUpdateFlag;
        var animationUpdate;
        if (this.cullingMode === AnimatorCullingMode.Complete) {
            animationUpdate = false;
            var controlledRenderers = this._controlledRenderers;
            for(var i = 0, n = controlledRenderers.length; i < n; i++){
                if (!controlledRenderers[i].isCulled) {
                    animationUpdate = true;
                    break;
                }
            }
        } else {
            animationUpdate = true;
        }
        var _this = this, animatorController = _this._animatorController;
        if (!animatorController) {
            return;
        }
        if ((_this__controllerUpdateFlag = this._controllerUpdateFlag) == null ? void 0 : _this__controllerUpdateFlag.flag) {
            this._checkAutoPlay();
            return;
        }
        deltaTime *= this.speed;
        this._updateMark++;
        for(var i1 = 0, n1 = animatorController.layers.length; i1 < n1; i1++){
            var animatorLayerData = this._getAnimatorLayerData(i1);
            if (animatorLayerData.layerState === LayerState.Standby) {
                continue;
            }
            this._updateLayer(i1, i1 === 0, deltaTime, animationUpdate);
        }
    };
    /**
   * Get the playing state from the target layerIndex.
   * @param layerIndex - The layer index
   */ _proto.getCurrentAnimatorState = function getCurrentAnimatorState(layerIndex) {
        var _this__animatorLayersData_layerIndex, _this__animatorLayersData_layerIndex_srcPlayData;
        return (_this__animatorLayersData_layerIndex = this._animatorLayersData[layerIndex]) == null ? void 0 : (_this__animatorLayersData_layerIndex_srcPlayData = _this__animatorLayersData_layerIndex.srcPlayData) == null ? void 0 : _this__animatorLayersData_layerIndex_srcPlayData.state;
    };
    /**
   * Get the state by name.
   * @param stateName - The state name
   * @param layerIndex - The layer index(default -1). If layer is -1, find the first state with the given state name
   */ _proto.findAnimatorState = function findAnimatorState(stateName, layerIndex) {
        if (layerIndex === void 0) layerIndex = -1;
        return this._getAnimatorStateInfo(stateName, layerIndex).state;
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        this.engine._componentsManager.addOnUpdateAnimations(this);
        this.animatorController && this._checkAutoPlay();
        this._entity.getComponentsIncludeChildren(Renderer, this._controlledRenderers);
    };
    /**
   * @internal
   */ _proto._onDisable = function _onDisable() {
        this.engine._componentsManager.removeOnUpdateAnimations(this);
    };
    /**
   * @internal
   */ _proto._reset = function _reset() {
        var _this = this, animationCurveOwners = _this._curveOwnerPool;
        for(var instanceId in animationCurveOwners){
            var propertyOwners = animationCurveOwners[instanceId];
            for(var property in propertyOwners){
                var owner = propertyOwners[property];
                owner.revertDefaultValue();
            }
        }
        this._animatorLayersData.length = 0;
        this._curveOwnerPool = {};
        this._animationEventHandlerPool.resetPool();
        if (this._controllerUpdateFlag) {
            this._controllerUpdateFlag.flag = false;
        }
    };
    _proto._getAnimatorStateInfo = function _getAnimatorStateInfo(stateName, layerIndex) {
        var _this = this, animatorController = _this._animatorController, stateInfo = _this._tempAnimatorStateInfo;
        var state = null;
        if (animatorController) {
            var layers = animatorController.layers;
            if (layerIndex === -1) {
                for(var i = 0, n = layers.length; i < n; i++){
                    state = layers[i].stateMachine.findStateByName(stateName);
                    if (state) {
                        layerIndex = i;
                        break;
                    }
                }
            } else {
                state = layers[layerIndex].stateMachine.findStateByName(stateName);
            }
        }
        stateInfo.layerIndex = layerIndex;
        stateInfo.state = state;
        return stateInfo;
    };
    _proto._getAnimatorStateData = function _getAnimatorStateData(stateName, animatorState, animatorLayerData, layerIndex) {
        var animatorStateDataMap = animatorLayerData.animatorStateDataMap;
        var animatorStateData = animatorStateDataMap[stateName];
        if (!animatorStateData) {
            animatorStateData = new AnimatorStateData();
            animatorStateDataMap[stateName] = animatorStateData;
            this._saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex);
            this._saveAnimatorEventHandlers(animatorState, animatorStateData);
        }
        return animatorStateData;
    };
    _proto._saveAnimatorStateData = function _saveAnimatorStateData(animatorState, animatorStateData, animatorLayerData, layerIndex) {
        var _this = this, entity = _this.entity, curveOwnerPool = _this._curveOwnerPool;
        var curveLayerOwner = animatorStateData.curveLayerOwner;
        var _animatorState_clip = animatorState.clip, curves = _animatorState_clip._curveBindings;
        var layerCurveOwnerPool = animatorLayerData.curveOwnerPool;
        for(var i = curves.length - 1; i >= 0; i--){
            var curve = curves[i];
            var targetEntity = curve.relativePath === "" ? entity : entity.findByPath(curve.relativePath);
            if (targetEntity) {
                var _curveOwnerPool, _instanceId, _propertyOwners, _property, _layerCurveOwnerPool, _instanceId1, _layerPropertyOwners, _property1;
                var property = curve.property;
                var instanceId = targetEntity.instanceId;
                // Get owner
                var propertyOwners = (_curveOwnerPool = curveOwnerPool)[_instanceId = instanceId] || (_curveOwnerPool[_instanceId] = Object.create(null));
                var owner = (_propertyOwners = propertyOwners)[_property = property] || (_propertyOwners[_property] = curve._createCurveOwner(targetEntity));
                // Get layer owner
                var layerPropertyOwners = (_layerCurveOwnerPool = layerCurveOwnerPool)[_instanceId1 = instanceId] || (_layerCurveOwnerPool[_instanceId1] = Object.create(null));
                var layerOwner = (_layerPropertyOwners = layerPropertyOwners)[_property1 = property] || (_layerPropertyOwners[_property1] = curve._createCurveLayerOwner(owner));
                curveLayerOwner[i] = layerOwner;
            } else {
                curveLayerOwner[i] = null;
                Logger.warn("The entity don't have the child entity which path is " + curve.relativePath + ".");
            }
        }
    };
    _proto._saveAnimatorEventHandlers = function _saveAnimatorEventHandlers(state, animatorStateData) {
        var eventHandlerPool = this._animationEventHandlerPool;
        var scripts = this._entity._scripts;
        var scriptCount = scripts.length;
        var eventHandlers = animatorStateData.eventHandlers;
        var events = state.clip.events;
        eventHandlers.length = 0;
        for(var i = 0, n = events.length; i < n; i++){
            var event = events[i];
            var eventHandler = eventHandlerPool.getFromPool();
            var funcName = event.functionName;
            var handlers = eventHandler.handlers;
            eventHandler.event = event;
            handlers.length = 0;
            for(var j = scriptCount - 1; j >= 0; j--){
                var handler = scripts.get(j)[funcName];
                handler && handlers.push(handler);
            }
            eventHandlers.push(eventHandler);
        }
    };
    _proto._clearCrossData = function _clearCrossData(animatorLayerData) {
        animatorLayerData.crossCurveMark++;
        animatorLayerData.crossLayerOwnerCollection.length = 0;
    };
    _proto._addCrossOwner = function _addCrossOwner(animatorLayerData, layerOwner, curCurveIndex, nextCurveIndex) {
        layerOwner.crossSrcCurveIndex = curCurveIndex;
        layerOwner.crossDestCurveIndex = nextCurveIndex;
        animatorLayerData.crossLayerOwnerCollection.push(layerOwner);
    };
    _proto._prepareCrossFading = function _prepareCrossFading(animatorLayerData) {
        // Add src cross curve data.
        this._prepareSrcCrossData(animatorLayerData, false);
        // Add dest cross curve data.
        this._prepareDestCrossData(animatorLayerData, false);
    };
    _proto._prepareStandbyCrossFading = function _prepareStandbyCrossFading(animatorLayerData) {
        // Standby have two sub state, one is never play, one is finished, never play srcPlayData.state is null.
        animatorLayerData.srcPlayData.state && this._prepareSrcCrossData(animatorLayerData, true);
        // Add dest cross curve data.
        this._prepareDestCrossData(animatorLayerData, true);
    };
    _proto._prepareFixedPoseCrossFading = function _prepareFixedPoseCrossFading(animatorLayerData) {
        var crossLayerOwnerCollection = animatorLayerData.crossLayerOwnerCollection;
        // Save current cross curve data owner fixed pose.
        for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
            var layerOwner = crossLayerOwnerCollection[i];
            if (!layerOwner) continue;
            layerOwner.curveOwner.saveFixedPoseValue();
            // Reset destCurveIndex When fixed pose crossFading again.
            layerOwner.crossDestCurveIndex = -1;
        }
        // prepare dest AnimatorState cross data.
        this._prepareDestCrossData(animatorLayerData, true);
    };
    _proto._prepareSrcCrossData = function _prepareSrcCrossData(animatorLayerData, saveFixed) {
        var curveLayerOwner = animatorLayerData.srcPlayData.stateData.curveLayerOwner;
        for(var i = curveLayerOwner.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            if (!layerOwner) continue;
            layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
            saveFixed && layerOwner.curveOwner.saveFixedPoseValue();
            this._addCrossOwner(animatorLayerData, layerOwner, i, -1);
        }
    };
    _proto._prepareDestCrossData = function _prepareDestCrossData(animatorLayerData, saveFixed) {
        var curveLayerOwner = animatorLayerData.destPlayData.stateData.curveLayerOwner;
        for(var i = curveLayerOwner.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            if (!layerOwner) continue;
            if (layerOwner.crossCurveMark === animatorLayerData.crossCurveMark) {
                layerOwner.crossDestCurveIndex = i;
            } else {
                var owner = layerOwner.curveOwner;
                saveFixed && owner.saveFixedPoseValue();
                layerOwner.crossCurveMark = animatorLayerData.crossCurveMark;
                this._addCrossOwner(animatorLayerData, layerOwner, -1, i);
            }
        }
    };
    _proto._getAnimatorLayerData = function _getAnimatorLayerData(layerIndex) {
        var animatorLayerData = this._animatorLayersData[layerIndex];
        animatorLayerData || (this._animatorLayersData[layerIndex] = animatorLayerData = new AnimatorLayerData());
        return animatorLayerData;
    };
    _proto._updateLayer = function _updateLayer(layerIndex, firstLayer, deltaTime, aniUpdate) {
        var _this__animatorController_layers_layerIndex = this._animatorController.layers[layerIndex], blendingMode = _this__animatorController_layers_layerIndex.blendingMode, weight = _this__animatorController_layers_layerIndex.weight;
        var layerData = this._animatorLayersData[layerIndex];
        var srcPlayData = layerData.srcPlayData, destPlayData = layerData.destPlayData, crossFadeTransitionInfo = layerData.crossFadeTransition;
        var additive = blendingMode === AnimatorLayerBlendingMode.Additive;
        firstLayer && (weight = 1.0);
        //@todo: All situations should be checked, optimizations will follow later.
        layerData.layerState !== LayerState.FixedCrossFading && this._checkTransition(srcPlayData, crossFadeTransitionInfo, layerIndex);
        switch(layerData.layerState){
            case LayerState.Playing:
                this._updatePlayingState(srcPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
                break;
            case LayerState.FixedCrossFading:
                this._updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
                break;
            case LayerState.CrossFading:
                this._updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, deltaTime, additive, aniUpdate);
                break;
            case LayerState.Finished:
                this._updateFinishedState(srcPlayData, weight, additive, aniUpdate);
                break;
        }
    };
    _proto._updatePlayingState = function _updatePlayingState(playData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
        var _playData_stateData = playData.stateData, curveLayerOwner = _playData_stateData.curveLayerOwner, eventHandlers = _playData_stateData.eventHandlers;
        var state = playData.state, lastPlayState = playData.playState, lastClipTime = playData.clipTime;
        var _state_clip = state.clip, curveBindings = _state_clip._curveBindings;
        playData.update(this.speed < 0);
        var clipTime = playData.clipTime, playState = playData.playState;
        var finished = playState === AnimatorStatePlayState.Finished;
        if (aniUpdate || finished) {
            for(var i = curveBindings.length - 1; i >= 0; i--){
                var layerOwner = curveLayerOwner[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner) continue;
                var curve = curveBindings[i].curve;
                if (curve.keys.length) {
                    this._checkRevertOwner(owner, additive);
                    var value = owner.evaluateValue(curve, clipTime, additive);
                    aniUpdate && owner.applyValue(value, weight, additive);
                    finished && layerOwner.saveFinalValue();
                }
            }
        }
        playData.frameTime += state.speed * delta;
        if (playState === AnimatorStatePlayState.Finished) {
            layerData.layerState = LayerState.Finished;
        }
        eventHandlers.length && this._fireAnimationEvents(playData, eventHandlers, lastClipTime, clipTime);
        if (lastPlayState === AnimatorStatePlayState.UnStarted) {
            this._callAnimatorScriptOnEnter(state, layerIndex);
        }
        if (playState === AnimatorStatePlayState.Finished) {
            this._callAnimatorScriptOnExit(state, layerIndex);
        } else {
            this._callAnimatorScriptOnUpdate(state, layerIndex);
        }
    };
    _proto._updateCrossFade = function _updateCrossFade(srcPlayData, destPlayData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
        var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
        var _srcPlayData_state_clip = srcPlayData.state.clip, srcCurves = _srcPlayData_state_clip._curveBindings;
        var srcState = srcPlayData.state, srcStateData = srcPlayData.stateData, lastSrcPlayState = srcPlayData.playState;
        var srcEventHandlers = srcStateData.eventHandlers;
        var destState = destPlayData.state, destStateData = destPlayData.stateData, lastDstPlayState = destPlayData.playState;
        var destEventHandlers = destStateData.eventHandlers;
        var _destState_clip = destState.clip, destCurves = _destState_clip._curveBindings;
        var lastSrcClipTime = srcPlayData.clipTime;
        var lastDestClipTime = destPlayData.clipTime;
        var duration = destState._getDuration() * layerData.crossFadeTransition.duration;
        var crossWeight = Math.abs(destPlayData.frameTime) / duration;
        (crossWeight >= 1.0 || duration === 0) && (crossWeight = 1.0);
        srcPlayData.update(this.speed < 0);
        destPlayData.update(this.speed < 0);
        var srcClipTime = srcPlayData.clipTime, srcPlayState = srcPlayData.playState;
        var destClipTime = destPlayData.clipTime, destPlayState = destPlayData.playState;
        var finished = destPlayData.playState === AnimatorStatePlayState.Finished;
        if (aniUpdate || finished) {
            for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
                var layerOwner = crossLayerOwnerCollection[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner) continue;
                var srcCurveIndex = layerOwner.crossSrcCurveIndex;
                var destCurveIndex = layerOwner.crossDestCurveIndex;
                this._checkRevertOwner(owner, additive);
                var value = owner.evaluateCrossFadeValue(srcCurveIndex >= 0 ? srcCurves[srcCurveIndex].curve : null, destCurveIndex >= 0 ? destCurves[destCurveIndex].curve : null, srcClipTime, destClipTime, crossWeight, additive);
                aniUpdate && owner.applyValue(value, weight, additive);
                finished && layerOwner.saveFinalValue();
            }
        }
        this._updateCrossFadeData(layerData, crossWeight, delta, false);
        srcEventHandlers.length && this._fireAnimationEvents(srcPlayData, srcEventHandlers, lastSrcClipTime, srcClipTime);
        destEventHandlers.length && this._fireAnimationEvents(destPlayData, destEventHandlers, lastDestClipTime, destClipTime);
        if (lastSrcPlayState === AnimatorStatePlayState.UnStarted) {
            this._callAnimatorScriptOnEnter(srcState, layerIndex);
        }
        if (crossWeight === 1 || srcPlayState === AnimatorStatePlayState.Finished) {
            this._callAnimatorScriptOnExit(srcState, layerIndex);
        } else {
            this._callAnimatorScriptOnUpdate(srcState, layerIndex);
        }
        if (lastDstPlayState === AnimatorStatePlayState.UnStarted) {
            this._callAnimatorScriptOnEnter(destState, layerIndex);
        }
        if (destPlayState === AnimatorStatePlayState.Finished) {
            this._callAnimatorScriptOnExit(destState, layerIndex);
        } else {
            this._callAnimatorScriptOnUpdate(destState, layerIndex);
        }
    };
    _proto._updateCrossFadeFromPose = function _updateCrossFadeFromPose(destPlayData, layerData, layerIndex, weight, delta, additive, aniUpdate) {
        var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
        var state = destPlayData.state, stateData = destPlayData.stateData, lastPlayState = destPlayData.playState;
        var eventHandlers = stateData.eventHandlers;
        var _state_clip = state.clip, curveBindings = _state_clip._curveBindings;
        var lastDestClipTime = destPlayData.clipTime;
        var duration = state._getDuration() * layerData.crossFadeTransition.duration;
        var crossWeight = Math.abs(destPlayData.frameTime) / duration;
        (crossWeight >= 1.0 || duration === 0) && (crossWeight = 1.0);
        destPlayData.update(this.speed < 0);
        var playState = destPlayData.playState;
        this._updateCrossFadeData(layerData, crossWeight, delta, true);
        var destClipTime = destPlayData.clipTime;
        var finished = playState === AnimatorStatePlayState.Finished;
        // When the animator is culled (aniUpdate=false), if the play state has finished, the final value needs to be calculated and saved to be applied directly.
        if (aniUpdate || finished) {
            for(var i = crossLayerOwnerCollection.length - 1; i >= 0; i--){
                var layerOwner = crossLayerOwnerCollection[i];
                var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
                if (!owner) continue;
                var curveIndex = layerOwner.crossDestCurveIndex;
                this._checkRevertOwner(owner, additive);
                var value = layerOwner.curveOwner.crossFadeFromPoseAndApplyValue(curveIndex >= 0 ? curveBindings[curveIndex].curve : null, destClipTime, crossWeight, additive);
                aniUpdate && owner.applyValue(value, weight, additive);
                finished && layerOwner.saveFinalValue();
            }
        }
        //@todo: srcState is missing the judgment of the most recent period."
        eventHandlers.length && this._fireAnimationEvents(destPlayData, eventHandlers, lastDestClipTime, destClipTime);
        if (lastPlayState === AnimatorStatePlayState.UnStarted) {
            this._callAnimatorScriptOnEnter(state, layerIndex);
        }
        if (playState === AnimatorStatePlayState.Finished) {
            this._callAnimatorScriptOnExit(state, layerIndex);
        } else {
            this._callAnimatorScriptOnUpdate(state, layerIndex);
        }
    };
    _proto._updateFinishedState = function _updateFinishedState(playData, weight, additive, aniUpdate) {
        if (!aniUpdate) {
            return;
        }
        var curveLayerOwner = playData.stateData.curveLayerOwner;
        var _playData_state_clip = playData.state.clip, curveBindings = _playData_state_clip._curveBindings;
        for(var i = curveBindings.length - 1; i >= 0; i--){
            var layerOwner = curveLayerOwner[i];
            var owner = layerOwner == null ? void 0 : layerOwner.curveOwner;
            if (!owner) continue;
            this._checkRevertOwner(owner, additive);
            owner.applyValue(layerOwner.finalValue, weight, additive);
        }
    };
    _proto._updateCrossFadeData = function _updateCrossFadeData(layerData, crossWeight, delta, fixed) {
        var destPlayData = layerData.destPlayData;
        destPlayData.frameTime += destPlayData.state.speed * delta;
        if (crossWeight === 1.0) {
            if (destPlayData.playState === AnimatorStatePlayState.Finished) {
                layerData.layerState = LayerState.Finished;
            } else {
                layerData.layerState = LayerState.Playing;
            }
            layerData.switchPlayData();
            layerData.crossFadeTransition = null;
        } else {
            fixed || (layerData.srcPlayData.frameTime += layerData.srcPlayData.state.speed * delta);
        }
    };
    _proto._preparePlay = function _preparePlay(layerData, playState) {
        if (layerData.layerState === LayerState.Playing) {
            var srcPlayData = layerData.srcPlayData;
            if (srcPlayData.state !== playState) {
                var curveLayerOwner = srcPlayData.stateData.curveLayerOwner;
                for(var i = curveLayerOwner.length - 1; i >= 0; i--){
                    var _curveLayerOwner_i;
                    (_curveLayerOwner_i = curveLayerOwner[i]) == null ? void 0 : _curveLayerOwner_i.curveOwner.revertDefaultValue();
                }
            }
        } else {
            // layerState is CrossFading, FixedCrossFading, Standby, Finished
            var crossLayerOwnerCollection = layerData.crossLayerOwnerCollection;
            for(var i1 = crossLayerOwnerCollection.length - 1; i1 >= 0; i1--){
                crossLayerOwnerCollection[i1].curveOwner.revertDefaultValue();
            }
        }
    };
    _proto._checkTransition = function _checkTransition(stateData, crossFadeTransition, layerIndex) {
        var state = stateData.state, clipTime = stateData.clipTime;
        var transitions = state.transitions;
        var duration = state._getDuration();
        for(var i = 0, n = transitions.length; i < n; ++i){
            var transition = transitions[i];
            if (duration * transition.exitTime <= clipTime) {
                crossFadeTransition !== transition && this._crossFadeByTransition(transition, layerIndex);
            }
        }
    };
    _proto._crossFadeByTransition = function _crossFadeByTransition(transition, layerIndex) {
        var name = transition.destinationState.name;
        var stateInfo = this._getAnimatorStateInfo(name, layerIndex);
        var crossState = stateInfo.state, playLayerIndex = stateInfo.layerIndex;
        if (!crossState) {
            return;
        }
        if (!crossState.clip) {
            Logger.warn("The state named " + name + " has no AnimationClip data.");
            return;
        }
        var animatorLayerData = this._getAnimatorLayerData(playLayerIndex);
        var layerState = animatorLayerData.layerState;
        var destPlayData = animatorLayerData.destPlayData;
        var animatorStateData = this._getAnimatorStateData(name, crossState, animatorLayerData, playLayerIndex);
        var duration = crossState._getDuration();
        var offset = duration * transition.offset;
        destPlayData.reset(crossState, animatorStateData, offset);
        switch(layerState){
            case LayerState.Standby:
            case LayerState.Finished:
                animatorLayerData.layerState = LayerState.FixedCrossFading;
                this._clearCrossData(animatorLayerData);
                this._prepareStandbyCrossFading(animatorLayerData);
                break;
            case LayerState.Playing:
                animatorLayerData.layerState = LayerState.CrossFading;
                this._clearCrossData(animatorLayerData);
                this._prepareCrossFading(animatorLayerData);
                break;
            case LayerState.CrossFading:
                animatorLayerData.layerState = LayerState.FixedCrossFading;
                this._prepareFixedPoseCrossFading(animatorLayerData);
                break;
            case LayerState.FixedCrossFading:
                this._prepareFixedPoseCrossFading(animatorLayerData);
                break;
        }
        animatorLayerData.crossFadeTransition = transition;
    };
    _proto._fireAnimationEvents = function _fireAnimationEvents(playState, eventHandlers, lastClipTime, clipTime) {
        var state = playState.state;
        var clipDuration = state.clip.length;
        if (this.speed >= 0) {
            if (clipTime < lastClipTime) {
                this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipEndTime * clipDuration);
                playState.currentEventIndex = 0;
                this._fireSubAnimationEvents(playState, eventHandlers, state.clipStartTime * clipDuration, clipTime);
            } else {
                this._fireSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
            }
        } else {
            if (clipTime > lastClipTime) {
                this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, state.clipStartTime * clipDuration);
                playState.currentEventIndex = eventHandlers.length - 1;
                this._fireBackwardSubAnimationEvents(playState, eventHandlers, state.clipEndTime * clipDuration, clipTime);
            } else {
                this._fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, clipTime);
            }
        }
    };
    _proto._fireSubAnimationEvents = function _fireSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for(var n = eventHandlers.length; eventIndex < n; eventIndex++){
            var eventHandler = eventHandlers[eventIndex];
            var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
            if (time > curClipTime) {
                break;
            }
            var handlers = eventHandler.handlers;
            if (time >= lastClipTime) {
                for(var j = handlers.length - 1; j >= 0; j--){
                    handlers[j](parameter);
                }
                playState.currentEventIndex = Math.min(eventIndex + 1, n - 1);
            }
        }
    };
    _proto._fireBackwardSubAnimationEvents = function _fireBackwardSubAnimationEvents(playState, eventHandlers, lastClipTime, curClipTime) {
        var eventIndex = playState.currentEventIndex;
        for(; eventIndex >= 0; eventIndex--){
            var eventHandler = eventHandlers[eventIndex];
            var _eventHandler_event = eventHandler.event, time = _eventHandler_event.time, parameter = _eventHandler_event.parameter;
            if (time < curClipTime) {
                break;
            }
            if (time <= lastClipTime) {
                var handlers = eventHandler.handlers;
                for(var j = handlers.length - 1; j >= 0; j--){
                    handlers[j](parameter);
                }
                playState.currentEventIndex = Math.max(eventIndex - 1, 0);
            }
        }
    };
    _proto._callAnimatorScriptOnEnter = function _callAnimatorScriptOnEnter(state, layerIndex) {
        var scripts = state._onStateEnterScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateEnter(this, state, layerIndex);
        }
    };
    _proto._callAnimatorScriptOnUpdate = function _callAnimatorScriptOnUpdate(state, layerIndex) {
        var scripts = state._onStateUpdateScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateUpdate(this, state, layerIndex);
        }
    };
    _proto._callAnimatorScriptOnExit = function _callAnimatorScriptOnExit(state, layerIndex) {
        var scripts = state._onStateExitScripts;
        for(var i = 0, n = scripts.length; i < n; i++){
            scripts[i].onStateExit(this, state, layerIndex);
        }
    };
    _proto._checkAutoPlay = function _checkAutoPlay() {
        var layers = this._animatorController.layers;
        for(var i = 0, n = layers.length; i < n; ++i){
            var stateMachine = layers[i].stateMachine;
            if (stateMachine == null ? void 0 : stateMachine.defaultState) {
                this.play(stateMachine.defaultState.name, i);
            }
        }
    };
    _proto._checkRevertOwner = function _checkRevertOwner(owner, additive) {
        if (additive && owner.updateMark !== this._updateMark) {
            owner.revertDefaultValue();
        }
        owner.updateMark = this._updateMark;
    };
    _create_class$3(Animator, [
        {
            key: "animatorController",
            get: /**
   * All layers from the AnimatorController which belongs this Animator.
   */ function get() {
                return this._animatorController;
            },
            set: function set(animatorController) {
                if (animatorController !== this._animatorController) {
                    this._reset();
                    this._controllerUpdateFlag && this._controllerUpdateFlag.destroy();
                    this._controllerUpdateFlag = animatorController && animatorController._registerChangeFlag();
                    this._animatorController = animatorController;
                }
            }
        }
    ]);
    return Animator;
}(Component);
__decorate$1([
    assignmentClone
], Animator.prototype, "speed", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_controllerUpdateFlag", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_updateMark", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_animatorLayersData", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_curveOwnerPool", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_animationEventHandlerPool", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_tempAnimatorStateInfo", void 0);
__decorate$1([
    ignoreClone
], Animator.prototype, "_controlledRenderers", void 0);

/**
 * Store the data for Animator playback.
 */ var AnimatorController = /*#__PURE__*/ function() {
    function AnimatorController() {
        this._updateFlagManager = new UpdateFlagManager();
        this._layers = [];
        this._layersMap = {};
    }
    var _proto = AnimatorController.prototype;
    /**
   * Get the layer by name.
   * @param name - The layer's name.
   */ _proto.findLayerByName = function findLayerByName(name) {
        return this._layersMap[name];
    };
    /**
   * Add a layer to the controller.
   * @param layer - The layer to add
   */ _proto.addLayer = function addLayer(layer) {
        this._layers.push(layer);
        this._layersMap[layer.name] = layer;
        this._updateFlagManager.dispatch();
    };
    /**
   * Remove a layer from the controller.
   * @param layerIndex - The index of the AnimatorLayer
   */ _proto.removeLayer = function removeLayer(layerIndex) {
        var theLayer = this.layers[layerIndex];
        this._layers.splice(layerIndex, 1);
        delete this._layersMap[theLayer.name];
        this._updateFlagManager.dispatch();
    };
    /**
   * Clear layers.
   */ _proto.clearLayers = function clearLayers() {
        this._layers.length = 0;
        for(var name in this._layersMap){
            delete this._layersMap[name];
        }
        this._updateFlagManager.dispatch();
    };
    /**
   * @internal
   */ _proto._registerChangeFlag = function _registerChangeFlag() {
        return this._updateFlagManager.createFlag(BoolUpdateFlag);
    };
    _create_class$3(AnimatorController, [
        {
            key: "layers",
            get: /**
   * The layers in the controller.
   */ function get() {
                return this._layers;
            }
        }
    ]);
    return AnimatorController;
}();

/**
 * The Animation Layer contains a state machine that controls animations of a model or part of it.
 */ var AnimatorControllerLayer = function AnimatorControllerLayer(name) {
    this.name = name;
    this./** The blending weight that the layers has. It is not taken into account for the first layer. */ weight = 1.0;
    this./** The blending mode used by the layer. It is not taken into account for the first layer. */ blendingMode = AnimatorLayerBlendingMode.Override;
};

/**
 * StateMachineScript is a component that can be added to a animator state. It's the base class every script on a state derives from.
 */ var StateMachineScript = /*#__PURE__*/ function() {
    function StateMachineScript() {
        /** @internal */ this._destroyed = false;
    }
    var _proto = StateMachineScript.prototype;
    /**
   * onStateEnter is called when a transition starts and the state machine starts to evaluate this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateEnter = function onStateEnter(animator, animatorState, layerIndex) {};
    /**
   * onStateUpdate is called on each Update frame between onStateEnter and onStateExit callbacks.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateUpdate = function onStateUpdate(animator, animatorState, layerIndex) {};
    /**
   * onStateExit is called when a transition ends and the state machine finishes evaluating this state.
   * @param animator - The animator
   * @param animatorState - The state be evaluated
   * @param layerIndex - The index of the layer where the state is located
   */ _proto.onStateExit = function onStateExit(animator, animatorState, layerIndex) {};
    /**
   * Destroy this instance.
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        this._state._removeStateMachineScript(this);
        this._destroyed = true;
    };
    return StateMachineScript;
}();

/**
 * States are the basic building blocks of a state machine. Each state contains a AnimationClip which will play while the character is in that state.
 */ var AnimatorState = /*#__PURE__*/ function() {
    function AnimatorState(name) {
        this.name = name;
        this./** The speed of the clip. 1 is normal speed, default 1. */ speed = 1.0;
        this./** The wrap mode used in the state. */ wrapMode = WrapMode.Loop;
        this./** @internal */ _onStateEnterScripts = [];
        this./** @internal */ _onStateUpdateScripts = [];
        this./** @internal */ _onStateExitScripts = [];
        this._clipStartTime = 0;
        this._clipEndTime = 1;
        this._transitions = [];
    }
    var _proto = AnimatorState.prototype;
    /**
   * Add an outgoing transition to the destination state.
   * @param transition - The transition
   */ _proto.addTransition = function addTransition(transition) {
        this._transitions.push(transition);
    };
    /**
   * Remove a transition from the state.
   * @param transition - The transition
   */ _proto.removeTransition = function removeTransition(transition) {
        var index = this._transitions.indexOf(transition);
        index !== -1 && this._transitions.splice(index, 1);
    };
    /**
   * Adds a state machine script class of type T to the AnimatorState.
   * @param scriptType - The state machine script class of type T
   */ _proto.addStateMachineScript = function addStateMachineScript(scriptType) {
        var script = new scriptType();
        script._state = this;
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
            this._onStateEnterScripts.push(script);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
            this._onStateUpdateScripts.push(script);
        }
        if (script.onStateExit !== prototype.onStateExit) {
            this._onStateExitScripts.push(script);
        }
        return script;
    };
    /**
   * Clears all transitions from the state.
   */ _proto.clearTransitions = function clearTransitions() {
        this._transitions.length = 0;
    };
    /**
   * @internal
   */ _proto._getDuration = function _getDuration() {
        if (this.clip) {
            return (this._clipEndTime - this._clipStartTime) * this.clip.length;
        }
        return null;
    };
    /**
   * @internal
   */ _proto._removeStateMachineScript = function _removeStateMachineScript(script) {
        var prototype = StateMachineScript.prototype;
        if (script.onStateEnter !== prototype.onStateEnter) {
            var index = this._onStateEnterScripts.indexOf(script);
            index !== -1 && this._onStateEnterScripts.splice(index, 1);
        }
        if (script.onStateUpdate !== prototype.onStateUpdate) {
            var index1 = this._onStateUpdateScripts.indexOf(script);
            index1 !== -1 && this._onStateUpdateScripts.splice(index1, 1);
        }
        if (script.onStateExit !== prototype.onStateExit) {
            var index2 = this._onStateExitScripts.indexOf(script);
            index2 !== -1 && this._onStateExitScripts.splice(index2, 1);
        }
    };
    _create_class$3(AnimatorState, [
        {
            key: "transitions",
            get: /**
   * The transitions that are going out of the state.
   */ function get() {
                return this._transitions;
            }
        },
        {
            key: "clip",
            get: /**
   * The clip that is being played by this animator state.
   */ function get() {
                return this._clip;
            },
            set: function set(clip) {
                this._clip = clip;
                this._clipEndTime = Math.min(this._clipEndTime, 1);
            }
        },
        {
            key: "clipStartTime",
            get: /**
   * The start time of the clip, the range is 0 to 1, default is 0.
   */ function get() {
                return this._clipStartTime;
            },
            set: function set(time) {
                this._clipStartTime = Math.max(time, 0);
            }
        },
        {
            key: "clipEndTime",
            get: /**
   * The end time of the clip, the range is 0 to 1, default is 1.
   */ function get() {
                return this._clipEndTime;
            },
            set: function set(time) {
                this._clipEndTime = Math.min(time, 1);
            }
        }
    ]);
    return AnimatorState;
}();

/**
 * A graph controlling the interaction of states. Each state references a motion.
 */ var AnimatorStateMachine = /*#__PURE__*/ function() {
    function AnimatorStateMachine() {
        /** The list of states. */ this.states = [];
        /** @internal */ this._statesMap = {};
    }
    var _proto = AnimatorStateMachine.prototype;
    /**
   * Add a state to the state machine.
   * @param name - The name of the new state
   */ _proto.addState = function addState(name) {
        var state = this.findStateByName(name);
        if (!state) {
            state = new AnimatorState(name);
            this.states.push(state);
            this._statesMap[name] = state;
        } else {
            console.warn("The state named " + name + " has existed.");
        }
        return state;
    };
    /**
   * Remove a state from the state machine.
   * @param state - The state
   */ _proto.removeState = function removeState(state) {
        var name = state.name;
        var index = this.states.indexOf(state);
        if (index > -1) {
            this.states.splice(index, 1);
        }
        delete this._statesMap[name];
    };
    /**
   * Get the state by name.
   * @param name - The layer's name
   */ _proto.findStateByName = function findStateByName(name) {
        return this._statesMap[name];
    };
    /**
   * Makes a unique state name in the state machine.
   * @param name - Desired name for the state.
   * @returns Unique name.
   */ _proto.makeUniqueStateName = function makeUniqueStateName(name) {
        var _statesMap = this._statesMap;
        var originName = name;
        var index = 0;
        while(_statesMap[name]){
            name = originName + " " + index;
            index++;
        }
        return name;
    };
    return AnimatorStateMachine;
}();

var AnimatorConditionMode;
(function(AnimatorConditionMode) {
    AnimatorConditionMode[AnimatorConditionMode["If"] = 0] = "If";
    AnimatorConditionMode[AnimatorConditionMode["IfNot"] = 1] = "IfNot";
    AnimatorConditionMode[AnimatorConditionMode["Greater"] = 2] = "Greater";
    AnimatorConditionMode[AnimatorConditionMode["Less"] = 3] = "Less";
    AnimatorConditionMode[AnimatorConditionMode["Equals"] = 4] = "Equals";
    AnimatorConditionMode[AnimatorConditionMode["NotEquals"] = 5] = "NotEquals";
})(AnimatorConditionMode || (AnimatorConditionMode = {}));

/**
 * Keyframe.
 * @typeParam V - Type of Keyframe value
 */ var Keyframe = function Keyframe() {
};

/**
 * SkyBoxMaterial.
 */ var SkyBoxMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(SkyBoxMaterial, Material);
    function SkyBoxMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("skybox")) || this;
        _this._textureDecodeRGBM = false;
        _this._tintColor = new Color$1(1, 1, 1, 1);
        _this.renderState.rasterState.cullMode = CullMode.Off;
        _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        _this.shaderData.setFloat(SkyBoxMaterial._rotationProp, 0);
        _this.shaderData.setFloat(SkyBoxMaterial._exposureProp, 1);
        _this.shaderData.setColor(SkyBoxMaterial._tintColorProp, _this._tintColor);
        return _this;
    }
    var _proto = SkyBoxMaterial.prototype;
    _proto.clone = function clone() {
        var dest = new SkyBoxMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(SkyBoxMaterial, [
        {
            key: "textureDecodeRGBM",
            get: /**
   * Whether to decode texture with RGBM format.
   */ function get() {
                return this._textureDecodeRGBM;
            },
            set: function set(value) {
                this._textureDecodeRGBM = value;
                if (value) {
                    this.shaderData.enableMacro(SkyBoxMaterial._decodeSkyRGBMMacro);
                } else {
                    this.shaderData.disableMacro(SkyBoxMaterial._decodeSkyRGBMMacro);
                }
            }
        },
        {
            key: "texture",
            get: /**
   * Texture of the sky box material.
   */ function get() {
                return this.shaderData.getTexture(SkyBoxMaterial._textureCubeProp);
            },
            set: function set(value) {
                this.shaderData.setTexture(SkyBoxMaterial._textureCubeProp, value);
            }
        },
        {
            key: "rotation",
            get: /**
   * The angle to rotate around the y-axis, unit is degree.
   */ function get() {
                return this.shaderData.getFloat(SkyBoxMaterial._rotationProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyBoxMaterial._rotationProp, value);
            }
        },
        {
            key: "exposure",
            get: /**
   * The exposure value of this material.
   */ function get() {
                return this.shaderData.getFloat(SkyBoxMaterial._exposureProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyBoxMaterial._exposureProp, value);
            }
        },
        {
            key: "tintColor",
            get: /**
   * The Tint color of this material.
   */ function get() {
                return this._tintColor;
            },
            set: function set(value) {
                if (this._tintColor != value) {
                    this._tintColor.copyFrom(value);
                }
            }
        }
    ]);
    return SkyBoxMaterial;
}(Material);
(function() {
    SkyBoxMaterial._tintColorProp = ShaderProperty.getByName("material_TintColor");
})();
(function() {
    SkyBoxMaterial._textureCubeProp = ShaderProperty.getByName("material_CubeTexture");
})();
(function() {
    SkyBoxMaterial._rotationProp = ShaderProperty.getByName("material_Rotation");
})();
(function() {
    SkyBoxMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
})();
(function() {
    SkyBoxMaterial._decodeSkyRGBMMacro = ShaderMacro.getByName("MATERIAL_IS_DECODE_SKY_RGBM");
})();

var SunMode;
(function(SunMode) {
    SunMode[SunMode[/** None */ "None"] = 0] = "None";
    SunMode[SunMode[/** Simple sun. */ "Simple"] = 1] = "Simple";
    SunMode[SunMode[/** High quality sun. */ "HighQuality"] = 2] = "HighQuality";
})(SunMode || (SunMode = {}));
/**
 * Sky procedural material.
 */ var SkyProceduralMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(SkyProceduralMaterial, Material);
    function SkyProceduralMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("SkyProcedural")) || this;
        _this.sunMode = 2;
        _this.sunSize = 0.04;
        _this.sunSizeConvergence = 5;
        _this.atmosphereThickness = 1.0;
        _this.skyTint = new Color$1(0.5, 0.5, 0.5, 1.0);
        _this.groundTint = new Color$1(0.369, 0.349, 0.341, 1.0);
        _this.exposure = 1.3;
        _this.renderState.rasterState.cullMode = CullMode.Off;
        _this.renderState.depthState.compareFunction = CompareFunction.LessEqual;
        return _this;
    }
    var _proto = SkyProceduralMaterial.prototype;
    /**
   * @inheritDoc
   */ _proto.clone = function clone() {
        var dest = new SkyProceduralMaterial(this._engine);
        this.cloneTo(dest);
        return dest;
    };
    _create_class$3(SkyProceduralMaterial, [
        {
            key: "sunMode",
            get: /**
   * Sun mode.
   */ function get() {
                return this._sunDisk;
            },
            set: function set(value) {
                var shaderData = this.shaderData;
                switch(value){
                    case 2:
                        shaderData.disableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        shaderData.enableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        break;
                    case 1:
                        shaderData.disableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        shaderData.enableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        break;
                    case 0:
                        shaderData.disableMacro(SkyProceduralMaterial._sunHighQualityMacro);
                        shaderData.disableMacro(SkyProceduralMaterial._sunSimpleMacro);
                        break;
                    default:
                        throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = value;
            }
        },
        {
            key: "sunSize",
            get: /**
   * Sun size, range is 0 to 1.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._sunSizeProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._sunSizeProp, Math.min(Math.max(0.0, value), 1.0));
            }
        },
        {
            key: "sunSizeConvergence",
            get: /**
   * Sun size convergence, range is 0 to 20.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._sunSizeConvergenceProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._sunSizeConvergenceProp, Math.min(Math.max(0.0, value), 20.0));
            }
        },
        {
            key: "atmosphereThickness",
            get: /**
   * Atmosphere thickness, range is 0 to 5.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._atmosphereThicknessProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._atmosphereThicknessProp, Math.min(Math.max(0.0, value), 5.0));
            }
        },
        {
            key: "skyTint",
            get: /**
   * Sky tint.
   */ function get() {
                return this.shaderData.getColor(SkyProceduralMaterial._skyTintProp);
            },
            set: function set(value) {
                this.shaderData.setColor(SkyProceduralMaterial._skyTintProp, value);
            }
        },
        {
            key: "groundTint",
            get: /**
   * Ground tint.
   */ function get() {
                return this.shaderData.getColor(SkyProceduralMaterial._groundTintProp);
            },
            set: function set(value) {
                this.shaderData.setColor(SkyProceduralMaterial._groundTintProp, value);
            }
        },
        {
            key: "exposure",
            get: /**
   * Exposure, range is 0 to 8.
   */ function get() {
                return this.shaderData.getFloat(SkyProceduralMaterial._exposureProp);
            },
            set: function set(value) {
                this.shaderData.setFloat(SkyProceduralMaterial._exposureProp, Math.min(Math.max(0.0, value), 8.0));
            }
        }
    ]);
    return SkyProceduralMaterial;
}(Material);
(function() {
    SkyProceduralMaterial._sunSizeProp = ShaderProperty.getByName("material_SunSize");
})();
(function() {
    SkyProceduralMaterial._sunSizeConvergenceProp = ShaderProperty.getByName("material_SunSizeConvergence");
})();
(function() {
    SkyProceduralMaterial._atmosphereThicknessProp = ShaderProperty.getByName("material_AtmosphereThickness");
})();
(function() {
    SkyProceduralMaterial._skyTintProp = ShaderProperty.getByName("material_SkyTint");
})();
(function() {
    SkyProceduralMaterial._groundTintProp = ShaderProperty.getByName("material_GroundTint");
})();
(function() {
    SkyProceduralMaterial._exposureProp = ShaderProperty.getByName("material_Exposure");
})();
(function() {
    SkyProceduralMaterial._sunHighQualityMacro = ShaderMacro.getByName("MATERIAL_SUN_HIGH_QUALITY");
})();
(function() {
    SkyProceduralMaterial._sunSimpleMacro = ShaderMacro.getByName("MATERIAL_SUN_SIMPLE");
})();

var DirtyFlagType;
(function(DirtyFlagType) {
    DirtyFlagType[DirtyFlagType["Position"] = 0x1] = "Position";
    DirtyFlagType[DirtyFlagType["Velocity"] = 0x2] = "Velocity";
    DirtyFlagType[DirtyFlagType["Acceleration"] = 0x4] = "Acceleration";
    DirtyFlagType[DirtyFlagType["Color"] = 0x8] = "Color";
    DirtyFlagType[DirtyFlagType["Alpha"] = 0x10] = "Alpha";
    DirtyFlagType[DirtyFlagType["Size"] = 0x20] = "Size";
    DirtyFlagType[DirtyFlagType["StartAngle"] = 0x40] = "StartAngle";
    DirtyFlagType[DirtyFlagType["StartTime"] = 0x80] = "StartTime";
    DirtyFlagType[DirtyFlagType["LifeTime"] = 0x100] = "LifeTime";
    DirtyFlagType[DirtyFlagType["RotateVelocity"] = 0x200] = "RotateVelocity";
    DirtyFlagType[DirtyFlagType["Scale"] = 0x400] = "Scale";
    DirtyFlagType[DirtyFlagType["Everything"] = 0xffffffff] = "Everything";
})(DirtyFlagType || (DirtyFlagType = {}));
var ParticleRendererBlendMode;
(function(ParticleRendererBlendMode) {
    ParticleRendererBlendMode[ParticleRendererBlendMode["Transparent"] = 0] = "Transparent";
    ParticleRendererBlendMode[ParticleRendererBlendMode["Additive"] = 1] = "Additive";
})(ParticleRendererBlendMode || (ParticleRendererBlendMode = {}));
/**
 * Particle Renderer Component.
 */ var ParticleRenderer = /*#__PURE__*/ function(MeshRenderer) {
    _inherits$2(ParticleRenderer, MeshRenderer);
    function ParticleRenderer(props) {
        var _this;
        _this = MeshRenderer.call(this, props) || this;
        _this._maxCount = 1000;
        _this._position = new Vector3();
        _this._positionRandomness = new Vector3();
        _this._velocity = new Vector3();
        _this._velocityRandomness = new Vector3();
        _this._acceleration = new Vector3();
        _this._accelerationRandomness = new Vector3();
        _this._color = new Color$1(1, 1, 1, 1);
        _this._colorRandomness = 0;
        _this._size = 1;
        _this._sizeRandomness = 0;
        _this._alpha = 1;
        _this._alphaRandomness = 0;
        _this._startAngle = 0;
        _this._startAngleRandomness = 0;
        _this._rotateVelocity = 0;
        _this._rotateVelocityRandomness = 0;
        _this._lifetime = 5;
        _this._startTimeRandomness = 0;
        _this._scale = 1;
        _this._isOnce = false;
        _this._onceTime = 0;
        _this._time = 0;
        _this._isInit = false;
        _this._isStart = false;
        _this._updateDirtyFlag = 0xffffffff;
        _this._isRotateToVelocity = false;
        _this._isUseOriginColor = false;
        _this._isScaleByLifetime = false;
        _this._is2d = true;
        _this._isFadeIn = false;
        _this._isFadeOut = false;
        _this._playOnEnable = true;
        _this._blendMode = 0;
        _this._onColorChanged = _this._onColorChanged.bind(_assert_this_initialized(_this));
        //@ts-ignore
        _this._color._onValueChanged = _this._onColorChanged;
        _this.setMaterial(_this._createMaterial());
        return _this;
    }
    var _proto = ParticleRenderer.prototype;
    /**
   * @internal
   */ _proto.update = function update(deltaTime) {
        if (!this._isInit || !this._isStart) {
            return;
        }
        // Stop after play once
        if (this._isOnce && this._time > this._onceTime) {
            return this.stop();
        }
        if (this._updateDirtyFlag) {
            this._updateBuffer();
            this._updateDirtyFlag = 0;
        }
        this._time += deltaTime;
        this.shaderData.setFloat("u_time", this._time);
    };
    /**
   * @internal
   */ _proto._onEnable = function _onEnable() {
        MeshRenderer.prototype._onEnable.call(this);
        if (this._playOnEnable) {
            this.start();
        }
    };
    /**
   * Start emitting.
   */ _proto.start = function start() {
        this._isStart = true;
        this._time = 0;
    };
    /**
   * Stop emitting.
   */ _proto.stop = function stop() {
        this._isStart = false;
    };
    _proto._createMaterial = function _createMaterial() {
        var material = new Material(this.engine, Shader.find("particle-shader"));
        var renderState = material.renderState;
        var target = renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
        target.sourceAlphaBlendFactor = BlendFactor.One;
        target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
        renderState.depthState.writeEnabled = false;
        material.renderState.renderQueueType = RenderQueueType.Transparent;
        this.isUseOriginColor = true;
        this.is2d = true;
        this.isFadeOut = true;
        return material;
    };
    _proto._createMesh = function _createMesh() {
        var mesh = new BufferMesh(this._entity.engine, "particleMesh");
        var vertexStride = 96;
        var vertexCount = this._maxCount * 4;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var indices = null;
        var useUint32 = false;
        if (vertexCount > ParticleRenderer._uint16VertexLimit) {
            if (this.engine._hardwareRenderer.canIUse(GLCapabilityType.elementIndexUint)) {
                useUint32 = true;
                indices = new Uint32Array(6 * this._maxCount);
            } else {
                throw Error("The vertex count is over limit.");
            }
        } else {
            indices = new Uint16Array(6 * this._maxCount);
        }
        for(var i = 0, idx = 0; i < this._maxCount; ++i){
            var startIndex = i * 4;
            indices[idx++] = startIndex;
            indices[idx++] = startIndex + 1;
            indices[idx++] = startIndex + 2;
            indices[idx++] = startIndex;
            indices[idx++] = startIndex + 2;
            indices[idx++] = startIndex + 3;
        }
        var vertexElements = [
            new VertexElement("a_position", 0, VertexElementFormat.Vector3, 0),
            new VertexElement("a_velocity", 12, VertexElementFormat.Vector3, 0),
            new VertexElement("a_acceleration", 24, VertexElementFormat.Vector3, 0),
            new VertexElement("a_color", 36, VertexElementFormat.Vector4, 0),
            new VertexElement("a_lifeAndSize", 52, VertexElementFormat.Vector4, 0),
            new VertexElement("a_rotation", 68, VertexElementFormat.Vector2, 0),
            new VertexElement("a_uv", 76, VertexElementFormat.Vector3, 0),
            new VertexElement("a_normalizedUv", 88, VertexElementFormat.Vector2, 0)
        ];
        var vertexBuffer = new Buffer(this.engine, BufferBindFlag.VertexBuffer, vertexFloatCount * 4, BufferUsage.Dynamic);
        var indexBuffer = new Buffer(this.engine, BufferBindFlag.IndexBuffer, indices, BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setIndexBufferBinding(indexBuffer, useUint32 ? IndexFormat.UInt32 : IndexFormat.UInt16);
        mesh.setVertexElements(vertexElements);
        mesh.addSubMesh(0, indices.length);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride / 4;
        this._vertices = vertices;
        var bounds = mesh.bounds;
        var minValue = Number.MIN_SAFE_INTEGER;
        var maxValue = Number.MAX_SAFE_INTEGER;
        bounds.min.set(minValue, minValue, minValue);
        bounds.max.set(maxValue, maxValue, maxValue);
        return mesh;
    };
    _proto._updateBuffer = function _updateBuffer() {
        for(var x = 0; x < this._maxCount; x++){
            this._updateSingleBuffer(x);
        }
        this._vertexBuffer.setData(this._vertices);
    };
    _proto._updateSingleBuffer = function _updateSingleBuffer(i) {
        var _this = this, _updateDirtyFlag = _this._updateDirtyFlag, vertices = _this._vertices, vertexStride = _this._vertexStride;
        var getRandom = ParticleRenderer._getRandom;
        var offset = i * 4;
        var k0 = offset * vertexStride;
        var k1 = (offset + 1) * vertexStride;
        var k2 = (offset + 2) * vertexStride;
        var k3 = (offset + 3) * vertexStride;
        if (_updateDirtyFlag & 0x1) {
            var _this__position = this._position, x = _this__position.x, y = _this__position.y, z = _this__position.z;
            var _this1 = this, _positionArray = _this1._positionArray, _positionRandomness = _this1._positionRandomness;
            if (_positionArray) {
                if (_positionArray.length !== this._maxCount) {
                    throw Error("The length of positionArray must be equal to maxCount.");
                }
                var pos = _positionArray[i];
                x += pos.x;
                y += pos.y;
                z += pos.z;
            } else {
                x += getRandom() * _positionRandomness.x;
                y += getRandom() * _positionRandomness.y;
                z += getRandom() * _positionRandomness.z;
            }
            vertices[k0] = vertices[k1] = vertices[k2] = vertices[k3] = x;
            vertices[k0 + 1] = vertices[k1 + 1] = vertices[k2 + 1] = vertices[k3 + 1] = y;
            vertices[k0 + 2] = vertices[k1 + 2] = vertices[k2 + 2] = vertices[k3 + 2] = z;
        }
        if (_updateDirtyFlag & 0x2) {
            var _this2 = this, _velocity = _this2._velocity, _velocityRandomness = _this2._velocityRandomness;
            vertices[k0 + 3] = vertices[k1 + 3] = vertices[k2 + 3] = vertices[k3 + 3] = _velocity.x + getRandom() * _velocityRandomness.x;
            vertices[k0 + 4] = vertices[k1 + 4] = vertices[k2 + 4] = vertices[k3 + 4] = _velocity.y + getRandom() * _velocityRandomness.y;
            vertices[k0 + 5] = vertices[k1 + 5] = vertices[k2 + 5] = vertices[k3 + 5] = _velocity.z + getRandom() * _velocityRandomness.z;
        }
        if (_updateDirtyFlag & 0x4) {
            var _this3 = this, _acceleration = _this3._acceleration, _accelerationRandomness = _this3._accelerationRandomness;
            vertices[k0 + 6] = vertices[k1 + 6] = vertices[k2 + 6] = vertices[k3 + 6] = _acceleration.x + getRandom() * _accelerationRandomness.x;
            vertices[k0 + 7] = vertices[k1 + 7] = vertices[k2 + 7] = vertices[k3 + 7] = _acceleration.y + getRandom() * _accelerationRandomness.y;
            vertices[k0 + 8] = vertices[k1 + 8] = vertices[k2 + 8] = vertices[k3 + 8] = _acceleration.z + getRandom() * _accelerationRandomness.z;
        }
        if (_updateDirtyFlag & 0x8) {
            var _this4 = this, _color = _this4._color, _colorRandomness = _this4._colorRandomness;
            vertices[k0 + 9] = vertices[k1 + 9] = vertices[k2 + 9] = vertices[k3 + 9] = MathUtil$1.clamp(_color.r + getRandom() * _colorRandomness, 0, 1);
            vertices[k0 + 10] = vertices[k1 + 10] = vertices[k2 + 10] = vertices[k3 + 10] = MathUtil$1.clamp(_color.g + getRandom() * _colorRandomness, 0, 1);
            vertices[k0 + 11] = vertices[k1 + 11] = vertices[k2 + 11] = vertices[k3 + 11] = MathUtil$1.clamp(_color.b + getRandom() * _colorRandomness, 0, 1);
        }
        if (_updateDirtyFlag & 0x10) {
            vertices[k0 + 12] = vertices[k1 + 12] = vertices[k2 + 12] = vertices[k3 + 12] = MathUtil$1.clamp(this._alpha + getRandom() * this._alphaRandomness, 0, 1);
        }
        if (_updateDirtyFlag & 0x80) {
            vertices[k0 + 13] = vertices[k1 + 13] = vertices[k2 + 13] = vertices[k3 + 13] = Math.random() * this._startTimeRandomness;
        }
        if (_updateDirtyFlag & 0x100) {
            var _lifetime = this._lifetime;
            vertices[k0 + 14] = vertices[k1 + 14] = vertices[k2 + 14] = vertices[k3 + 14] = _lifetime + getRandom() * _lifetime;
        }
        // Update the duration of play once when startTime or lifetime changes.
        if (_updateDirtyFlag & 0x80 || _updateDirtyFlag & 0x100) {
            this._onceTime = Math.max(this._onceTime, vertices[k0 + 13] + vertices[k0 + 14]);
        }
        if (_updateDirtyFlag & 0x20) {
            var _size = this._size;
            vertices[k0 + 15] = vertices[k1 + 15] = vertices[k2 + 15] = vertices[k3 + 15] = Math.max(_size + getRandom() * this._sizeRandomness * _size * 2, 0);
        }
        if (_updateDirtyFlag & 0x400) {
            vertices[k0 + 16] = vertices[k1 + 16] = vertices[k2 + 16] = vertices[k3 + 16] = this._scale;
        }
        if (_updateDirtyFlag & 0x40) {
            vertices[k0 + 17] = vertices[k1 + 17] = vertices[k2 + 17] = vertices[k3 + 17] = this._startAngle + getRandom() * Math.PI * this._startAngleRandomness * 2;
        }
        if (_updateDirtyFlag & 0x200) {
            vertices[k0 + 18] = vertices[k1 + 18] = vertices[k2 + 18] = vertices[k3 + 18] = this._rotateVelocity + getRandom() * this._rotateVelocityRandomness;
        }
        this._updateSingleUv(i, k0, k1, k2, k3);
    };
    _proto._updateSingleUv = function _updateSingleUv(i, k0, k1, k2, k3) {
        var spriteSheet = this.spriteSheet;
        var texture = this.getMaterial().shaderData.getTexture("u_texture");
        var vertices = this._vertices;
        if (texture) {
            var width = texture.width;
            var height = texture.height;
            if (spriteSheet) {
                var _spriteSheet_ = spriteSheet[i % spriteSheet.length], x = _spriteSheet_.x, y = _spriteSheet_.y, w = _spriteSheet_.w, h = _spriteSheet_.h;
                var u = x / width;
                var v = y / height;
                var p = u + w / width;
                var q = v + h / height;
                var ratio = h / w;
                // left bottom
                vertices[k0 + 19] = u;
                vertices[k0 + 20] = q;
                vertices[k0 + 21] = ratio;
                // right bottom
                vertices[k1 + 19] = p;
                vertices[k1 + 20] = q;
                vertices[k1 + 21] = ratio;
                // right top
                vertices[k2 + 19] = p;
                vertices[k2 + 20] = v;
                vertices[k2 + 21] = ratio;
                // left top
                vertices[k3 + 19] = u;
                vertices[k3 + 20] = v;
                vertices[k3 + 21] = ratio;
            } else {
                var ratio1 = height / width;
                // left bottom
                vertices[k0 + 19] = 0;
                vertices[k0 + 20] = 1;
                vertices[k0 + 21] = ratio1;
                // right bottom
                vertices[k1 + 19] = 1;
                vertices[k1 + 20] = 1;
                vertices[k1 + 21] = ratio1;
                // right top
                vertices[k2 + 19] = 1;
                vertices[k2 + 20] = 0;
                vertices[k2 + 21] = ratio1;
                // left top
                vertices[k3 + 19] = 0;
                vertices[k3 + 20] = 0;
                vertices[k3 + 21] = ratio1;
            }
        } else {
            // left bottom
            vertices[k0 + 19] = 0;
            vertices[k0 + 20] = 0;
            vertices[k0 + 21] = 1;
            // right bottom
            vertices[k1 + 19] = 1;
            vertices[k1 + 20] = 0;
            vertices[k1 + 21] = 1;
            // right top
            vertices[k2 + 19] = 1;
            vertices[k2 + 20] = 1;
            vertices[k2 + 21] = 1;
            // left top
            vertices[k3 + 19] = 0;
            vertices[k3 + 20] = 1;
            vertices[k3 + 21] = 1;
        }
        vertices[k0 + 22] = -0.5;
        vertices[k0 + 23] = -0.5;
        vertices[k1 + 22] = 0.5;
        vertices[k1 + 23] = -0.5;
        vertices[k2 + 22] = 0.5;
        vertices[k2 + 23] = 0.5;
        vertices[k3 + 22] = -0.5;
        vertices[k3 + 23] = 0.5;
    };
    _proto._onColorChanged = function _onColorChanged() {
        this._updateDirtyFlag |= 0x8;
    };
    ParticleRenderer._getRandom = function _getRandom() {
        return Math.random() - 0.5;
    };
    _create_class$3(ParticleRenderer, [
        {
            key: "texture",
            get: /**
   * Texture of particle.
   */ function get() {
                return this.getMaterial().shaderData.getTexture("u_texture");
            },
            set: function set(texture) {
                if (texture) {
                    this.shaderData.enableMacro("particleTexture");
                    this.getMaterial().shaderData.setTexture("u_texture", texture);
                } else {
                    this.shaderData.disableMacro("particleTexture");
                }
            }
        },
        {
            key: "position",
            get: /**
   * Position of particles.
   */ function get() {
                return this._position;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x1;
                this._position = value;
            }
        },
        {
            key: "positionRandomness",
            get: /**
   * Random range of positions.
   */ function get() {
                return this._positionRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x1;
                this._positionRandomness = value;
            }
        },
        {
            key: "positionArray",
            get: /**
   * Array of fixed positions.
   */ function get() {
                return this._positionArray;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x1;
                this._positionArray = value;
            }
        },
        {
            key: "velocity",
            get: /**
   * Velocity of particles.
   */ function get() {
                return this._velocity;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x2;
                this._velocity = value;
            }
        },
        {
            key: "velocityRandomness",
            get: /**
   * Random range of velocity.
   */ function get() {
                return this._velocityRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x2;
                this._velocityRandomness = value;
            }
        },
        {
            key: "acceleration",
            get: /**
   * Acceleration of particles.
   */ function get() {
                return this._acceleration;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x4;
                this._acceleration = value;
            }
        },
        {
            key: "accelerationRandomness",
            get: /**
   * Random range of acceleration.
   */ function get() {
                return this._accelerationRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x4;
                this._accelerationRandomness = value;
            }
        },
        {
            key: "color",
            get: /**
   * Color of particles.
   */ function get() {
                return this._color;
            },
            set: function set(value) {
                this._color.copyFrom(value);
            }
        },
        {
            key: "colorRandomness",
            get: /**
   * Random range of color.
   */ function get() {
                return this._colorRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x8;
                this._colorRandomness = value;
            }
        },
        {
            key: "size",
            get: /**
   * Size of particles.
   */ function get() {
                return this._size;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x20;
                this._size = value;
            }
        },
        {
            key: "sizeRandomness",
            get: /**
   * Random range of size.
   */ function get() {
                return this._sizeRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x20;
                this._sizeRandomness = value;
            }
        },
        {
            key: "alpha",
            get: /**
   * Alpha of particles.
   */ function get() {
                return this._alpha;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x10;
                this._alpha = value;
            }
        },
        {
            key: "alphaRandomness",
            get: /**
   * Random range of alpha.
   */ function get() {
                return this._alphaRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x10;
                this._alphaRandomness = value;
            }
        },
        {
            key: "angle",
            get: /**
   * Angle of particles.
   */ function get() {
                return this._startAngle;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x40;
                this._startAngle = value;
            }
        },
        {
            key: "angleRandomness",
            get: /**
   * Random range of angle.
   */ function get() {
                return this._startAngleRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x40;
                this._startAngleRandomness = value;
            }
        },
        {
            key: "rotateVelocity",
            get: /**
   * Rotate velocity of particles.
   */ function get() {
                return this._rotateVelocity;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x200;
                this._rotateVelocity = value;
            }
        },
        {
            key: "rotateVelocityRandomness",
            get: /**
   * Random range of rotate velocity.
   */ function get() {
                return this._rotateVelocityRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x200;
                this._rotateVelocityRandomness = value;
            }
        },
        {
            key: "lifetime",
            get: /**
   * Lifetime of particles.
   */ function get() {
                return this._lifetime;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x100;
                this._lifetime = value;
                this._onceTime = 0;
            }
        },
        {
            key: "startTimeRandomness",
            get: /**
   * Random range of start time.
   */ function get() {
                return this._startTimeRandomness;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x80;
                this._startTimeRandomness = value;
                this._onceTime = 0;
            }
        },
        {
            key: "scale",
            get: /**
   * Scale factor of particles.
   */ function get() {
                return this._scale;
            },
            set: function set(value) {
                this._updateDirtyFlag |= 0x400;
                this._scale = value;
            }
        },
        {
            key: "maxCount",
            get: /**
   * Max count of particles.
   */ function get() {
                return this._maxCount;
            },
            set: function set(value) {
                this._isStart = false;
                this._isInit = false;
                this._maxCount = value;
                this._updateDirtyFlag = 0xffffffff;
                this.mesh = this._createMesh();
                this._updateBuffer();
                this._isInit = true;
                this.shaderData.setFloat("u_time", 0);
            }
        },
        {
            key: "isOnce",
            get: /**
   * Whether play once.
   */ function get() {
                return this._isOnce;
            },
            set: function set(value) {
                this._time = 0;
                this.shaderData.setInt("u_once", value ? 1 : 0);
                this._isOnce = value;
            }
        },
        {
            key: "isRotateToVelocity",
            get: /**
   * Whether follow the direction of velocity.
   */ function get() {
                return this._isRotateToVelocity;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("rotateToVelocity");
                } else {
                    this.shaderData.disableMacro("rotateToVelocity");
                }
                this._isRotateToVelocity = value;
            }
        },
        {
            key: "isUseOriginColor",
            get: /**
   * Whether use origin color.
   */ function get() {
                return this._isUseOriginColor;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("useOriginColor");
                } else {
                    this.shaderData.disableMacro("useOriginColor");
                }
                this._isUseOriginColor = value;
            }
        },
        {
            key: "isScaleByLifetime",
            get: /**
   * Whether scale by lifetime.
   */ function get() {
                return this._isScaleByLifetime;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("isScaleByLifetime");
                } else {
                    this.shaderData.disableMacro("isScaleByLifetime");
                }
                this._isScaleByLifetime = value;
            }
        },
        {
            key: "is2d",
            get: /**
   * Whether 2D rendering.
   */ function get() {
                return this._is2d;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("is2d");
                } else {
                    this.shaderData.disableMacro("is2d");
                    this.getMaterial().renderState.rasterState.cullMode = CullMode.Off;
                }
                this._is2d = value;
            }
        },
        {
            key: "isFadeIn",
            get: /**
   * Whether fade in.
   */ function get() {
                return this._isFadeIn;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("fadeIn");
                } else {
                    this.shaderData.disableMacro("fadeIn");
                }
                this._isFadeIn = value;
            }
        },
        {
            key: "isFadeOut",
            get: /**
   * Whether fade out.
   */ function get() {
                return this._isFadeOut;
            },
            set: function set(value) {
                if (value) {
                    this.shaderData.enableMacro("fadeOut");
                } else {
                    this.shaderData.disableMacro("fadeOut");
                }
                this._isFadeOut = value;
            }
        },
        {
            key: "playOnEnable",
            get: /**
   * Whether play on enable.
   */ function get() {
                return this._playOnEnable;
            },
            set: function set(value) {
                this._playOnEnable = value;
                if (value) {
                    this.start();
                } else {
                    this.stop();
                }
            }
        },
        {
            key: "blendMode",
            get: /**
   * Blend mode of the particle renderer's material.
   */ function get() {
                return this._blendMode;
            },
            set: function set(value) {
                var blendState = this.getMaterial().renderState.blendState;
                var target = blendState.targetBlendState;
                if (value === 0) {
                    target.enabled = true;
                    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                    target.destinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
                    target.sourceAlphaBlendFactor = BlendFactor.One;
                    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
                } else if (value === 1) {
                    target.enabled = true;
                    target.sourceColorBlendFactor = BlendFactor.SourceAlpha;
                    target.destinationColorBlendFactor = BlendFactor.One;
                    target.sourceAlphaBlendFactor = BlendFactor.One;
                    target.destinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
                }
                this._blendMode = value;
            }
        }
    ]);
    return ParticleRenderer;
}(MeshRenderer);
(function() {
    /** The max number of indices that Uint16Array can support. */ ParticleRenderer._uint16VertexLimit = 65535;
})();
__decorate$1([
    ignoreClone
], ParticleRenderer.prototype, "_onColorChanged", null);

var FRAG_SHADER = "#define GLSLIFY 1\nvarying vec2 v_uv;uniform sampler2D u_texture;void main(void){gl_FragColor=texture2D(u_texture,v_uv);}"; // eslint-disable-line

var VERT_SHADER = "#define GLSLIFY 1\nattribute vec3 POSITION;attribute vec2 TEXCOORD_0;varying vec2 v_uv;uniform mat4 camera_ProjMat;uniform mat4 camera_ViewMat;void main(){gl_Position=camera_ProjMat*camera_ViewMat*vec4(POSITION,1.0);v_uv=TEXCOORD_0;}"; // eslint-disable-line

Shader.create("trail", VERT_SHADER, FRAG_SHADER);
var TrailMaterial = /*#__PURE__*/ function(Material) {
    _inherits$2(TrailMaterial, Material);
    function TrailMaterial(engine) {
        var _this;
        _this = Material.call(this, engine, Shader.find("trail")) || this;
        var target = _this.renderState.blendState.targetBlendState;
        target.enabled = true;
        target.sourceColorBlendFactor = target.sourceAlphaBlendFactor = BlendFactor.SourceAlpha;
        target.destinationColorBlendFactor = target.destinationAlphaBlendFactor = BlendFactor.One;
        _this.renderState.depthState.writeEnabled = false;
        return _this;
    }
    return TrailMaterial;
}(Material);

var _tempVector3 = new Vector3();
/**
 * @deprecated
 */ var TrailRenderer = /*#__PURE__*/ function(MeshRenderer) {
    _inherits$2(TrailRenderer, MeshRenderer);
    function TrailRenderer(entity, props) {
        var _this;
        _this = MeshRenderer.call(this, entity) || this;
        _this._stroke = props.stroke || 0.2;
        _this._minSeg = props.minSeg || 0.02;
        _this._lifetime = props.lifetime || 1000;
        _this._maxPointNum = _this._lifetime / 1000.0 * entity.engine.targetFrameRate;
        _this._points = [];
        _this._pointStates = [];
        _this._strapPoints = [];
        for(var i = 0; i < _this._maxPointNum; i++){
            _this._points.push(new Vector3());
            _this._pointStates.push(_this._lifetime);
            _this._strapPoints.push(new Vector3());
            _this._strapPoints.push(new Vector3());
        }
        _this._curPointNum = 0;
        var mtl = props.material || new TrailMaterial(_this.engine);
        _this.setMaterial(mtl);
        _this.setTexture(props.texture);
        _this._initGeometry();
        return _this;
    }
    var _proto = TrailRenderer.prototype;
    /**
   * @internal
   */ _proto.update = function update(deltaTime) {
        var mov = 0, newIdx = 0;
        for(var i = 0; i < this._curPointNum; i++){
            this._pointStates[i] -= deltaTime;
            if (this._pointStates[i] < 0) {
                mov++;
            } else if (mov > 0) {
                newIdx = i - mov;
                // Move data
                this._pointStates[newIdx] = this._pointStates[i];
                // Move point
                this._points[newIdx].copyFrom(this._points[i]);
            }
        }
        this._curPointNum -= mov;
        var appendNewPoint = true;
        if (this._curPointNum === this._maxPointNum) {
            appendNewPoint = false;
        } else if (this._curPointNum > 0) {
            var lastPoint = this._points[this._points.length - 1];
            if (Vector3.distance(this.entity.transform.worldPosition, lastPoint) < this._minSeg) {
                appendNewPoint = false;
            }
        }
        if (appendNewPoint) {
            this._pointStates[this._curPointNum] = this._lifetime;
            this._points[this._curPointNum].copyFrom(this.entity.transform.worldPosition);
            this._curPointNum++;
        }
    };
    /**
   * @deprecated
   * Set trail texture.
   * @param texture
   */ _proto.setTexture = function setTexture(texture) {
        if (texture) {
            this.getMaterial().shaderData.setTexture("u_texture", texture);
        }
    };
    /**
   * @internal
   */ _proto._render = function _render(context) {
        this._updateStrapVertices(context.camera, this._points);
        this._updateStrapCoords();
        this._vertexBuffer.setData(this._vertices);
        MeshRenderer.prototype._render.call(this, context);
    };
    _proto._initGeometry = function _initGeometry() {
        var mesh = new BufferMesh(this._entity.engine);
        var vertexStride = 20;
        var vertexCount = this._maxPointNum * 2;
        var vertexFloatCount = vertexCount * vertexStride;
        var vertices = new Float32Array(vertexFloatCount);
        var vertexElements = [
            new VertexElement("POSITION", 0, VertexElementFormat.Vector3, 0),
            new VertexElement("TEXCOORD_0", 12, VertexElementFormat.Vector2, 0)
        ];
        var vertexBuffer = new Buffer(this.engine, vertexFloatCount * 4, BufferUsage.Dynamic);
        mesh.setVertexBufferBinding(vertexBuffer, vertexStride);
        mesh.setVertexElements(vertexElements);
        mesh.addSubMesh(0, vertexCount, MeshTopology.TriangleStrip);
        this._vertexBuffer = vertexBuffer;
        this._vertexStride = vertexStride;
        this._vertices = vertices;
        this.mesh = mesh;
    };
    _proto._updateStrapVertices = function _updateStrapVertices(camera, points) {
        var m = camera.viewMatrix;
        var e = m.elements;
        var vx = new Vector3(e[0], e[4], e[8]);
        var vy = new Vector3(e[1], e[5], e[9]);
        var vz = new Vector3(e[2], e[6], e[10]);
        var s = this._stroke;
        vy.scale(s);
        var up = new Vector3();
        var down = new Vector3();
        var rotation = new Quaternion();
        Vector3.transformByQuat(vx, rotation, vx);
        Vector3.transformByQuat(vy, rotation, vy);
        var dy = new Vector3();
        var cross = new Vector3();
        var perpVector = new Vector3();
        vx.normalize();
        var vertices = this._vertices;
        //-- quad pos
        for(var i = 0; i < this._maxPointNum; i++){
            //-- center pos
            if (i < this._curPointNum) {
                var p = points[i];
                if (i === this._curPointNum - 1 && i !== 0) {
                    Vector3.subtract(p, points[i - 1], perpVector);
                } else {
                    Vector3.subtract(points[i + 1], p, perpVector);
                }
                this._projectOnPlane(perpVector, vz, perpVector);
                perpVector.normalize();
                // Calculate angle between vectors
                var angle = Math.acos(Vector3.dot(vx, perpVector));
                Vector3.cross(vx, perpVector, cross);
                if (Vector3.dot(cross, vz) <= 0) {
                    angle = Math.PI * 2 - angle;
                }
                Quaternion.rotationAxisAngle(vz, angle, rotation);
                Vector3.transformByQuat(vy, rotation, dy);
                Vector3.add(p, dy, up);
                Vector3.subtract(p, dy, down);
            }
            var p0 = i * 2 * this._vertexStride / 4;
            var p1 = (i * 2 + 1) * this._vertexStride / 4;
            vertices[p0] = up.x;
            vertices[p0 + 1] = up.y;
            vertices[p0 + 2] = up.z;
            vertices[p1] = down.x;
            vertices[p1 + 1] = down.y;
            vertices[p1 + 2] = down.z;
        }
    };
    _proto._updateStrapCoords = function _updateStrapCoords() {
        if (this._prePointsNum === this._curPointNum) {
            return;
        }
        this._prePointsNum = this._curPointNum;
        var count = this._curPointNum;
        var texDelta = 1.0 / count;
        var vertices = this._vertices;
        for(var i = 0; i < count; i++){
            var d = 1.0 - i * texDelta;
            var p0 = i * 2 * this._vertexStride / 4;
            var p1 = (i * 2 + 1) * this._vertexStride / 4;
            vertices[p0] = 0;
            vertices[p0 + 1] = d;
            vertices[p1] = 1.0;
            vertices[p1 + 1] = d;
        }
    };
    _proto._projectOnVector = function _projectOnVector(a, p, out) {
        var n_p = p.clone();
        Vector3.normalize(n_p, n_p);
        var cosine = Vector3.dot(a, n_p);
        out.x = n_p.x * cosine;
        out.y = n_p.y * cosine;
        out.z = n_p.z * cosine;
    };
    _proto._projectOnPlane = function _projectOnPlane(a, n, out) {
        this._projectOnVector(a, n, _tempVector3);
        Vector3.subtract(a, _tempVector3, out);
    };
    return TrailRenderer;
}(MeshRenderer);

/**
 * Environmental probes, providing necessary capabilities such as reflection and refraction.
 * @example
 * ```ts
 * const probe = cameraEntity.addComponent( CubeProbe )
 * probe.onTextureChange = cubeTexture => {
 *   envLight.specularTexture = cubeTexture;
 *   skybox.specularTexture = cubeTexture;
 * }
 * ```
 */ var Probe = /*#__PURE__*/ function(Script) {
    _inherits$2(Probe, Script);
    function Probe() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        /**
   * Probe's layer, render everything by default.
   */ _this.probeLayer = Layer.Everything;
        /**
   * The width of the probe rendering target.
   */ _this.width = 1024;
        /**
   * The height of the probe rendering target.
   */ _this.height = 1024;
        /**
   * When using WebGL2, you can turn on MSAA at the hardware layer.
   */ _this.antiAliasing = 1;
        /**
   * Whether the probe is rendered to the cube color texture.
   */ _this._isCube = false;
        return _this;
    }
    var _proto = Probe.prototype;
    /**
   * Provide hooks for users to exchange Texture.
   * @remarks Prevent issue: Feedback Loops Between Textures and the Framebuffer.
   */ _proto.onTextureChange = function onTextureChange(renderColorTexture) {};
    _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled) return;
        this._camera = camera;
        this._oriCameraCullingMask = camera.cullingMask;
        camera.cullingMask = this.probeLayer;
        if (!this._activeRenderTarget || this._activeRenderTarget.width !== this.width || this._activeRenderTarget.height !== this.height || this._activeRenderTarget.antiAliasing !== this.antiAliasing) {
            this._renderTarget = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
            this._renderTargetSwap = new RenderTarget(this.engine, this.width, this.height, this._isCube ? new TextureCube(this.engine, this.width) : new Texture2D(this.engine, this.width, this.height), RenderBufferDepthFormat.Depth, this.antiAliasing);
            this._activeRenderTarget = this._renderTarget;
        }
        this._oriCameraRenderTarget = camera.renderTarget;
        camera.renderTarget = this._activeRenderTarget;
    };
    _proto.onEndRender = function onEndRender(camera) {
        if (!this.enabled) return;
        this.onTextureChange && this.onTextureChange(this._texture);
        this._activeRenderTarget = this._activeRenderTarget === this._renderTarget ? this._renderTargetSwap : this._renderTarget;
    };
    _proto._reset = function _reset() {
        if (!this.enabled) return;
        this._camera.renderTarget = this._oriCameraRenderTarget;
        this._camera.cullingMask = this._oriCameraCullingMask;
    };
    _create_class$3(Probe, [
        {
            key: "_texture",
            get: function get() {
                var _this__activeRenderTarget;
                return (_this__activeRenderTarget = this._activeRenderTarget) == null ? void 0 : _this__activeRenderTarget.getColorTexture();
            }
        }
    ]);
    return Probe;
}(Script);

var cacheTarget = new Vector3();
var cacheUp = new Vector3();
var cacheDir = new Vector3();
/**
 * Cube probe, generate cubeTexture, used for dynamic environment reflection and other effects.
 */ var CubeProbe = /*#__PURE__*/ function(Probe) {
    _inherits$2(CubeProbe, Probe);
    function CubeProbe() {
        var _this;
        _this = Probe.apply(this, arguments) || this;
        /**
   * The position of the probe can be set, the default is the origin [0,0,0].
   */ _this.position = new Vector3(0, 0, 0);
        /** @internal */ _this._isCube = true;
        _this.oriViewMatrix = new Matrix();
        return _this;
    }
    var _proto = CubeProbe.prototype;
    _proto.onBeginRender = function onBeginRender(camera) {
        if (!this.enabled) return;
        Probe.prototype.onBeginRender.call(this, camera);
        this._storeCamera(camera);
        // Render 6 faces
        for(var faceIndex = 0; faceIndex < 6; faceIndex++){
            // Change camera parameters
            this._setCamera(faceIndex, camera);
            camera.render(TextureCubeFace.PositiveX + faceIndex);
        }
        this._restoreCamera(camera);
        Probe.prototype._reset.call(this);
    };
    /**
   * Store original camera parameters.
   */ _proto._storeCamera = function _storeCamera(camera) {
        this.oriViewMatrix.copyFrom(camera.viewMatrix);
        this._oriFieldOfView = camera.fieldOfView;
    };
    /**
   * Restore camera parameters.
   */ _proto._restoreCamera = function _restoreCamera(camera) {
        camera.viewMatrix.copyFrom(this.oriViewMatrix);
        camera.fieldOfView = this._oriFieldOfView;
    };
    /**
   * Set camera parameters according to the rendering surface.
   */ _proto._setCamera = function _setCamera(faceIndex, camera) {
        switch(faceIndex){
            // positive_x
            case 0:
                cacheUp.set(0, -1, 0);
                cacheDir.set(1, 0, 0);
                break;
            // negative_x
            case 1:
                cacheUp.set(0, -1, 0);
                cacheDir.set(-1, 0, 0);
                break;
            // positive_y
            case 2:
                cacheUp.set(0, 0, 1);
                cacheDir.set(0, 1, 0);
                break;
            // negative_y
            case 3:
                cacheUp.set(0, 0, -1);
                cacheDir.set(0, -1, 0);
                break;
            // positive_z
            case 4:
                cacheUp.set(0, -1, 0);
                cacheDir.set(0, 0, 1);
                break;
            // negative_z
            case 5:
                cacheUp.set(0, -1, 0);
                cacheDir.set(0, 0, -1);
                break;
        }
        Vector3.add(this.position, cacheDir, cacheTarget);
        Matrix.lookAt(this.position, cacheTarget, cacheUp, camera.viewMatrix);
        camera.fieldOfView = 90;
    };
    return CubeProbe;
}(Probe);

var CoreObjects = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AmbientLight: AmbientLight,
    get AnimationArrayCurve () { return AnimationArrayCurve; },
    get AnimationBoolCurve () { return AnimationBoolCurve; },
    AnimationClip: AnimationClip,
    AnimationClipCurveBinding: AnimationClipCurveBinding,
    get AnimationColorCurve () { return AnimationColorCurve; },
    AnimationCurve: AnimationCurve,
    AnimationEvent: AnimationEvent,
    get AnimationFloatArrayCurve () { return AnimationFloatArrayCurve; },
    get AnimationFloatCurve () { return AnimationFloatCurve; },
    get AnimationQuaternionCurve () { return AnimationQuaternionCurve; },
    get AnimationVector2Curve () { return AnimationVector2Curve; },
    get AnimationVector3Curve () { return AnimationVector3Curve; },
    get AnimationVector4Curve () { return AnimationVector4Curve; },
    Animator: Animator,
    get AnimatorConditionMode () { return AnimatorConditionMode; },
    AnimatorController: AnimatorController,
    AnimatorControllerLayer: AnimatorControllerLayer,
    get AnimatorCullingMode () { return AnimatorCullingMode; },
    get AnimatorLayerBlendingMode () { return AnimatorLayerBlendingMode; },
    AnimatorState: AnimatorState,
    AnimatorStateMachine: AnimatorStateMachine,
    AnimatorStateTransition: AnimatorStateTransition,
    AssetPromise: AssetPromise,
    get AssetType () { return exports.AssetType; },
    Background: Background,
    get BackgroundMode () { return BackgroundMode; },
    get BackgroundTextureFillMode () { return BackgroundTextureFillMode; },
    BaseMaterial: BaseMaterial,
    Basic2DBatcher: Basic2DBatcher,
    BasicRenderPipeline: BasicRenderPipeline,
    get BlendFactor () { return BlendFactor; },
    get BlendMode () { return BlendMode; },
    get BlendOperation () { return BlendOperation; },
    BlendShape: BlendShape,
    BlendShapeFrame: BlendShapeFrame,
    BlendState: BlendState,
    BlinnPhongMaterial: BlinnPhongMaterial,
    BoolUpdateFlag: BoolUpdateFlag,
    BoxColliderShape: BoxColliderShape,
    Buffer: Buffer,
    get BufferBindFlag () { return BufferBindFlag; },
    BufferMesh: BufferMesh,
    get BufferUsage () { return BufferUsage; },
    BufferUtil: BufferUtil,
    get Camera () { return exports.Camera; },
    get CameraClearFlags () { return CameraClearFlags; },
    CapsuleColliderShape: CapsuleColliderShape,
    CharacterController: CharacterController,
    CloneManager: CloneManager,
    get Collider () { return Collider; },
    ColliderShape: ColliderShape,
    get ColliderShapeUpAxis () { return ColliderShapeUpAxis; },
    get CollisionDetectionMode () { return CollisionDetectionMode; },
    get ColorSpace () { return ColorSpace; },
    get ColorWriteMask () { return ColorWriteMask; },
    get CompareFunction () { return CompareFunction; },
    Component: Component,
    ContentRestorer: ContentRestorer,
    get ControllerCollisionFlag () { return ControllerCollisionFlag; },
    get ControllerNonWalkableMode () { return ControllerNonWalkableMode; },
    CubeProbe: CubeProbe,
    get CullMode () { return CullMode; },
    get DataType () { return DataType; },
    get DependentMode () { return DependentMode; },
    DepthState: DepthState,
    get DiffuseMode () { return DiffuseMode; },
    DirectLight: DirectLight,
    DynamicCollider: DynamicCollider,
    get DynamicColliderConstraints () { return DynamicColliderConstraints; },
    Engine: Engine,
    EngineObject: EngineObject,
    Entity: Entity,
    EventDispatcher: EventDispatcher,
    FixedJoint: FixedJoint,
    get FogMode () { return exports.FogMode; },
    Font: Font,
    get FontStyle () { return FontStyle; },
    get GLCapabilityType () { return GLCapabilityType; },
    HingeJoint: HingeJoint,
    HitResult: HitResult,
    IndexBufferBinding: IndexBufferBinding,
    get IndexFormat () { return IndexFormat; },
    InputManager: InputManager,
    get InterpolationType () { return InterpolationType; },
    get Joint () { return Joint; },
    JointLimits: JointLimits,
    JointMotor: JointMotor,
    Keyframe: Keyframe,
    get Keys () { return exports.Keys; },
    get Layer () { return Layer; },
    Light: Light,
    Loader: Loader,
    Logger: Logger,
    Material: Material,
    Mesh: Mesh,
    MeshRenderer: MeshRenderer,
    get MeshTopology () { return MeshTopology; },
    ModelMesh: ModelMesh,
    get OverflowMode () { return OverflowMode; },
    PBRBaseMaterial: PBRBaseMaterial,
    PBRMaterial: PBRMaterial,
    PBRSpecularMaterial: PBRSpecularMaterial,
    ParticleRenderer: ParticleRenderer,
    get ParticleRendererBlendMode () { return ParticleRendererBlendMode; },
    PhysicsManager: PhysicsManager,
    PhysicsMaterial: PhysicsMaterial,
    get PhysicsMaterialCombineMode () { return PhysicsMaterialCombineMode; },
    get PipelineStage () { return PipelineStage; },
    PlaneColliderShape: PlaneColliderShape,
    get Platform () { return Platform; },
    PointLight: PointLight,
    Pointer: Pointer,
    get PointerButton () { return exports.PointerButton; },
    get PointerPhase () { return PointerPhase; },
    PrimitiveMesh: PrimitiveMesh,
    Probe: Probe,
    RasterState: RasterState,
    ReferResource: ReferResource,
    get RenderBufferDepthFormat () { return RenderBufferDepthFormat; },
    get RenderFace () { return RenderFace; },
    RenderPass: RenderPass,
    RenderQueue: RenderQueue,
    get RenderQueueType () { return RenderQueueType; },
    RenderState: RenderState,
    RenderTarget: RenderTarget,
    RenderTargetBlendState: RenderTargetBlendState,
    get Renderer () { return Renderer; },
    ResourceManager: ResourceManager,
    Scene: Scene,
    SceneManager: SceneManager,
    Script: Script,
    get SetDataOptions () { return SetDataOptions; },
    Shader: Shader,
    ShaderData: ShaderData,
    ShaderFactory: ShaderFactory,
    ShaderMacro: ShaderMacro,
    ShaderMacroCollection: ShaderMacroCollection,
    ShaderPass: ShaderPass,
    ShaderProperty: ShaderProperty,
    get ShaderPropertyType () { return ShaderPropertyType; },
    ShaderTagKey: ShaderTagKey,
    get ShadowCascadesMode () { return ShadowCascadesMode; },
    get ShadowResolution () { return ShadowResolution; },
    get ShadowType () { return exports.ShadowType; },
    Skin: Skin,
    SkinnedMeshRenderer: SkinnedMeshRenderer,
    Sky: Sky,
    SkyBoxMaterial: SkyBoxMaterial,
    SkyProceduralMaterial: SkyProceduralMaterial,
    SphereColliderShape: SphereColliderShape,
    SpotLight: SpotLight,
    SpringJoint: SpringJoint,
    Sprite: Sprite,
    SpriteAtlas: SpriteAtlas,
    get SpriteDrawMode () { return SpriteDrawMode; },
    SpriteMask: SpriteMask,
    get SpriteMaskInteraction () { return SpriteMaskInteraction; },
    get SpriteMaskLayer () { return SpriteMaskLayer; },
    SpriteRenderer: SpriteRenderer,
    get SpriteTileMode () { return SpriteTileMode; },
    StateMachineScript: StateMachineScript,
    StaticCollider: StaticCollider,
    get StencilOperation () { return StencilOperation; },
    StencilState: StencilState,
    SubMesh: SubMesh,
    SubShader: SubShader,
    get SunMode () { return SunMode; },
    SystemInfo: SystemInfo,
    get TextHorizontalAlignment () { return exports.TextHorizontalAlignment; },
    TextRenderer: TextRenderer,
    TextUtils: TextUtils,
    get TextVerticalAlignment () { return TextVerticalAlignment; },
    Texture: Texture,
    Texture2D: Texture2D,
    Texture2DArray: Texture2DArray,
    get TextureCoordinate () { return TextureCoordinate; },
    TextureCube: TextureCube,
    get TextureCubeFace () { return TextureCubeFace; },
    get TextureDepthCompareFunction () { return TextureDepthCompareFunction; },
    get TextureFilterMode () { return TextureFilterMode; },
    get TextureFormat () { return TextureFormat; },
    get TextureUsage () { return TextureUsage; },
    get TextureWrapMode () { return TextureWrapMode$1; },
    Time: Time,
    TrailMaterial: TrailMaterial,
    TrailRenderer: TrailRenderer,
    Transform: Transform,
    UnlitMaterial: UnlitMaterial,
    Utils: Utils,
    VertexBufferBinding: VertexBufferBinding,
    VertexElement: VertexElement,
    get VertexElementFormat () { return VertexElementFormat; },
    get WrapMode () { return WrapMode; },
    assignmentClone: assignmentClone,
    deepClone: deepClone,
    dependentComponents: dependentComponents,
    ignoreClone: ignoreClone,
    request: request,
    resourceLoader: resourceLoader,
    shallowClone: shallowClone
});

/**
 * Smoothing plug-in.
 * */ var GLCompressedTextureInternalFormat;
(function(GLCompressedTextureInternalFormat) {
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat[// astc
    "RGBA_ASTC_4X4_KHR"] = 0x93b0] = "RGBA_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X4_KHR"] = 0x93b1] = "RGBA_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_5X5_KHR"] = 0x93b2] = "RGBA_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X5_KHR"] = 0x93b3] = "RGBA_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_6X6_KHR"] = 0x93b4] = "RGBA_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X5_KHR"] = 0x93b5] = "RGBA_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X6_KHR"] = 0x93b6] = "RGBA_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_8X8_KHR"] = 0x93b7] = "RGBA_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X5_KHR"] = 0x93b8] = "RGBA_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X6_KHR"] = 0x93b9] = "RGBA_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X8_KHR"] = 0x93ba] = "RGBA_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_10X10_KHR"] = 0x93bb] = "RGBA_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X10_KHR"] = 0x93bc] = "RGBA_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_ASTC_12X12_KHR"] = 0x93bd] = "RGBA_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_4X4_KHR"] = 0x93d0] = "SRGB8_ALPHA8_ASTC_4X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X4_KHR"] = 0x93d1] = "SRGB8_ALPHA8_ASTC_5X4_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_5X5_KHR"] = 0x93d2] = "SRGB8_ALPHA8_ASTC_5X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X5_KHR"] = 0x93d3] = "SRGB8_ALPHA8_ASTC_6X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_6X6_KHR"] = 0x93d4] = "SRGB8_ALPHA8_ASTC_6X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X5_KHR"] = 0x93d5] = "SRGB8_ALPHA8_ASTC_8X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X6_KHR"] = 0x93d6] = "SRGB8_ALPHA8_ASTC_8X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_8X8_KHR"] = 0x93d7] = "SRGB8_ALPHA8_ASTC_8X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X5_KHR"] = 0x93d8] = "SRGB8_ALPHA8_ASTC_10X5_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X6_KHR"] = 0x93d9] = "SRGB8_ALPHA8_ASTC_10X6_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X8_KHR"] = 0x93da] = "SRGB8_ALPHA8_ASTC_10X8_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_10X10_KHR"] = 0x93db] = "SRGB8_ALPHA8_ASTC_10X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X10_KHR"] = 0x93dc] = "SRGB8_ALPHA8_ASTC_12X10_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ASTC_12X12_KHR"] = 0x93dd] = "SRGB8_ALPHA8_ASTC_12X12_KHR";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat[// etc1
    "RGB_ETC1_WEBGL"] = 0x8d64] = "RGB_ETC1_WEBGL";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat[// etc2
    "R11_EAC"] = 0x9270] = "R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_R11_EAC"] = 0x9271] = "SIGNED_R11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RG11_EAC"] = 0x9272] = "RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SIGNED_RG11_EAC"] = 0x9273] = "SIGNED_RG11_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_ETC2"] = 0x9274] = "RGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ETC2"] = 0x9275] = "SRGB8_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 0x9276] = "RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 0x9277] = "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA8_ETC2_EAC"] = 0x9278] = "RGBA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["SRGB8_ALPHA8_ETC2_EAC"] = 0x9279] = "SRGB8_ALPHA8_ETC2_EAC";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat[// pvrtc
    "RGB_PVRTC_4BPPV1_IMG"] = 0x8c00] = "RGB_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGB_PVRTC_2BPPV1_IMG"] = 0x8c01] = "RGB_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_4BPPV1_IMG"] = 0x8c02] = "RGBA_PVRTC_4BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_PVRTC_2BPPV1_IMG"] = 0x8c03] = "RGBA_PVRTC_2BPPV1_IMG";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat[// s3tc
    "RGB_S3TC_DXT1_EXT"] = 0x83f0] = "RGB_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT1_EXT"] = 0x83f1] = "RGBA_S3TC_DXT1_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT3_EXT"] = 0x83f2] = "RGBA_S3TC_DXT3_EXT";
    GLCompressedTextureInternalFormat[GLCompressedTextureInternalFormat["RGBA_S3TC_DXT5_EXT"] = 0x83f3] = "RGBA_S3TC_DXT5_EXT";
})(GLCompressedTextureInternalFormat || (GLCompressedTextureInternalFormat = {}));

function _defineProperties$2(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$2(Constructor, staticProps);

    return Constructor;
}

function _instanceof$1(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

/**
 * The canvas used on the web, which can support HTMLCanvasElement and OffscreenCanvas.
 */ var WebCanvas = /*#__PURE__*/ function() {
    function WebCanvas(webCanvas) {
        this._scale = new Vector2();
        var width = webCanvas.width;
        var height = webCanvas.height;
        this._webCanvas = webCanvas;
        this._width = width;
        this._height = height;
    }
    var _proto = WebCanvas.prototype;
    /**
   * Resize the rendering size according to the clientWidth and clientHeight of the canvas.
   * @param pixelRatio - Pixel ratio
   */ _proto.resizeByClientSize = function resizeByClientSize(pixelRatio) {
        if (pixelRatio === void 0) pixelRatio = PlatformManager$1.polyfill.window.devicePixelRatio;
        var webCanvas = this._webCanvas;
        if (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, PlatformManager$1.polyfill.OffscreenCanvas)) {
            this.width = webCanvas.clientWidth * pixelRatio;
            this.height = webCanvas.clientHeight * pixelRatio;
        }
    };
    /**
   * Set scale.
   * @param x - Scale along the X axis
   * @param y - Scale along the Y axis
   */ _proto.setScale = function setScale(x, y) {
        this._scale.set(x, y);
        this.scale = this._scale;
    };
    _create_class$2(WebCanvas, [
        {
            key: "width",
            get: /**
   * @inheritdoc
   */ function get() {
                return this._width;
            },
            set: function set(value) {
                if (this._width !== value) {
                    this._webCanvas.width = value;
                    this._width = value;
                }
            }
        },
        {
            key: "height",
            get: /**
   * @inheritdoc
   */ function get() {
                return this._height;
            },
            set: function set(value) {
                if (this._height !== value) {
                    this._webCanvas.height = value;
                    this._height = value;
                }
            }
        },
        {
            key: "scale",
            get: /**
   * The scale of canvas, the value is visible width/height divide the render width/height.
   * @remarks Need to re-assign after modification to ensure that the modification takes effect.
   */ function get() {
                var webCanvas = this._webCanvas;
                if (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, PlatformManager$1.polyfill.OffscreenCanvas)) {
                    this._scale.set(webCanvas.clientWidth * devicePixelRatio / webCanvas.width, webCanvas.clientHeight * devicePixelRatio / webCanvas.height);
                }
                return this._scale;
            },
            set: function set(value) {
                var webCanvas = this._webCanvas;
                if (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, PlatformManager$1.polyfill.OffscreenCanvas)) {
                    webCanvas.style.transformOrigin = "left top";
                    webCanvas.style.transform = "scale(" + value.x + ", " + value.y + ")";
                }
            }
        }
    ]);
    return WebCanvas;
}();

function _set_prototype_of$1(o, p) {
    _set_prototype_of$1 = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of$1(o, p);
}

function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of$1(subClass, superClass);
}

/**
 * WebGL platform engine,support includes WebGL1.0 and WebGL2.0.
 */ var WebGLEngine = /*#__PURE__*/ function(Engine) {
    _inherits$1(WebGLEngine, Engine);
    function WebGLEngine() {
        return Engine.apply(this, arguments);
    }
    /**
   * Create a WebGL engine.
   * @param configuration - WebGL engine configuration
   * @returns A promise that will resolve when the engine is created
   */ WebGLEngine.create = function create(configuration) {
        var canvas = configuration.canvas;
        var webCanvas = new WebCanvas(typeof canvas === "string" ? PlatformManager$1.polyfill.document.getElementById(canvas) : canvas);
        var webGLGraphicDevice = new WebGLGraphicDevice(configuration.graphicDeviceOptions);
        var engine = new WebGLEngine(webCanvas, webGLGraphicDevice, configuration);
        // @ts-ignore
        return engine._initialize(configuration);
    };
    _create_class$2(WebGLEngine, [
        {
            key: "canvas",
            get: /**
   * Web canvas.
   */ function get() {
                // @ts-ignore
                return this._canvas;
            }
        }
    ]);
    return WebGLEngine;
}(Engine);

function _extends$1() {
    _extends$1 = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends$1.apply(this, arguments);
}

var GLBuffer = /*#__PURE__*/ function() {
    function GLBuffer(rhi, type, byteLength, bufferUsage, data) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        var gl = rhi.gl;
        var glBuffer = gl.createBuffer();
        var glBufferUsage = this._getGLBufferUsage(gl, bufferUsage);
        var glBindTarget = type === BufferBindFlag.VertexBuffer ? gl.ARRAY_BUFFER : gl.ELEMENT_ARRAY_BUFFER;
        this._gl = gl;
        this._glBuffer = glBuffer;
        this._glBufferUsage = glBufferUsage;
        this._glBindTarget = glBindTarget;
        this._isWebGL2 = rhi.isWebGL2;
        this.bind();
        if (data) {
            gl.bufferData(glBindTarget, data, glBufferUsage);
        } else {
            gl.bufferData(glBindTarget, byteLength, glBufferUsage);
        }
        gl.bindBuffer(glBindTarget, null);
    }
    var _proto = GLBuffer.prototype;
    _proto.bind = function bind() {
        this._gl.bindBuffer(this._glBindTarget, this._glBuffer);
    };
    _proto.setData = function setData(byteLength, data, bufferByteOffset, dataOffset, dataLength, options) {
        var gl = this._gl;
        var glBindTarget = this._glBindTarget;
        this.bind();
        if (options === SetDataOptions.Discard) {
            gl.bufferData(glBindTarget, byteLength, this._glBufferUsage);
        }
        // TypeArray is BYTES_PER_ELEMENT, unTypeArray is 1
        var byteSize = data.BYTES_PER_ELEMENT || 1;
        var dataByteLength = dataLength ? byteSize * dataLength : data.byteLength;
        if (dataOffset !== 0 || dataByteLength < data.byteLength) {
            var isArrayBufferView = data.byteOffset !== undefined;
            if (this._isWebGL2 && isArrayBufferView) {
                gl.bufferSubData(glBindTarget, bufferByteOffset, data, dataOffset, dataByteLength / byteSize);
            } else {
                var subData = new Uint8Array(isArrayBufferView ? data.buffer : data, dataOffset * byteSize, dataByteLength);
                gl.bufferSubData(glBindTarget, bufferByteOffset, subData);
            }
        } else {
            gl.bufferSubData(glBindTarget, bufferByteOffset, data);
        }
        gl.bindBuffer(glBindTarget, null);
    };
    _proto.getData = function getData(data, bufferByteOffset, dataOffset, dataLength) {
        if (this._isWebGL2) {
            var gl = this._gl;
            this.bind();
            gl.getBufferSubData(this._glBindTarget, bufferByteOffset, data, dataOffset, dataLength);
        } else {
            throw "Buffer is write-only on WebGL1.0 platforms.";
        }
    };
    _proto.resize = function resize(byteLength) {
        this.bind();
        this._gl.bufferData(this._glBindTarget, byteLength, this._glBufferUsage);
    };
    _proto.destroy = function destroy() {
        this._gl.deleteBuffer(this._glBuffer);
        this._gl = null;
        this._glBuffer = null;
    };
    _proto._getGLBufferUsage = function _getGLBufferUsage(gl, bufferUsage) {
        switch(bufferUsage){
            case BufferUsage.Static:
                return gl.STATIC_DRAW;
            case BufferUsage.Dynamic:
                return gl.DYNAMIC_DRAW;
            case BufferUsage.Stream:
                return gl.STREAM_DRAW;
        }
    };
    return GLBuffer;
}();

/**
 * GL capability.
 */ var GLCapability = /*#__PURE__*/ function() {
    function GLCapability(rhi) {
        this._rhi = rhi;
        this.capabilityList = new Map();
        this._init();
        this._compatibleAllInterface();
    }
    var _proto = GLCapability.prototype;
    /**
   * Check device capabilities.
   */ _proto.canIUse = function canIUse(capabilityType) {
        return this.capabilityList.get(capabilityType);
    };
    /**
   * Check if can use some compressed texture format.
   */ _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(internalType) {
        var // astc
        RGBA_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR, RGBA_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR, SRGB8_ALPHA8_ASTC_4X4_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_4X4_KHR, SRGB8_ALPHA8_ASTC_12X12_KHR = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ASTC_12X12_KHR, // etc1
        RGB_ETC1_WEBGL = GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL, // etc
        R11_EAC = GLCompressedTextureInternalFormat.R11_EAC, SRGB8_ALPHA8_ETC2_EAC = GLCompressedTextureInternalFormat.SRGB8_ALPHA8_ETC2_EAC, // pvrtc
        RGB_PVRTC_4BPPV1_IMG = GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG, RGBA_PVRTC_2BPPV1_IMG = GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG, // s3tc
        RGB_S3TC_DXT1_EXT = GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT, RGBA_S3TC_DXT5_EXT = GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT;
        if (internalType >= RGBA_ASTC_4X4_KHR && RGBA_ASTC_12X12_KHR <= RGBA_ASTC_12X12_KHR || internalType >= SRGB8_ALPHA8_ASTC_4X4_KHR && internalType <= SRGB8_ALPHA8_ASTC_12X12_KHR) {
            return this.canIUse(GLCapabilityType.astc);
        } else if (internalType === RGB_ETC1_WEBGL) {
            return this.canIUse(GLCapabilityType.etc1);
        } else if (internalType >= R11_EAC && internalType <= SRGB8_ALPHA8_ETC2_EAC) {
            return this.canIUse(GLCapabilityType.etc);
        } else if (internalType >= RGB_PVRTC_4BPPV1_IMG && internalType <= RGBA_PVRTC_2BPPV1_IMG) {
            return this.canIUse(GLCapabilityType.pvrtc);
        } else if (internalType >= RGB_S3TC_DXT1_EXT && internalType <= RGBA_S3TC_DXT5_EXT) {
            return this.canIUse(GLCapabilityType.s3tc);
        }
        return false;
    };
    /**
   *  Init capabilities.
   */ _proto._init = function _init() {
        var cap = this.capabilityList;
        var isWebGL2 = this.rhi.isWebGL2;
        var requireExtension = this.rhi.requireExtension.bind(this.rhi);
        var shaderVertexID = GLCapabilityType.shaderVertexID, standardDerivatives = GLCapabilityType.standardDerivatives, shaderTextureLod = GLCapabilityType.shaderTextureLod, elementIndexUint = GLCapabilityType.elementIndexUint, depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, multipleSample = GLCapabilityType.multipleSample, drawBuffers = GLCapabilityType.drawBuffers, astc = GLCapabilityType.astc, astc_webkit = GLCapabilityType.astc_webkit, etc = GLCapabilityType.etc, etc_webkit = GLCapabilityType.etc_webkit, etc1 = GLCapabilityType.etc1, etc1_webkit = GLCapabilityType.etc1_webkit, pvrtc = GLCapabilityType.pvrtc, pvrtc_webkit = GLCapabilityType.pvrtc_webkit, s3tc = GLCapabilityType.s3tc, s3tc_webkit = GLCapabilityType.s3tc_webkit, textureFloat = GLCapabilityType.textureFloat, textureHalfFloat = GLCapabilityType.textureHalfFloat, textureFloatLinear = GLCapabilityType.textureFloatLinear, textureHalfFloatLinear = GLCapabilityType.textureHalfFloatLinear, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat, colorBufferFloat = GLCapabilityType.colorBufferFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic;
        cap.set(shaderVertexID, isWebGL2);
        cap.set(standardDerivatives, isWebGL2 || !!requireExtension(standardDerivatives));
        cap.set(shaderTextureLod, isWebGL2 || !!requireExtension(shaderTextureLod));
        cap.set(elementIndexUint, isWebGL2 || !!requireExtension(elementIndexUint));
        cap.set(depthTexture, isWebGL2 || !!requireExtension(depthTexture));
        cap.set(vertexArrayObject, isWebGL2 || !!requireExtension(vertexArrayObject));
        cap.set(instancedArrays, isWebGL2 || !!requireExtension(instancedArrays));
        cap.set(multipleSample, isWebGL2);
        cap.set(drawBuffers, isWebGL2 || !!requireExtension(drawBuffers));
        cap.set(textureFloat, isWebGL2 || !!requireExtension(textureFloat));
        cap.set(textureHalfFloat, isWebGL2 || !!requireExtension(textureHalfFloat));
        cap.set(textureFloatLinear, !!requireExtension(textureFloatLinear));
        cap.set(textureHalfFloatLinear, isWebGL2 || !!requireExtension(textureHalfFloatLinear));
        cap.set(colorBufferFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(WEBGL_colorBufferFloat));
        cap.set(colorBufferHalfFloat, isWebGL2 && !!requireExtension(colorBufferFloat) || !!requireExtension(colorBufferHalfFloat));
        cap.set(textureFilterAnisotropic, !!requireExtension(textureFilterAnisotropic));
        cap.set(astc, !!(requireExtension(astc) || requireExtension(astc_webkit)));
        cap.set(etc, !!(requireExtension(etc) || requireExtension(etc_webkit)));
        cap.set(etc1, !!(requireExtension(etc1) || requireExtension(etc1_webkit)));
        cap.set(pvrtc, !!(requireExtension(pvrtc) || requireExtension(pvrtc_webkit)));
        cap.set(s3tc, !!(requireExtension(s3tc) || requireExtension(s3tc_webkit)));
    };
    /**
   * If there are extensions that can supplement this ability, smooth out the difference.
   * @example
   * compatible(GLCapabilityType.depthTexture,{
   *    UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
   * })
   * gl.UNSIGNED_INT_24_8 = ext.UNSIGNED_INT_24_8_WEBGL
   */ _proto._compatibleInterface = function _compatibleInterface(capabilityType, flatItem) {
        var rhi = this.rhi;
        var gl = rhi.gl;
        var ext = null;
        if (ext = rhi.requireExtension(capabilityType)) {
            for(var glKey in flatItem){
                var extensionKey = flatItem[glKey];
                var extensionVal = ext[extensionKey];
                // Mini game hack the native function,use â€œ.bindâ€ to smooth out if is â€œFuncionâ€.
                if (extensionVal == null ? void 0 : extensionVal.bind) {
                    gl[glKey] = extensionVal.bind(ext);
                } else {
                    gl[glKey] = extensionVal;
                }
            }
        }
    };
    _proto._compatibleAllInterface = function _compatibleAllInterface() {
        var depthTexture = GLCapabilityType.depthTexture, vertexArrayObject = GLCapabilityType.vertexArrayObject, instancedArrays = GLCapabilityType.instancedArrays, drawBuffers = GLCapabilityType.drawBuffers, textureFilterAnisotropic = GLCapabilityType.textureFilterAnisotropic, textureHalfFloat = GLCapabilityType.textureHalfFloat, colorBufferHalfFloat = GLCapabilityType.colorBufferHalfFloat, WEBGL_colorBufferFloat = GLCapabilityType.WEBGL_colorBufferFloat;
        var isWebGL2 = this.rhi.isWebGL2;
        if (!isWebGL2) {
            this._compatibleInterface(depthTexture, {
                UNSIGNED_INT_24_8: "UNSIGNED_INT_24_8_WEBGL"
            });
            this._compatibleInterface(vertexArrayObject, {
                createVertexArray: "createVertexArrayOES",
                deleteVertexArray: "deleteVertexArrayOES",
                isVertexArray: "isVertexArrayOES",
                bindVertexArray: "bindVertexArrayOES"
            });
            this._compatibleInterface(instancedArrays, {
                drawArraysInstanced: "drawArraysInstancedANGLE",
                drawElementsInstanced: "drawElementsInstancedANGLE",
                vertexAttribDivisor: "vertexAttribDivisorANGLE"
            });
            this._compatibleInterface(drawBuffers, {
                MAX_DRAW_BUFFERS: "MAX_DRAW_BUFFERS_WEBGL"
            });
            var items = {};
            if (this.canIUse(GLCapabilityType.drawBuffers)) {
                var maxDrawBuffers = this.maxDrawBuffers;
                for(var i = 0; i < maxDrawBuffers; i++){
                    i != 0 && (items["COLOR_ATTACHMENT" + i] = "COLOR_ATTACHMENT" + i + "_WEBGL");
                    items["DRAW_BUFFER" + i] = "DRAW_BUFFER" + i + "_WEBGL";
                }
                this._compatibleInterface(drawBuffers, _extends$1({
                    drawBuffers: "drawBuffersWEBGL"
                }, items));
            }
            this._compatibleInterface(textureHalfFloat, {
                HALF_FLOAT: "HALF_FLOAT_OES"
            });
            this._compatibleInterface(colorBufferHalfFloat, {
                RGBA16F: "RBGA16F_EXT"
            });
            this._compatibleInterface(WEBGL_colorBufferFloat, {
                RGBA32F: "RBGA32F_EXT"
            });
        }
        this._compatibleInterface(textureFilterAnisotropic, {
            TEXTURE_MAX_ANISOTROPY_EXT: "TEXTURE_MAX_ANISOTROPY_EXT"
        });
    };
    _create_class$2(GLCapability, [
        {
            key: "maxTextureSize",
            get: function get() {
                return this.rhi.renderStates.getParameter(this.rhi.gl.MAX_TEXTURE_SIZE);
            }
        },
        {
            key: "canUseFloatTextureBlendShape",
            get: function get() {
                return this.canIUse(GLCapabilityType.shaderVertexID) && this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
            }
        },
        {
            key: "canIUseMoreJoints",
            get: /**
   * Whether can use more joints.
   */ function get() {
                return this.canIUse(GLCapabilityType.textureFloat) && this.rhi.renderStates.getParameter(this.rhi.gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
            }
        },
        {
            key: "maxDrawBuffers",
            get: function get() {
                if (!this._maxDrawBuffers) {
                    if (this.canIUse(GLCapabilityType.drawBuffers)) {
                        this._maxDrawBuffers = this._rhi.gl.getParameter(this._rhi.gl.MAX_DRAW_BUFFERS);
                    } else {
                        this._maxDrawBuffers = 1;
                    }
                }
                return this._maxDrawBuffers;
            }
        },
        {
            key: "maxAnisoLevel",
            get: /**
   * Max anisoLevel.
   */ function get() {
                if (!this._maxAnisoLevel) {
                    var ext = this._rhi.requireExtension(GLCapabilityType.textureFilterAnisotropic);
                    this._maxAnisoLevel = ext ? this._rhi.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
                }
                return this._maxAnisoLevel;
            }
        },
        {
            key: "maxAntiAliasing",
            get: /**
   * Max MSAA count.
   */ function get() {
                if (!this._maxAntiAliasing) {
                    var gl = this._rhi.gl;
                    var canMSAA = this.canIUse(GLCapabilityType.multipleSample);
                    this._maxAntiAliasing = canMSAA ? gl.getParameter(gl.MAX_SAMPLES) : 1;
                }
                return this._maxAntiAliasing;
            }
        },
        {
            key: "rhi",
            get: function get() {
                return this._rhi;
            }
        }
    ]);
    return GLCapability;
}();

/**
 * GLContext extension.
 */ var GLExtensions = /*#__PURE__*/ function() {
    function GLExtensions(rhi) {
        this.rhi = rhi;
        this._requireResult = Object.assign({}, PlatformManager$1.polyfill.$defaultWebGLExtensions);
    }
    var _proto = GLExtensions.prototype;
    /**
   * Require an extension.
   */ _proto.requireExtension = function requireExtension(ext) {
        if (this._requireResult[ext] !== undefined) {
            return this._requireResult[ext];
        }
        this._requireResult[ext] = this.rhi.gl.getExtension(ext);
        return this._requireResult[ext];
    };
    return GLExtensions;
}();

/**
 * Improvement of VAO:
 * 1) WebGL2.0 must support VAO, almost all devices support vao extensions in webgl1.0, we can use PollyFill,only keep VAO mode.
 */ /**
 * @internal
 * GL platform primitive.
 */ var GLPrimitive = /*#__PURE__*/ function() {
    function GLPrimitive(rhi, primitive) {
        this._attribLocArray = [];
        this._vaoMap = new Map();
        this._primitive = primitive;
        this._canUseInstancedArrays = rhi.canIUse(GLCapabilityType.instancedArrays);
        this._useVao = rhi.canIUse(GLCapabilityType.vertexArrayObject);
        this._gl = rhi.gl;
    }
    var _proto = GLPrimitive.prototype;
    /**
   * Draw the primitive.
   */ _proto.draw = function draw(shaderProgram, subMesh) {
        var gl = this._gl;
        var primitive = this._primitive;
        // @ts-ignore
        var useVao = this._useVao && primitive._enableVAO;
        if (useVao) {
            // @ts-ignore
            if (primitive._bufferStructChanged) {
                this._clearVAO();
            }
            if (!this._vaoMap.has(shaderProgram.id)) {
                this._registerVAO(shaderProgram);
            }
            var vao = this._vaoMap.get(shaderProgram.id);
            gl.bindVertexArray(vao);
        } else {
            this._bindBufferAndAttrib(shaderProgram);
        }
        // @ts-ignore
        var _indexBufferBinding = primitive._indexBufferBinding, _instanceCount = primitive._instanceCount, _glIndexType = primitive._glIndexType, _glIndexByteCount = primitive._glIndexByteCount;
        var topology = subMesh.topology, start = subMesh.start, count = subMesh.count;
        if (!_instanceCount) {
            if (_indexBufferBinding) {
                if (useVao) {
                    gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
                } else {
                    var _glBuffer = _indexBufferBinding.buffer._platformBuffer._glBuffer;
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer);
                    gl.drawElements(topology, count, _glIndexType, start * _glIndexByteCount);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                }
            } else {
                gl.drawArrays(topology, start, count);
            }
        } else {
            if (this._canUseInstancedArrays) {
                if (_indexBufferBinding) {
                    if (useVao) {
                        gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
                    } else {
                        var _glBuffer1 = _indexBufferBinding.buffer._platformBuffer._glBuffer;
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _glBuffer1);
                        gl.drawElementsInstanced(topology, count, _glIndexType, start * _glIndexByteCount, _instanceCount);
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    }
                } else {
                    gl.drawArraysInstanced(topology, start, count, _instanceCount);
                }
            } else {
                Logger.error("ANGLE_instanced_arrays extension is not supported");
            }
        }
        // Unbind
        if (useVao) {
            gl.bindVertexArray(null);
        } else {
            this._disableAttrib();
        }
    };
    _proto.destroy = function destroy() {
        this._useVao && this._clearVAO();
    };
    /**
   * Bind buffer and attribute.
   */ _proto._bindBufferAndAttrib = function _bindBufferAndAttrib(shaderProgram) {
        var gl = this._gl;
        var primitive = this._primitive;
        // @ts-ignore
        var vertexBufferBindings = primitive._vertexBufferBindings;
        this._attribLocArray.length = 0;
        var attributeLocation = shaderProgram.attributeLocation;
        // @ts-ignore
        var attributes = primitive._vertexElementMap;
        var vbo;
        var lastBoundVbo;
        for(var name in attributeLocation){
            var loc = attributeLocation[name];
            if (loc === -1) continue;
            var element = attributes[name];
            if (element) {
                var _vertexBufferBindings_element_bindingIndex = vertexBufferBindings[element.bindingIndex], buffer = _vertexBufferBindings_element_bindingIndex.buffer, stride = _vertexBufferBindings_element_bindingIndex.stride;
                vbo = buffer._platformBuffer._glBuffer;
                // prevent binding the vbo which already bound at the last loop, e.g. a buffer with multiple attributes.
                if (lastBoundVbo !== vbo) {
                    lastBoundVbo = vbo;
                    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                }
                gl.enableVertexAttribArray(loc);
                var elementInfo = element._glElementInfo;
                gl.vertexAttribPointer(loc, elementInfo.size, elementInfo.type, elementInfo.normalized, stride, element.offset);
                if (this._canUseInstancedArrays) {
                    gl.vertexAttribDivisor(loc, element.instanceStepRate);
                }
                this._attribLocArray.push(loc);
            } else {
                Logger.warn("vertex attribute not found: " + name);
            }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };
    _proto._disableAttrib = function _disableAttrib() {
        var gl = this._gl;
        for(var i = 0, l = this._attribLocArray.length; i < l; i++){
            gl.disableVertexAttribArray(this._attribLocArray[i]);
        }
    };
    _proto._registerVAO = function _registerVAO(shaderProgram) {
        var gl = this._gl;
        var vao = gl.createVertexArray();
        /** register VAO */ gl.bindVertexArray(vao);
        // @ts-ignore
        var _indexBufferBinding = this._primitive._indexBufferBinding;
        if (_indexBufferBinding) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBufferBinding.buffer._platformBuffer._glBuffer);
        }
        this._bindBufferAndAttrib(shaderProgram);
        /** unbind */ gl.bindVertexArray(null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        this._disableAttrib();
        this._vaoMap.set(shaderProgram.id, vao);
    };
    _proto._clearVAO = function _clearVAO() {
        var gl = this._gl;
        this._vaoMap.forEach(function(vao) {
            gl.deleteVertexArray(vao);
        });
        this._vaoMap.clear();
    };
    return GLPrimitive;
}();

/**
 * @private
 */ var GLRenderStates = /*#__PURE__*/ function() {
    function GLRenderStates(gl) {
        this._parameters = {};
        this._gl = gl;
        this._parameters = {}; // current gl state parameters
        /** cache */ this._parameters[gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_VERTEX_UNIFORM_VECTORS] = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this._parameters[gl.MAX_VERTEX_ATTRIBS] = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._parameters[gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS] = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._parameters[gl.MAX_TEXTURE_SIZE] = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        // init blend state same as BlendState default value.
        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.colorMask(true, true, true, true);
        gl.blendColor(0, 0, 0, 0);
        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        // init depth state same as DepthState default value.
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(true);
        // init stencil state same as StencilState default value.
        gl.disable(gl.STENCIL_TEST);
        gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 0, 0xff);
        gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 0, 0xff);
        gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(0xff);
        // init raster state same as RasterState default value.
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(0, 0);
    }
    var _proto = GLRenderStates.prototype;
    /**
   * Get a parameter.
   */ _proto.getParameter = function getParameter(pname) {
        return this._parameters[pname];
    };
    return GLRenderStates;
}();

/**
 * Texture in WebGL platform.
 */ var GLTexture = /*#__PURE__*/ function() {
    function GLTexture(rhi, texture, target) {
        this._texture = texture;
        this._rhi = rhi;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        this._glTexture = this._gl.createTexture();
    }
    var _proto = GLTexture.prototype;
    /**
   * Destroy texture.
   */ _proto.destroy = function destroy() {
        this._gl.deleteTexture(this._glTexture);
        this._texture = null;
        this._glTexture = null;
        this._formatDetail = null;
    };
    /**
   * @internal
   */ _proto.setUseDepthCompareMode = function setUseDepthCompareMode(value) {
        var gl = this._gl;
        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_MODE, value ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
    };
    /**
   * Generate multi-level textures based on the 0th level data.
   */ _proto.generateMipmaps = function generateMipmaps() {
        // @todo (1x1).generateMipmap() will flash back in uc.
        if (this._texture.width !== 1 || this._texture.height !== 1) {
            this._bind();
            this._gl.generateMipmap(this._target);
        }
    };
    _proto._bind = function _bind() {
        this._rhi.bindTexture(this);
    };
    /**
   * Pre-development mipmapping GPU memory.
   */ _proto._init = function _init(isCube) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        // @ts-ignore
        var _this__texture = this._texture, mipmapCount = _this__texture.mipmapCount, width = _this__texture.width, height = _this__texture.height, usage = _this__texture.usage, _isDepthTexture = _this__texture._isDepthTexture;
        this._bind();
        if (isWebGL2 && !(baseFormat === gl.LUMINANCE_ALPHA || baseFormat === gl.ALPHA) && usage !== TextureUsage.Dynamic) {
            gl.texStorage2D(this._target, mipmapCount, internalFormat, width, height);
        } else {
            if (!isCube) {
                if (_isDepthTexture) {
                    gl.texImage2D(this._target, 0, internalFormat, width, height, 0, baseFormat, dataType, null);
                } else {
                    for(var i = 0; i < mipmapCount; i++){
                        var mipWidth = Math.max(1, width >> i);
                        var mipHeight = Math.max(1, height >> i);
                        gl.texImage2D(this._target, i, internalFormat, mipWidth, mipHeight, 0, baseFormat, dataType, null);
                    }
                }
            } else {
                for(var i1 = 0; i1 < mipmapCount; i1++){
                    var size = Math.max(1, width >> i1);
                    for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, i1, internalFormat, size, size, 0, baseFormat, dataType, null);
                    }
                }
            }
        }
    };
    /**
   * Get the pixel color buffer according to the specified cube face and area.
   * @param face - You can choose which cube face to read
   * @param x - X coordinate of area start
   * @param y - Y coordinate of area start
   * @param width - Area width
   * @param height - Area height
   * @param out - Color buffer
   * @param mipLevel - Set mip level the data want to get from
   */ _proto._getPixelBuffer = function _getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        if (mipLevel > 0 && !this._isWebGL2) {
            mipLevel = 0;
            Logger.error("mipLevel only take effect in WebGL2.0");
        }
        if (face != null) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, this._glTexture, mipLevel);
        } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._glTexture, mipLevel);
        }
        gl.readPixels(x, y, width, height, baseFormat, dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    _proto._setWrapMode = function _setWrapMode(value, pname) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var target = this._target;
        var _this__texture = this._texture, width = _this__texture.width, height = _this__texture.height;
        if (!isWebGL2 && value !== TextureWrapMode$1.Clamp && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
            Logger.warn("non-power-2 texture is not supported for REPEAT or MIRRORED_REPEAT in WebGL1,and has automatically downgraded to CLAMP_TO_EDGE");
            value = TextureWrapMode$1.Clamp;
        }
        switch(value){
            case TextureWrapMode$1.Clamp:
                gl.texParameteri(target, pname, gl.CLAMP_TO_EDGE);
                break;
            case TextureWrapMode$1.Repeat:
                gl.texParameteri(target, pname, gl.REPEAT);
                break;
            case TextureWrapMode$1.Mirror:
                gl.texParameteri(target, pname, gl.MIRRORED_REPEAT);
                break;
        }
    };
    _proto._getReadFrameBuffer = function _getReadFrameBuffer() {
        var frameBuffer = this._rhi._readFrameBuffer;
        if (!frameBuffer) {
            this._rhi._readFrameBuffer = frameBuffer = this._gl.createFramebuffer();
        }
        return frameBuffer;
    };
    /** @internal */ GLTexture._isPowerOf2 = function _isPowerOf2(v) {
        return (v & v - 1) === 0;
    };
    /**
   * Get more texture info from TextureFormat.
   * @internal
   */ GLTexture._getFormatDetail = function _getFormatDetail(format, gl, isWebGL2) {
        switch(format){
            case TextureFormat.R8G8B8:
                return {
                    internalFormat: isWebGL2 ? gl.RGB8 : gl.RGB,
                    baseFormat: gl.RGB,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false
                };
            case TextureFormat.R8G8B8A8:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA8 : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false
                };
            case TextureFormat.R4G4B4A4:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA4 : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_SHORT_4_4_4_4,
                    isCompressed: false
                };
            case TextureFormat.R5G5B5A1:
                return {
                    internalFormat: isWebGL2 ? gl.RGB5_A1 : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.UNSIGNED_SHORT_5_5_5_1,
                    isCompressed: false
                };
            case TextureFormat.R5G6B5:
                return {
                    internalFormat: isWebGL2 ? gl.RGB565 : gl.RGB,
                    baseFormat: gl.RGB,
                    dataType: gl.UNSIGNED_SHORT_5_6_5,
                    isCompressed: false
                };
            case TextureFormat.Alpha8:
                return {
                    internalFormat: gl.ALPHA,
                    baseFormat: gl.ALPHA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false
                };
            case TextureFormat.LuminanceAlpha:
                return {
                    internalFormat: gl.LUMINANCE_ALPHA,
                    baseFormat: gl.LUMINANCE_ALPHA,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false
                };
            case TextureFormat.R16G16B16A16:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA16F : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.HALF_FLOAT,
                    isCompressed: false
                };
            case TextureFormat.R32G32B32A32:
                return {
                    internalFormat: isWebGL2 ? gl.RGBA32F : gl.RGBA,
                    baseFormat: gl.RGBA,
                    dataType: gl.FLOAT,
                    isCompressed: false
                };
            case TextureFormat.DXT1:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT,
                    isCompressed: true
                };
            case TextureFormat.DXT5:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT,
                    isCompressed: true
                };
            case TextureFormat.ETC1_RGB:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGB:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB8_ETC2,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGBA5:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                    isCompressed: true
                };
            case TextureFormat.ETC2_RGBA8:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGB2:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGBA2:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGB4:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.PVRTC_RGBA4:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG,
                    isCompressed: true
                };
            case TextureFormat.ASTC_4x4:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_5x5:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_6x6:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_8x8:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_10x10:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR,
                    isCompressed: true
                };
            case TextureFormat.ASTC_12x12:
                return {
                    internalFormat: GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR,
                    isCompressed: true
                };
            case TextureFormat.Depth:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.DepthStencil:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case TextureFormat.Depth16:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT16 : gl.DEPTH_COMPONENT,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth24Stencil8:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case TextureFormat.Depth24:
                return {
                    internalFormat: gl.DEPTH_COMPONENT24,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_INT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth32:
                return {
                    internalFormat: gl.DEPTH_COMPONENT32F,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case TextureFormat.Depth32Stencil8:
                return {
                    internalFormat: gl.DEPTH32F_STENCIL8,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            default:
                throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
        }
    };
    /**
   * In WebGL 1, internalformat must be the same as baseFormat when call texImage2D.
   * @internal
   */ GLTexture._getRenderBufferDepthFormatDetail = function _getRenderBufferDepthFormatDetail(format, gl, isWebGL2) {
        switch(format){
            case RenderBufferDepthFormat.Depth:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: isWebGL2 ? gl.FLOAT : gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case RenderBufferDepthFormat.DepthStencil:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH32F_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: isWebGL2 ? gl.FLOAT_32_UNSIGNED_INT_24_8_REV : gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case RenderBufferDepthFormat.Stencil:
                return {
                    internalFormat: gl.STENCIL_INDEX8,
                    baseFormat: gl.STENCIL_ATTACHMENT,
                    dataType: gl.UNSIGNED_BYTE,
                    isCompressed: false,
                    attachment: gl.STENCIL_ATTACHMENT
                };
            case RenderBufferDepthFormat.Depth16:
                return {
                    internalFormat: gl.DEPTH_COMPONENT16,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_SHORT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case RenderBufferDepthFormat.Depth24Stencil8:
                return {
                    internalFormat: isWebGL2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.UNSIGNED_INT_24_8,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            case RenderBufferDepthFormat.Depth24:
                return {
                    internalFormat: gl.DEPTH_COMPONENT24,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.UNSIGNED_INT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case RenderBufferDepthFormat.Depth32:
                return {
                    internalFormat: gl.DEPTH_COMPONENT32F,
                    baseFormat: gl.DEPTH_COMPONENT,
                    dataType: gl.FLOAT,
                    isCompressed: false,
                    attachment: gl.DEPTH_ATTACHMENT
                };
            case RenderBufferDepthFormat.Depth32Stencil8:
                return {
                    internalFormat: gl.DEPTH32F_STENCIL8,
                    baseFormat: gl.DEPTH_STENCIL,
                    dataType: gl.FLOAT_32_UNSIGNED_INT_24_8_REV,
                    isCompressed: false,
                    attachment: gl.DEPTH_STENCIL_ATTACHMENT
                };
            default:
                throw new Error("this TextureFormat is not supported in Galacean Engine: " + format);
        }
    };
    /**
   * Check whether the corresponding texture format is supported.
   * @internal
   */ GLTexture._supportTextureFormat = function _supportTextureFormat(format, rhi) {
        switch(format){
            case TextureFormat.R16G16B16A16:
                if (!rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
                    return false;
                }
                break;
            case TextureFormat.R32G32B32A32:
                if (!rhi.canIUse(GLCapabilityType.textureFloat)) {
                    return false;
                }
                break;
            case TextureFormat.Depth16:
            case TextureFormat.Depth24Stencil8:
            case TextureFormat.Depth:
            case TextureFormat.DepthStencil:
                if (!rhi.canIUse(GLCapabilityType.depthTexture)) {
                    return false;
                }
                break;
            case TextureFormat.Depth24:
            case TextureFormat.Depth32:
            case TextureFormat.Depth32Stencil8:
                return rhi.isWebGL2;
        }
        return true;
    };
    /**
   * @internal
   */ GLTexture._supportRenderBufferColorFormat = function _supportRenderBufferColorFormat(format, rhi) {
        var isSupported = true;
        switch(format){
            case TextureFormat.R16G16B16A16:
                {
                    if (!rhi.canIUse(GLCapabilityType.colorBufferHalfFloat) || !rhi.canIUse(GLCapabilityType.textureHalfFloat)) {
                        isSupported = false;
                    }
                }
                break;
            case TextureFormat.R32G32B32A32:
                {
                    if (!rhi.canIUse(GLCapabilityType.colorBufferFloat) || !rhi.canIUse(GLCapabilityType.textureFloat)) {
                        isSupported = false;
                    }
                }
                break;
        }
        return isSupported;
    };
    /**
   * @internal
   */ GLTexture._supportRenderBufferDepthFormat = function _supportRenderBufferDepthFormat(format, rhi) {
        if (!rhi.isWebGL2) {
            switch(format){
                case RenderBufferDepthFormat.Depth24:
                case RenderBufferDepthFormat.Depth32:
                case RenderBufferDepthFormat.Depth32Stencil8:
                    return false;
            }
        }
        return true;
    };
    _create_class$2(GLTexture, [
        {
            key: "wrapModeU",
            set: /**
   * Wrapping mode for texture coordinate S.
   */ function set(value) {
                this._bind();
                this._setWrapMode(value, this._gl.TEXTURE_WRAP_S);
            }
        },
        {
            key: "wrapModeV",
            set: /**
   * Wrapping mode for texture coordinate T.
   */ function set(value) {
                this._bind();
                this._setWrapMode(value, this._gl.TEXTURE_WRAP_T);
            }
        },
        {
            key: "filterMode",
            set: /**
   * Filter mode for texture.
   */ function set(value) {
                var gl = this._gl;
                var target = this._target;
                /** @ts-ignore */ var _mipmap = this._texture._mipmap;
                this._bind();
                switch(value){
                    case TextureFilterMode.Point:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.NEAREST_MIPMAP_NEAREST : gl.NEAREST);
                        break;
                    case TextureFilterMode.Bilinear:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
                        break;
                    case TextureFilterMode.Trilinear:
                        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _mipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
                        break;
                }
            }
        },
        {
            key: "anisoLevel",
            set: /**
   * Anisotropic level for texture.
   */ function set(value) {
                var gl = this._gl;
                this._bind();
                gl.texParameterf(this._target, gl.TEXTURE_MAX_ANISOTROPY_EXT, value);
            }
        },
        {
            key: "depthCompareFunction",
            set: function set(value) {
                this._bind();
                var gl = this._gl;
                switch(value){
                    case TextureDepthCompareFunction.Never:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NEVER);
                        break;
                    case TextureDepthCompareFunction.Less:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LESS);
                        break;
                    case TextureDepthCompareFunction.Equal:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.EQUAL);
                        break;
                    case TextureDepthCompareFunction.LessEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
                        break;
                    case TextureDepthCompareFunction.Greater:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GREATER);
                        break;
                    case TextureDepthCompareFunction.NotEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.NOTEQUAL);
                        break;
                    case TextureDepthCompareFunction.GreaterEqual:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.GEQUAL);
                        break;
                    case TextureDepthCompareFunction.Always:
                        gl.texParameteri(this._target, gl.TEXTURE_COMPARE_FUNC, gl.ALWAYS);
                        break;
                }
            }
        }
    ]);
    return GLTexture;
}();

/**
 * The render target in WebGL platform is used for off-screen rendering.
 */ var GLRenderTarget = /*#__PURE__*/ function() {
    function GLRenderTarget(rhi, target) {
        this._MSAAColorRenderBuffers = [];
        this._curMipLevel = 0;
        this._gl = rhi.gl;
        this._isWebGL2 = rhi.isWebGL2;
        this._target = target;
        /** @ts-ignore */ var _colorTextures = target._colorTextures, _depth = target._depth, width = target.width, height = target.height;
        var isDepthTexture = _instanceof$1(_depth, Texture);
        /** todo
     * MRT + Cube + [,MSAA]
     * MRT + MSAA
     */ for(var i = 0, n = _colorTextures.length; i < n; i++){
            var format = _colorTextures[i]._format;
            if (!GLTexture._supportRenderBufferColorFormat(format, rhi)) {
                throw new Error("TextureFormat is not supported:" + TextureFormat[format] + " in RenderTarget");
            }
        }
        if (!isDepthTexture && !GLTexture._supportRenderBufferDepthFormat(_depth, rhi)) {
            throw new Error("TextureFormat is not supported:" + TextureFormat[_depth] + " in RenderTarget");
        }
        if (_colorTextures.length > 1 && !rhi.canIUse(GLCapabilityType.drawBuffers)) {
            throw new Error("MRT is not supported");
        }
        if (_colorTextures.some(function(v) {
            return v.width !== width || v.height !== height;
        })) {
            throw new Error("ColorTexture's size must as same as RenderTarget");
        }
        if (isDepthTexture && (_depth.width !== width || _depth.height !== height)) {
            throw new Error("DepthTexture's size must as same as RenderTarget");
        }
        // todo: necessary to support MRT + Cube + [,MSAA] ?
        if (_colorTextures.length > 1 && _colorTextures.some(function(v) {
            return _instanceof$1(v, TextureCube);
        })) {
            throw new Error("MRT+Cube+[,MSAA] is not supported");
        }
        var maxAntiAliasing = rhi.capability.maxAntiAliasing;
        if (target.antiAliasing > maxAntiAliasing) {
            Logger.warn("MSAA antiAliasing exceeds the limit and is automatically downgraded to:" + maxAntiAliasing);
            /** @ts-ignore */ target._antiAliasing = maxAntiAliasing;
        }
        this._frameBuffer = this._gl.createFramebuffer();
        // bind main FBO
        this._bindMainFBO();
        // bind MSAA FBO
        if (target.antiAliasing > 1) {
            this._MSAAFrameBuffer = this._gl.createFramebuffer();
            this._bindMSAAFBO();
        }
    }
    var _proto = GLRenderTarget.prototype;
    /**
   * Set which face and mipLevel of the cube texture to render to.
   * @param faceIndex - Cube texture face
   * @param mipLevel - Set mip level the data want to write
   */ _proto.setRenderTargetInfo = function setRenderTargetInfo(faceIndex, mipLevel) {
        var _this = this, gl = _this._gl, target = _this._target;
        var depthTexture = target.depthTexture;
        var colorTexture = target.getColorTexture(0);
        var mipChanged = mipLevel !== this._curMipLevel;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        if (colorTexture) {
            var isCube = _instanceof$1(colorTexture, TextureCube);
            if (mipChanged || isCube) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, isCube ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, // @ts-ignore
                colorTexture._platformTexture._glTexture, mipLevel);
            }
        }
        if (depthTexture) {
            var isCube1 = _instanceof$1(depthTexture, TextureCube);
            if (mipChanged || isCube1) {
                // @ts-ignore
                var platformTexture = depthTexture._platformTexture;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, isCube1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D, platformTexture._glTexture, mipLevel);
            }
        } else {
            if (mipChanged) {
                // @ts-ignore
                var internalFormat = GLTexture._getRenderBufferDepthFormatDetail(target._depth, gl, this._isWebGL2).internalFormat;
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width >> mipLevel, target.height >> mipLevel);
            }
        }
        this._curMipLevel = mipLevel;
        // revert current activated render target
        this._activeRenderTarget();
    };
    /**
   * Blit FBO.
   */ _proto.blitRenderTarget = function blitRenderTarget() {
        if (!this._MSAAFrameBuffer) return;
        var gl = this._gl;
        var mask = gl.COLOR_BUFFER_BIT | (this._target.depthTexture ? gl.DEPTH_BUFFER_BIT : 0);
        var _this__target = this._target, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._MSAAFrameBuffer);
        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
        for(var textureIndex = 0; textureIndex < colorTextureCount; textureIndex++){
            var attachment = gl.COLOR_ATTACHMENT0 + textureIndex;
            this._blitDrawBuffers[textureIndex] = attachment;
            gl.readBuffer(attachment);
            gl.drawBuffers(this._blitDrawBuffers);
            gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
            this._blitDrawBuffers[textureIndex] = gl.NONE;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    /**
   * Destroy render target.
   */ _proto.destroy = function destroy() {
        var gl = this._gl;
        this._frameBuffer && gl.deleteFramebuffer(this._frameBuffer);
        this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
        this._MSAAFrameBuffer && gl.deleteFramebuffer(this._MSAAFrameBuffer);
        this._MSAADepthRenderBuffer && gl.deleteRenderbuffer(this._MSAADepthRenderBuffer);
        for(var i = 0; i < this._MSAAColorRenderBuffers.length; i++){
            gl.deleteRenderbuffer(this._MSAAColorRenderBuffers[i]);
        }
        this._frameBuffer = null;
        this._depthRenderBuffer = null;
        this._MSAAFrameBuffer = null;
        this._MSAAColorRenderBuffers.length = 0;
        this._MSAADepthRenderBuffer = null;
    };
    /**
   * Activate this RenderTarget.
   * @internal
   * @remarks
   * If MSAA is turned on, MSAA FBO is activated, and then this._blitRenderTarget() is performed to exchange FBO.
   * If MSAA is not turned on, activate the main FBO.
   */ _proto._activeRenderTarget = function _activeRenderTarget() {
        var gl = this._gl;
        if (this._MSAAFrameBuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        }
    };
    _proto._bindMainFBO = function _bindMainFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        /** @ts-ignore */ var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, width = _this__target.width, height = _this__target.height;
        var drawBuffers = new Array(colorTextureCount);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
        /** color render buffer */ for(var i = 0; i < colorTextureCount; i++){
            var colorTexture = this._target.getColorTexture(i);
            var attachment = gl.COLOR_ATTACHMENT0 + i;
            drawBuffers[i] = attachment;
            if (!_instanceof$1(colorTexture, TextureCube)) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, /** @ts-ignore */ colorTexture._platformTexture._glTexture, 0);
            }
        }
        if (colorTextureCount > 1) {
            gl.drawBuffers(drawBuffers);
        }
        this._oriDrawBuffers = drawBuffers;
        /** depth render buffer */ if (_depth !== null) {
            if (_instanceof$1(_depth, Texture) && !_instanceof$1(_depth, TextureCube)) {
                // @ts-ignore
                var platformTexture = _depth._platformTexture;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, platformTexture._formatDetail.attachment, gl.TEXTURE_2D, platformTexture._glTexture, 0);
            } else if (this._target.antiAliasing <= 1) {
                var _GLTexture__getRenderBufferDepthFormatDetail = GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _GLTexture__getRenderBufferDepthFormatDetail.internalFormat, attachment1 = _GLTexture__getRenderBufferDepthFormatDetail.attachment;
                var depthRenderBuffer = gl.createRenderbuffer();
                this._depthRenderBuffer = depthRenderBuffer;
                gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment1, gl.RENDERBUFFER, depthRenderBuffer);
            }
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._bindMSAAFBO = function _bindMSAAFBO() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var MSAADepthRenderBuffer = gl.createRenderbuffer();
        /** @ts-ignore */ var _this__target = this._target, _depth = _this__target._depth, colorTextureCount = _this__target.colorTextureCount, antiAliasing = _this__target.antiAliasing, width = _this__target.width, height = _this__target.height;
        this._blitDrawBuffers = new Array(colorTextureCount);
        this._MSAADepthRenderBuffer = MSAADepthRenderBuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._MSAAFrameBuffer);
        // prepare MRT+MSAA color RBOs
        for(var i = 0; i < colorTextureCount; i++){
            var MSAAColorRenderBuffer = gl.createRenderbuffer();
            this._MSAAColorRenderBuffers[i] = MSAAColorRenderBuffer;
            this._blitDrawBuffers[i] = gl.NONE;
            gl.bindRenderbuffer(gl.RENDERBUFFER, MSAAColorRenderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, /** @ts-ignore */ this._target.getColorTexture(i)._platformTexture._formatDetail.internalFormat, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, MSAAColorRenderBuffer);
        }
        gl.drawBuffers(this._oriDrawBuffers);
        // prepare MSAA depth RBO
        if (_depth !== null) {
            var _ref = _instanceof$1(_depth, Texture) ? /** @ts-ignore */ _depth._platformTexture._formatDetail : GLTexture._getRenderBufferDepthFormatDetail(_depth, gl, isWebGL2), internalFormat = _ref.internalFormat, attachment = _ref.attachment;
            gl.bindRenderbuffer(gl.RENDERBUFFER, MSAADepthRenderBuffer);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, antiAliasing, internalFormat, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, MSAADepthRenderBuffer);
        }
        this._checkFrameBuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    _proto._checkFrameBuffer = function _checkFrameBuffer() {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        switch(e){
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete");
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                throw new Error("There is no attachment");
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                throw new Error(" Height and width of the attachment are not the same.");
            case gl.FRAMEBUFFER_UNSUPPORTED:
                throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer");
        }
        if (isWebGL2 && e === gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
            throw new Error("The values of gl.RENDERBUFFER_SAMPLES are different among attached renderbuffers, or are non-zero if the attached images are a mix of renderbuffers and textures.");
        }
    };
    return GLRenderTarget;
}();

/**
 * Texture 2d in WebGL platform.
 */ var GLTexture2D = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTexture2D, GLTexture1);
    function GLTexture2D(rhi, texture2D) {
        var _this;
        _this = GLTexture1.call(this, rhi, texture2D, rhi.gl.TEXTURE_2D) || this;
        /** Backward compatible with WebGL1.0. */ _this._compressedMipFilled = 0;
        /** @ts-ignore */ var format = texture2D.format, _mipmap = texture2D._mipmap, width = texture2D.width, height = texture2D.height;
        var isWebGL2 = _this._isWebGL2;
        /** @ts-ignore */ if (!GLTexture._supportTextureFormat(format, rhi)) {
            throw new Error("Texture format is not supported:" + TextureFormat[format]);
        }
        if (_mipmap && !isWebGL2 && (!GLTexture._isPowerOf2(width) || !GLTexture._isPowerOf2(height))) {
            Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
            /** @ts-ignore */ texture2D._mipmap = false;
            /** @ts-ignore */ texture2D._mipmapCount = texture2D._getMipmapCount();
        }
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._init(false);
        return _this;
    }
    var _proto = GLTexture2D.prototype;
    /**
   * {@inheritDoc IPlatformTexture2D.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(colorBuffer, mipLevel, x, y, width, height) {
        if (mipLevel === void 0) mipLevel = 0;
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
        var mipWidth = Math.max(1, this._texture.width >> mipLevel);
        var mipHeight = Math.max(1, this._texture.height >> mipLevel);
        width = width || mipWidth - x;
        height = height || mipHeight - y;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
            var mipBit = 1 << mipLevel;
            if (isWebGL2 || this._compressedMipFilled & mipBit) {
                gl.compressedTexSubImage2D(this._target, mipLevel, x, y, width, height, internalFormat, colorBuffer);
            } else {
                gl.compressedTexImage2D(this._target, mipLevel, internalFormat, width, height, 0, colorBuffer);
                this._compressedMipFilled |= mipBit;
            }
        } else {
            gl.texSubImage2D(this._target, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2D.setImageSource}
   */ _proto.setImageSource = function setImageSource(imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        if (this._texture.usage === TextureUsage.Dynamic) {
            gl.texImage2D(this._target, mipLevel, internalFormat, baseFormat, dataType, imageSource);
        } else {
            gl.texSubImage2D(this._target, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2D.getPixelBuffer }
   */ _proto.getPixelBuffer = function getPixelBuffer(x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        GLTexture1.prototype._getPixelBuffer.call(this, null, x, y, width, height, mipLevel, out);
    };
    return GLTexture2D;
}(GLTexture);

/**
 * Texture 2D array in WebGL platform.
 */ var GLTexture2DArray = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTexture2DArray, GLTexture1);
    function GLTexture2DArray(rhi, texture2DArray) {
        var _this;
        _this = GLTexture1.call(this, rhi, texture2DArray, rhi.gl.TEXTURE_2D_ARRAY) || this;
        var format = texture2DArray.format, width = texture2DArray.width, height = texture2DArray.height, length = texture2DArray.length, mipmapCount = texture2DArray.mipmapCount;
        if (!_this._isWebGL2) {
            throw new Error("Texture2D Array is not supported in WebGL1.0");
        }
        /** @ts-ignore */ if (!GLTexture._supportTextureFormat(format, rhi)) {
            throw new Error("Texture format is not supported:" + TextureFormat[format]);
        }
        _this._bind();
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, true);
        _this._gl.texStorage3D(_this._target, mipmapCount, _this._formatDetail.internalFormat, width, height, length);
        return _this;
    }
    var _proto = GLTexture2DArray.prototype;
    /**
   * {@inheritDoc IPlatformTexture2DArray.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(offsetIndex, colorBuffer, mipLevel, x, y, width, height, length) {
        var _this = this, target = _this._target, gl = _this._gl;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
        width = width || Math.max(1, this._texture.width >> mipLevel) - x;
        height = height || Math.max(1, this._texture.height >> mipLevel) - y;
        length = length || this._texture.length;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
            gl.compressedTexSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, internalFormat, colorBuffer);
        } else {
            gl.texSubImage3D(target, mipLevel, x, y, offsetIndex, width, height, length, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTexture2DArray.setImageSource}
   */ _proto.setImageSource = function setImageSource(elementIndex, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage3D(this._target, mipLevel, x, y, elementIndex, imageSource.width, imageSource.height, 1, baseFormat, dataType, imageSource);
    };
    /**
   * {@inheritDoc IPlatformTexture2DArray.getPixelBuffer}
   */ _proto.getPixelBuffer = function getPixelBuffer(elementIndex, x, y, width, height, mipLevel, out) {
        var _this = this, gl = _this._gl, formatDetail = _this._formatDetail;
        if (formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._getReadFrameBuffer());
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this._glTexture, mipLevel, elementIndex);
        gl.readPixels(x, y, width, height, formatDetail.baseFormat, formatDetail.dataType, out);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };
    return GLTexture2DArray;
}(GLTexture);

/**
 * Cube texture in WebGL platform.
 */ var GLTextureCube = /*#__PURE__*/ function(GLTexture1) {
    _inherits$1(GLTextureCube, GLTexture1);
    function GLTextureCube(rhi, textureCube) {
        var _this;
        _this = GLTexture1.call(this, rhi, textureCube, rhi.gl.TEXTURE_CUBE_MAP) || this;
        /** Backward compatible with WebGL1.0. */ _this._compressedFaceFilled = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        /** @ts-ignore */ var format = textureCube.format, _mipmap = textureCube._mipmap, size = textureCube.width;
        var isWebGL2 = _this._isWebGL2;
        /** @ts-ignore */ if (!GLTexture._supportTextureFormat(format, rhi)) {
            throw new Error("Texture format is not supported:" + TextureFormat[format]);
        }
        if (_mipmap && !isWebGL2 && !GLTexture._isPowerOf2(size)) {
            Logger.warn("non-power-2 texture is not supported for mipmap in WebGL1,and has automatically downgraded to non-mipmap");
            /** @ts-ignore */ textureCube._mipmap = false;
            /** @ts-ignore */ textureCube._mipmapCount = textureCube._getMipmapCount();
        }
        _this._formatDetail = GLTexture._getFormatDetail(format, _this._gl, isWebGL2);
        _this._formatDetail.isCompressed && !isWebGL2 || _this._init(true);
        return _this;
    }
    var _proto = GLTextureCube.prototype;
    /**
   * {@inheritDoc IPlatformTextureCube.setPixelBuffer}
   */ _proto.setPixelBuffer = function setPixelBuffer(face, colorBuffer, mipLevel, x, y, width, height) {
        var gl = this._gl;
        var isWebGL2 = this._isWebGL2;
        var _this__formatDetail = this._formatDetail, internalFormat = _this__formatDetail.internalFormat, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType, isCompressed = _this__formatDetail.isCompressed;
        var mipSize = Math.max(1, this._texture.width >> mipLevel);
        width = width || mipSize - x;
        height = height || mipSize - y;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        if (isCompressed) {
            var mipBit = 1 << mipLevel;
            if (isWebGL2 || this._compressedFaceFilled[face] & mipBit) {
                gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, internalFormat, colorBuffer);
            } else {
                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, internalFormat, width, height, 0, colorBuffer);
                this._compressedFaceFilled[face] |= mipBit;
            }
        } else {
            gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x, y, width, height, baseFormat, dataType, colorBuffer);
        }
    };
    /**
   * {@inheritDoc IPlatformTextureCube.setImageSource}
   */ _proto.setImageSource = function setImageSource(face, imageSource, mipLevel, flipY, premultiplyAlpha, x, y) {
        var gl = this._gl;
        var _this__formatDetail = this._formatDetail, baseFormat = _this__formatDetail.baseFormat, dataType = _this__formatDetail.dataType;
        this._bind();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +premultiplyAlpha);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, x || 0, y || 0, baseFormat, dataType, imageSource);
    };
    /**
   * {@inheritDoc IPlatformTextureCube.getPixelBuffer}
   */ _proto.getPixelBuffer = function getPixelBuffer(face, x, y, width, height, mipLevel, out) {
        if (this._formatDetail.isCompressed) {
            throw new Error("Unable to read compressed texture");
        }
        GLTexture1.prototype._getPixelBuffer.call(this, face, x, y, width, height, mipLevel, out);
    };
    return GLTextureCube;
}(GLTexture);

var WebGLMode;
(function(WebGLMode) {
    WebGLMode[WebGLMode[/** Auto, use WebGL2.0 if support, or will fallback to WebGL1.0. */ "Auto"] = 0] = "Auto";
    WebGLMode[WebGLMode[/** WebGL2.0. */ "WebGL2"] = 1] = "WebGL2";
    WebGLMode[WebGLMode[/** WebGL1.0, */ "WebGL1"] = 2] = "WebGL1";
})(WebGLMode || (WebGLMode = {}));
/**
 * WebGL graphic device, including WebGL1.0 and WebGL2.0.
 */ var WebGLGraphicDevice = /*#__PURE__*/ function() {
    function WebGLGraphicDevice(initializeOptions) {
        if (initializeOptions === void 0) initializeOptions = {};
        /** @internal */ this._readFrameBuffer = null;
        /** @internal */ this._enableGlobalDepthBias = false;
        this._activeTextures = new Array(32);
        this._lastViewport = new Vector4(null, null, null, null);
        this._lastScissor = new Vector4(null, null, null, null);
        this._lastClearColor = new Color$1(null, null, null, null);
        this._scissorEnable = false;
        var options = _extends$1({
            webGLMode: 0,
            stencil: true,
            _forceFlush: false,
            _maxAllowSkinUniformVectorCount: 256
        }, initializeOptions);
        if (SystemInfo.platform === Platform.IPhone || SystemInfo.platform === Platform.IPad) {
            var version = SystemInfo.operatingSystem.match(/(\d+).?(\d+)?.?(\d+)?/);
            if (version) {
                var majorVersion = parseInt(version[1]);
                var minorVersion = parseInt(version[2]);
                if (majorVersion === 15 && minorVersion >= 0 && minorVersion <= 4) {
                    options._forceFlush = true;
                }
            }
        }
        this._options = options;
        this._onWebGLContextLost = this._onWebGLContextLost.bind(this);
        this._onWebGLContextRestored = this._onWebGLContextRestored.bind(this);
    }
    var _proto = WebGLGraphicDevice.prototype;
    _proto.init = function init(canvas, onDeviceLost, onDeviceRestored) {
        var options = this._options;
        var webCanvas = canvas._webCanvas;
        var webGLMode = options.webGLMode;
        this._onDeviceLost = onDeviceLost;
        this._onDeviceRestored = onDeviceRestored;
        webCanvas.addEventListener("webglcontextlost", this._onWebGLContextLost, false);
        webCanvas.addEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
        webCanvas.addEventListener("webglcontextcreationerror", this._onContextCreationError, false);
        this._webCanvas = webCanvas;
        var gl;
        if (webGLMode == 0 || webGLMode == 1) {
            gl = webCanvas.getContext("webgl2", options);
            if (!gl && (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, PlatformManager$1.polyfill.OffscreenCanvas))) {
                gl = webCanvas.getContext("experimental-webgl2", options);
            }
            this._isWebGL2 = true;
            // Prevent weird browsers to lie (such as safari!)
            if (gl && !gl.deleteQuery) {
                this._isWebGL2 = false;
            }
        }
        if (!gl) {
            if (webGLMode == 0 || webGLMode == 2) {
                gl = webCanvas.getContext("webgl", options);
                if (!gl && (typeof PlatformManager$1.polyfill.OffscreenCanvas === "undefined" || !_instanceof$1(webCanvas, PlatformManager$1.polyfill.OffscreenCanvas))) {
                    gl = webCanvas.getContext("experimental-webgl", options);
                }
                this._isWebGL2 = false;
            }
        }
        if (!gl) {
            throw new Error("Get GL Context FAILED.");
        }
        this._gl = gl;
        this._initGLState(gl);
    };
    _proto.createPlatformPrimitive = function createPlatformPrimitive(primitive) {
        return new GLPrimitive(this, primitive);
    };
    _proto.createPlatformTexture2D = function createPlatformTexture2D(texture2D) {
        return new GLTexture2D(this, texture2D);
    };
    _proto.createPlatformTexture2DArray = function createPlatformTexture2DArray(texture2D) {
        return new GLTexture2DArray(this, texture2D);
    };
    _proto.createPlatformTextureCube = function createPlatformTextureCube(textureCube) {
        return new GLTextureCube(this, textureCube);
    };
    _proto.createPlatformRenderTarget = function createPlatformRenderTarget(target) {
        return new GLRenderTarget(this, target);
    };
    _proto.createPlatformBuffer = function createPlatformBuffer(type, byteLength, bufferUsage, data) {
        if (bufferUsage === void 0) bufferUsage = BufferUsage.Static;
        return new GLBuffer(this, type, byteLength, bufferUsage, data);
    };
    _proto.requireExtension = function requireExtension(ext) {
        return this._extensions.requireExtension(ext);
    };
    _proto.canIUse = function canIUse(capabilityType) {
        return this.capability.canIUse(capabilityType);
    };
    _proto.canIUseCompressedTextureInternalFormat = function canIUseCompressedTextureInternalFormat(type) {
        return this.capability.canIUseCompressedTextureInternalFormat(type);
    };
    _proto.viewport = function viewport(x, y, width, height) {
        var _this = this, gl = _this._gl, lastViewport = _this._lastViewport;
        if (x !== lastViewport.x || y !== lastViewport.y || width !== lastViewport.z || height !== lastViewport.w) {
            gl.viewport(x, y, width, height);
            lastViewport.set(x, y, width, height);
        }
    };
    _proto.scissor = function scissor(x, y, width, height) {
        var _this = this, gl = _this._gl, lastScissor = _this._lastScissor;
        if (x !== lastScissor.x || y !== lastScissor.y || width !== lastScissor.z || height !== lastScissor.w) {
            var _this1 = this, webCanvas = _this1._webCanvas;
            if (x === 0 && y === 0 && width === webCanvas.width && height === webCanvas.height) {
                if (this._scissorEnable) {
                    gl.disable(gl.SCISSOR_TEST);
                    this._scissorEnable = false;
                }
            } else {
                if (!this._scissorEnable) {
                    gl.enable(gl.SCISSOR_TEST);
                    this._scissorEnable = true;
                }
                gl.scissor(x, y, width, height);
            }
            lastScissor.set(x, y, width, height);
        }
    };
    _proto.colorMask = function colorMask(r, g, b, a) {
        this._gl.colorMask(r, g, b, a);
    };
    _proto.clearRenderTarget = function clearRenderTarget(engine, clearFlags, clearColor) {
        var gl = this._gl;
        var _engine__lastRenderState = engine._lastRenderState, targetBlendState = _engine__lastRenderState.blendState.targetBlendState, depthState = _engine__lastRenderState.depthState, stencilState = _engine__lastRenderState.stencilState;
        var clearFlag = 0;
        if (clearFlags & CameraClearFlags.Color) {
            clearFlag |= gl.COLOR_BUFFER_BIT;
            var lc = this._lastClearColor;
            var r = clearColor.r, g = clearColor.g, b = clearColor.b, a = clearColor.a;
            if (clearColor && (r !== lc.r || g !== lc.g || b !== lc.b || a !== lc.a)) {
                gl.clearColor(r, g, b, a);
                lc.set(r, g, b, a);
            }
            if (targetBlendState.colorWriteMask !== ColorWriteMask.All) {
                gl.colorMask(true, true, true, true);
                targetBlendState.colorWriteMask = ColorWriteMask.All;
            }
        }
        if (clearFlags & CameraClearFlags.Depth) {
            clearFlag |= gl.DEPTH_BUFFER_BIT;
            if (depthState.writeEnabled !== true) {
                gl.depthMask(true);
                depthState.writeEnabled = true;
            }
        }
        if (clearFlags & CameraClearFlags.Stencil) {
            clearFlag |= gl.STENCIL_BUFFER_BIT;
            if (stencilState.writeMask !== 0xff) {
                gl.stencilMask(0xff);
                stencilState.writeMask = 0xff;
            }
        }
        gl.clear(clearFlag);
    };
    _proto.drawPrimitive = function drawPrimitive(primitive, subPrimitive, shaderProgram) {
        // todo: VAO not support morph animation
        if (primitive) {
            //@ts-ignore
            primitive._draw(shaderProgram, subPrimitive);
        } else {
            Logger.error("draw primitive failed.");
        }
    };
    _proto.activeRenderTarget = function activeRenderTarget(renderTarget, viewport, mipLevel) {
        var gl = this._gl;
        var bufferWidth, bufferHeight;
        if (renderTarget) {
            var /** @ts-ignore */ _renderTarget__platformRenderTarget;
            (_renderTarget__platformRenderTarget = renderTarget._platformRenderTarget) == null ? void 0 : _renderTarget__platformRenderTarget._activeRenderTarget();
            bufferWidth = renderTarget.width >> mipLevel;
            bufferHeight = renderTarget.height >> mipLevel;
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            bufferWidth = gl.drawingBufferWidth;
            bufferHeight = gl.drawingBufferHeight;
        }
        var width = bufferWidth * viewport.z;
        var height = bufferHeight * viewport.w;
        var x = viewport.x * bufferWidth;
        var y = bufferHeight - viewport.y * bufferHeight - height;
        this.viewport(x, y, width, height);
        this.scissor(x, y, width, height);
    };
    _proto.activeTexture = function activeTexture(textureID) {
        if (this._activeTextureID !== textureID) {
            this._gl.activeTexture(textureID);
            this._activeTextureID = textureID;
        }
    };
    _proto.bindTexture = function bindTexture(texture) {
        var index = this._activeTextureID - this._gl.TEXTURE0;
        if (this._activeTextures[index] !== texture) {
            this._gl.bindTexture(texture._target, texture._glTexture);
            this._activeTextures[index] = texture;
        }
    };
    _proto.setGlobalDepthBias = function setGlobalDepthBias(bias, slopeBias) {
        var gl = this._gl;
        var enable = bias !== 0 || slopeBias !== 0;
        if (enable) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(slopeBias, bias);
        } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
        }
        this._enableGlobalDepthBias = enable;
    };
    _proto.flush = function flush() {
        this._gl.flush();
    };
    _proto.forceLoseDevice = function forceLoseDevice() {
        var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
        extension.loseContext();
    };
    _proto.forceRestoreDevice = function forceRestoreDevice() {
        var extension = this.requireExtension(GLCapabilityType.WEBGL_lose_context);
        extension.restoreContext();
    };
    _proto.resetState = function resetState() {
        this._readFrameBuffer = null;
        this._enableGlobalDepthBias = false;
        this._currentBindShaderProgram = null;
        var activeTextures = this._activeTextures;
        for(var i = 0, n = activeTextures.length; i < n; i++){
            activeTextures[i] = null;
        }
        this._lastViewport.set(null, null, null, null);
        this._lastScissor.set(null, null, null, null);
        this._lastClearColor.set(null, null, null, null);
        this._scissorEnable = false;
        this._initGLState(this._gl);
    };
    _proto._initGLState = function _initGLState(gl) {
        this._activeTextureID = gl.TEXTURE0;
        this._renderStates = new GLRenderStates(gl);
        this._extensions = new GLExtensions(this);
        this._capability = new GLCapability(this);
        // Make sure the active texture in gl context is on default, because gl context may be used in other webgl renderer.
        gl.activeTexture(gl.TEXTURE0);
        var debugRenderInfo = gl.getExtension("WEBGL_debug_renderer_info");
        if (debugRenderInfo != null) {
            this._renderer = gl.getParameter(debugRenderInfo.UNMASKED_RENDERER_WEBGL);
        }
    };
    _proto.destroy = function destroy() {
        var webCanvas = this._webCanvas;
        webCanvas.removeEventListener("webglcontextcreationerror", this._onContextCreationError, false);
        webCanvas.removeEventListener("webglcontextlost", this._onWebGLContextLost, false);
        webCanvas.removeEventListener("webglcontextrestored", this._onWebGLContextRestored, false);
    };
    _proto._onContextCreationError = function _onContextCreationError(event) {
        console.error("WebGLRenderer: WebGL context could not be created. Reason: ", event.statusMessage);
    };
    _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
        event.preventDefault();
        this._onDeviceLost();
    };
    _proto._onWebGLContextRestored = function _onWebGLContextRestored(event) {
        this._onDeviceRestored();
    };
    _create_class$2(WebGLGraphicDevice, [
        {
            key: "isWebGL2",
            get: function get() {
                return this._isWebGL2;
            }
        },
        {
            key: "renderer",
            get: function get() {
                return this._renderer;
            }
        },
        {
            key: "gl",
            get: /**
   * GL Context
   * @member {WebGLRenderingContext}
   */ function get() {
                return this._gl;
            }
        },
        {
            key: "renderStates",
            get: function get() {
                return this._renderStates;
            }
        },
        {
            key: "capability",
            get: function get() {
                return this._capability;
            }
        },
        {
            key: "canIUseMoreJoints",
            get: function get() {
                return this.capability.canIUseMoreJoints;
            }
        }
    ]);
    return WebGLGraphicDevice;
}();

function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);

    return Constructor;
}

var DRACOWorker = /*#__PURE__*/ function() {
    function DRACOWorker(workerSourceURL, decoderWASMBinary) {
        var _this = this;
        // Record byteLength of each task.
        this._costs = {};
        // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.
        this._currentLoad = 0;
        this._callbacks = {};
        this._worker = new Worker(workerSourceURL);
        this._worker.onmessage = function(e) {
            var message = e.data;
            switch(message.type){
                case "decode":
                    _this._callbacks[message.id].resolve(message.geometry);
                    break;
                case "error":
                    _this._callbacks[message.id].reject(message);
                    break;
                default:
                    Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
            }
        };
        if (decoderWASMBinary) {
            this._worker.postMessage({
                type: "init",
                decoderConfig: {
                    wasmBinary: decoderWASMBinary
                }
            });
        } else {
            this._worker.postMessage({
                type: "init",
                decoderConfig: {}
            });
        }
    }
    var _proto = DRACOWorker.prototype;
    _proto.setCosts = function setCosts(taskId, cost) {
        this._costs[taskId] = cost;
    };
    _proto.addCurrentLoad = function addCurrentLoad(cost) {
        this._currentLoad += cost;
    };
    _proto.setCallback = function setCallback(taskId, resolve, reject) {
        this._callbacks[taskId] = {
            resolve: resolve,
            reject: reject
        };
    };
    _proto.decode = function decode(taskId, taskConfig, buffer) {
        this._worker.postMessage({
            type: "decode",
            id: taskId,
            taskConfig: taskConfig,
            buffer: buffer
        }, [
            buffer
        ]);
    };
    _proto.releaseTask = function releaseTask(taskId) {
        this._currentLoad -= this._costs[taskId];
        delete this._callbacks[taskId];
        delete this._costs[taskId];
    };
    _create_class$1(DRACOWorker, [
        {
            key: "currentLoad",
            get: function get() {
                return this._currentLoad;
            }
        }
    ]);
    return DRACOWorker;
}();

var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';

var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js";
var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = /*#__PURE__*/ function() {
    function DRACODecoder(config) {
        if (config === void 0) config = {
            type: "wasm",
            workerLimit: 4
        };
        this.pool = [];
        this.workerLimit = Math.min(PlatformManager$1.polyfill.navigator.hardwareConcurrency || 4, 4);
        this.currentTaskId = 1;
        this.taskCache = new WeakMap();
        if (config.workerLimit > this.workerLimit) {
            Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
        } else {
            var _config_workerLimit;
            this.workerLimit = (_config_workerLimit = config.workerLimit) != null ? _config_workerLimit : 4;
        }
        this.useJS = typeof WebAssembly !== "object" || config.type === "js";
        this.loadLibPromise = this.preloadLib();
    }
    var _proto = DRACODecoder.prototype;
    _proto.preloadLib = function preloadLib() {
        var _this = this;
        if (this.loadLibPromise) {
            return this.loadLibPromise;
        }
        return new Promise(function(resolve, reject) {
            if (_this.useJS) {
                request("" + LIB_PATH + JS_FILE, {
                    type: "text"
                }).then(function(jsSource) {
                    var body = [
                        jsSource,
                        workerString
                    ].join("\n");
                    var workerSourceURL = PlatformManager$1.polyfill.URL.createObjectURL(new PlatformManager$1.polyfill.Blob([
                        body
                    ]));
                    resolve({
                        workerSourceURL: workerSourceURL,
                        decoderWASMBinary: null
                    });
                }).catch(function(reason) {
                    reject(reason);
                });
            } else {
                Promise.all([
                    request("" + LIB_PATH + WASM_WRAPPER_FILE, {
                        type: "text"
                    }),
                    request("" + LIB_PATH + WASM_FILE, {
                        type: "arraybuffer"
                    })
                ]).then(function(resources) {
                    var wrapperSource = resources[0], decoderWASMBinary = resources[1];
                    var body = [
                        wrapperSource,
                        workerString
                    ].join("\n");
                    var workerSourceURL = PlatformManager$1.polyfill.URL.createObjectURL(new PlatformManager$1.polyfill.Blob([
                        body
                    ]));
                    resolve({
                        workerSourceURL: workerSourceURL,
                        decoderWASMBinary: decoderWASMBinary
                    });
                }).catch(function(reason) {
                    reject(reason);
                });
            }
        });
    };
    _proto.getWorker = function getWorker() {
        var _this = this;
        return this.preloadLib().then(function(worderResources) {
            if (_this.pool.length < _this.workerLimit) {
                var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
                _this.pool.push(dracoWorker);
            } else {
                _this.pool.sort(function(a, b) {
                    return a.currentLoad > b.currentLoad ? -1 : 1;
                });
            }
            return _this.pool[_this.pool.length - 1];
        });
    };
    _proto.decode = function decode(buffer, taskConfig) {
        var _this = this;
        var taskKey = JSON.stringify(taskConfig);
        // Check for an existing task using this buffer. A transferred buffer cannot be transferred.
        // again from this thread.
        if (this.taskCache.has(buffer)) {
            var cachedTask = this.taskCache.get(buffer);
            if (cachedTask.key === taskKey) {
                return cachedTask.promise;
            } else if (buffer.byteLength === 0) {
                // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.
                // Technically, it would be possible to wait for the previous task to complete,
                // transfer the buffer back, and decode again with the second configuration. That
                // is complex, and I don't know of any reason to decode a Draco buffer twice in
                // different ways, so this is left unimplemented.
                throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
            }
        }
        var taskId = this.currentTaskId++;
        var cost = buffer.byteLength;
        var taskWorker;
        var task = new Promise(function(resolve, reject) {
            _this.getWorker().then(function(worker) {
                taskWorker = worker;
                worker.setCosts(taskId, cost);
                worker.addCurrentLoad(cost);
                worker.setCallback(taskId, resolve, reject);
                worker.decode(taskId, taskConfig, buffer);
            }).catch(function(e) {
                reject(e);
            });
        });
        task.finally(function() {
            if (taskWorker && taskId) {
                taskWorker.releaseTask(taskId);
            }
        });
        this.taskCache.set(buffer, {
            key: taskKey,
            promise: task
        });
        return task;
    };
    return DRACODecoder;
}();

function _extends() {
    _extends = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var AnimatorControllerLoader = /*#__PURE__*/ function(Loader1) {
    _inherits(AnimatorControllerLoader, Loader1);
    function AnimatorControllerLoader() {
        return Loader1.apply(this, arguments);
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var animatorController = new AnimatorController();
                var layers = data.layers;
                var promises = [];
                layers.forEach(function(layerData, layerIndex) {
                    var name = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
                    var layer = new AnimatorControllerLayer(name);
                    layer.blendingMode = blendingMode;
                    layer.weight = weight;
                    if (stateMachineData) {
                        var states = stateMachineData.states;
                        var stateMachine = layer.stateMachine = new AnimatorStateMachine();
                        states.forEach(function(stateData, stateIndex) {
                            var name = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, isDefaultState = stateData.isDefaultState, clipData = stateData.clip, scripts = stateData.scripts;
                            var state = stateMachine.addState(name);
                            isDefaultState && (stateMachine.defaultState = state);
                            state.speed = speed;
                            state.wrapMode = wrapMode;
                            state.clipStartTime = clipStartNormalizedTime;
                            state.clipEndTime = clipEndNormalizedTime;
                            scripts == null ? void 0 : scripts.forEach(function(script) {
                                state.addStateMachineScript(Loader.getClass(script));
                            });
                            if (clipData) {
                                promises.push(new Promise(function(resolve) {
                                    //@ts-ignore
                                    resourceManager.getResourceByRef(clipData).then(function(clip) {
                                        resolve({
                                            layerIndex: layerIndex,
                                            stateIndex: stateIndex,
                                            clip: clip
                                        });
                                    });
                                }));
                            }
                        });
                        states.forEach(function(stateData) {
                            var name = stateData.name, transitions = stateData.transitions;
                            transitions.forEach(function(transitionData) {
                                var targetStateName = transitionData.targetStateName, duration = transitionData.duration, offset = transitionData.offset, exitTime = transitionData.exitTime;
                                var sourceState = stateMachine.findStateByName(name);
                                var destState = stateMachine.findStateByName(targetStateName);
                                var transition = new AnimatorStateTransition();
                                transition.destinationState = destState;
                                transition.duration = duration;
                                transition.exitTime = exitTime;
                                transition.offset = offset;
                                sourceState.addTransition(transition);
                            });
                        });
                    }
                    animatorController.addLayer(layer);
                });
                Promise.all(promises).then(function(clipData) {
                    clipData.forEach(function(data) {
                        var layerIndex = data.layerIndex, stateIndex = data.stateIndex, clip = data.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                    });
                    resolve(animatorController);
                });
            }).catch(reject);
        });
    };
    return AnimatorControllerLoader;
}(Loader);
AnimatorControllerLoader = __decorate([
    resourceLoader(exports.AssetType.AnimatorController, [
        "json"
    ], false)
], AnimatorControllerLoader);

function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
}
var BufferLoader = /*#__PURE__*/ function(Loader) {
    _inherits(BufferLoader, Loader);
    function BufferLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item) {
        var url = item.url;
        if (isBase64(url)) {
            return new AssetPromise(function(resolve) {
                var base64Str = url.slice(13 + RegExp.$1.length);
                var result = Uint8Array.from(PlatformManager$1.polyfill.atob(base64Str), function(c) {
                    return c.charCodeAt(0);
                });
                resolve(result.buffer);
            });
        }
        return this.request(url, _extends({}, item, {
            type: "arraybuffer"
        }));
    };
    return BufferLoader;
}(Loader);
BufferLoader = __decorate([
    resourceLoader(exports.AssetType.Buffer, [
        "bin",
        "r3bin"
    ], false)
], BufferLoader);

var EnvLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EnvLoader, Loader);
    function EnvLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(arraybuffer) {
                var _ref;
                var shArray = new Float32Array(arraybuffer, 0, 27);
                var shByteLength = 27 * 4;
                var size = (_ref = new Uint16Array(arraybuffer, shByteLength, 1)) == null ? void 0 : _ref[0];
                var texture = new TextureCube(resourceManager.engine, size);
                texture.filterMode = TextureFilterMode.Trilinear;
                var mipmapCount = texture.mipmapCount;
                var offset = shByteLength + 2;
                for(var mipLevel = 0; mipLevel < mipmapCount; mipLevel++){
                    var mipSize = size >> mipLevel;
                    for(var face = 0; face < 6; face++){
                        var dataSize = mipSize * mipSize * 4;
                        var data = new Uint8Array(arraybuffer, offset, dataSize);
                        offset += dataSize;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
                    }
                }
                var ambientLight = new AmbientLight();
                var sh = new SphericalHarmonics3();
                ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
                sh.copyFromArray(shArray);
                ambientLight.diffuseSphericalHarmonics = sh;
                ambientLight.specularTexture = texture;
                ambientLight.specularTextureDecodeRGBM = true;
                resolve(ambientLight);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return EnvLoader;
}(Loader);
EnvLoader = __decorate([
    resourceLoader(exports.AssetType.Env, [
        "env"
    ])
], EnvLoader);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;

        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
        });
    };
}

var FontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(FontLoader, Loader);
    function FontLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = FontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "json"
            }).then(function(data) {
                var fontName = data.fontName, fontUrl = data.fontUrl;
                if (fontUrl) {
                    _this._registerFont(fontName, fontUrl).then(function() {
                        var font = new Font(resourceManager.engine, fontName);
                        resolve(font);
                    }).catch(function(e) {
                        reject("load font " + fontUrl + " fail");
                    });
                } else {
                    var font = new Font(resourceManager.engine, fontName);
                    resolve(font);
                }
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        PlatformManager$1.polyfill.document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return FontLoader;
}(Loader);
FontLoader = __decorate([
    resourceLoader(exports.AssetType.Font, [
        "font"
    ], false)
], FontLoader);

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * @internal
 */ var GLTFContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(GLTFContentRestorer, ContentRestorer);
    function GLTFContentRestorer() {
        var _this;
        _this = ContentRestorer.apply(this, arguments) || this;
        _this.bufferRequests = [];
        _this.glbBufferSlices = [];
        _this.bufferTextures = [];
        _this.meshes = [];
        return _this;
    }
    var _proto = GLTFContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.bufferRequests.map(function(bufferRequestInfo) {
                return request(bufferRequestInfo.url, bufferRequestInfo.config);
            })).then(function(buffers) {
                // Buffer parse
                if (_this.isGLB) {
                    var glbBufferSlice = _this.glbBufferSlices;
                    var bigBuffer = buffers[0];
                    var bufferCount = glbBufferSlice.length;
                    buffers.length = bufferCount;
                    for(var i = 0; i < bufferCount; i++){
                        var slice = glbBufferSlice[i];
                        buffers[i] = bigBuffer.slice(slice.x, slice.x + slice.y);
                    }
                }
                // Restore texture
                AssetPromise.all(_this.bufferTextures.map(function(textureRestoreInfo) {
                    var bufferView = textureRestoreInfo.bufferView;
                    var buffer = buffers[bufferView.buffer];
                    var _bufferView_byteOffset;
                    var bufferData = new Uint8Array(buffer, (_bufferView_byteOffset = bufferView.byteOffset) != null ? _bufferView_byteOffset : 0, bufferView.byteLength);
                    return GLTFUtils.loadImageBuffer(bufferData, textureRestoreInfo.mimeType).then(function(image) {
                        textureRestoreInfo.texture.setImageSource(image);
                        textureRestoreInfo.texture.generateMipmaps();
                    });
                })).then(function() {
                    // Restore mesh
                    for(var _iterator = _create_for_of_iterator_helper_loose(_this.meshes), _step; !(_step = _iterator()).done;){
                        var meshInfo = _step.value;
                        var mesh = meshInfo.mesh;
                        for(var _iterator1 = _create_for_of_iterator_helper_loose(meshInfo.vertexBuffers), _step1; !(_step1 = _iterator1()).done;){
                            var bufferRestoreInfo = _step1.value;
                            var vertexData = _this._getBufferData(buffers, bufferRestoreInfo.data);
                            bufferRestoreInfo.buffer.setData(vertexData);
                        }
                        if (meshInfo.indexBuffer) {
                            var indexData = _this._getBufferData(buffers, meshInfo.indexBuffer);
                            mesh.setIndices(indexData);
                        }
                        for(var _iterator2 = _create_for_of_iterator_helper_loose(meshInfo.blendShapes), _step2; !(_step2 = _iterator2()).done;){
                            var restoreInfo = _step2.value;
                            var frame = restoreInfo.blendShape.frames[0];
                            var positionData = _this._getBufferData(buffers, restoreInfo.position);
                            frame.deltaPositions = GLTFUtils.floatBufferToVector3Array(positionData);
                            if (restoreInfo.normal) {
                                var normalData = _this._getBufferData(buffers, restoreInfo.normal);
                                frame.deltaNormals = GLTFUtils.floatBufferToVector3Array(normalData);
                            }
                            if (restoreInfo.tangent) {
                                var tangentData = _this._getBufferData(buffers, restoreInfo.tangent);
                                frame.deltaTangents = GLTFUtils.floatBufferToVector3Array(tangentData);
                            }
                        }
                        mesh.uploadData(true);
                    }
                    resolve(_this.resource);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._getBufferData = function _getBufferData(buffers, restoreInfo) {
        var main = restoreInfo.main;
        var buffer = buffers[main.bufferIndex];
        var data = new main.TypedArray(buffer, main.byteOffset, main.length);
        var sparseCount = restoreInfo.sparseCount;
        if (sparseCount) {
            var sparseIndex = restoreInfo.sparseIndices;
            var sparseIndexBuffer = buffers[sparseIndex.bufferIndex];
            var sparseIndexData = new sparseIndex.TypedArray(sparseIndexBuffer, sparseIndex.byteOffset, sparseIndex.length);
            var sparseValue = restoreInfo.sparseValues;
            var sparseValueBuffer = buffers[sparseValue.bufferIndex];
            var sparseValueData = new sparseValue.TypedArray(sparseValueBuffer, sparseValue.byteOffset, sparseValue.length);
            var typeSize = restoreInfo.typeSize;
            for(var i = 0; i < sparseCount; i++){
                var replaceIndex = sparseIndexData[i];
                for(var j = 0; j < typeSize; j++){
                    data[replaceIndex * typeSize + j] = sparseValueData[i * typeSize + j];
                }
            }
        }
        return data;
    };
    return GLTFContentRestorer;
}(ContentRestorer);
/**
 * @internal
 */ var BufferRequestInfo = function BufferRequestInfo(url, config) {
    this.url = url;
    this.config = config;
};
/**
 * @internal
 */ var BufferTextureRestoreInfo = function BufferTextureRestoreInfo(texture, bufferView, mimeType) {
    this.texture = texture;
    this.bufferView = bufferView;
    this.mimeType = mimeType;
};
/**
 * @internal
 */ var ModelMeshRestoreInfo = function ModelMeshRestoreInfo() {
    this.vertexBuffers = [];
    this.blendShapes = [];
};
/**
 * @internal
 */ var BufferRestoreInfo = function BufferRestoreInfo(buffer, data) {
    this.buffer = buffer;
    this.data = data;
};
/**
 * @internal
 */ var BufferDataRestoreInfo = function BufferDataRestoreInfo(main, typeSize, sparseCount, sparseIndices, sparseValues) {
    this.main = main;
    this.typeSize = typeSize;
    this.sparseCount = sparseCount;
    this.sparseIndices = sparseIndices;
    this.sparseValues = sparseValues;
};
/**
 * @internal
 */ var RestoreDataAccessor = function RestoreDataAccessor(bufferIndex, TypedArray, byteOffset, length) {
    this.bufferIndex = bufferIndex;
    this.TypedArray = TypedArray;
    this.byteOffset = byteOffset;
    this.length = length;
};
/**
 * @internal
 */ var BlendShapeRestoreInfo = function BlendShapeRestoreInfo(blendShape, position, normal, tangent) {
    this.blendShape = blendShape;
    this.position = position;
    this.normal = normal;
    this.tangent = tangent;
};

/**
 * Module for glTF 2.0 Interface
 */ var AccessorComponentType;
(function(AccessorComponentType) {
    AccessorComponentType[AccessorComponentType[/**
   * Byte
   */ "BYTE"] = 5120] = "BYTE";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Byte
   */ "UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    AccessorComponentType[AccessorComponentType[/**
   * Short
   */ "SHORT"] = 5122] = "SHORT";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Short
   */ "UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Int
   */ "UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    AccessorComponentType[AccessorComponentType[/**
   * Float
   */ "FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));
var AccessorType;
(function(AccessorType) {
    AccessorType[/**
   * Scalar
   */ "SCALAR"] = "SCALAR";
    AccessorType[/**
   * Vector2
   */ "VEC2"] = "VEC2";
    AccessorType[/**
   * Vector3
   */ "VEC3"] = "VEC3";
    AccessorType[/**
   * Vector4
   */ "VEC4"] = "VEC4";
    AccessorType[/**
   * Matrix2x2
   */ "MAT2"] = "MAT2";
    AccessorType[/**
   * Matrix3x3
   */ "MAT3"] = "MAT3";
    AccessorType[/**
   * Matrix4x4
   */ "MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));
var AnimationChannelTargetPath;
(function(AnimationChannelTargetPath) {
    AnimationChannelTargetPath[/**
   * Translation
   */ "TRANSLATION"] = "translation";
    AnimationChannelTargetPath[/**
   * Rotation
   */ "ROTATION"] = "rotation";
    AnimationChannelTargetPath[/**
   * Scale
   */ "SCALE"] = "scale";
    AnimationChannelTargetPath[/**
   * Weights
   */ "WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
var AnimationSamplerInterpolation;
(function(AnimationSamplerInterpolation) {
    AnimationSamplerInterpolation[/**
   * The animated values are linearly interpolated between keyframes
   */ "Linear"] = "LINEAR";
    AnimationSamplerInterpolation[/**
   * The animated values remain constant to the output of the first keyframe, until the next keyframe
   */ "Step"] = "STEP";
    AnimationSamplerInterpolation[/**
   * The animation's interpolation is computed using a cubic spline with specified tangents
   */ "CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
var CameraType;
(function(CameraType) {
    CameraType[/**
   * A perspective camera containing properties to create a perspective projection matrix
   */ "PERSPECTIVE"] = "perspective";
    CameraType[/**
   * An orthographic camera containing properties to create an orthographic projection matrix
   */ "ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));
var ImageMimeType;
(function(ImageMimeType) {
    ImageMimeType[/**
   * JPEG Mime-type
   */ "JPEG"] = "image/jpeg";
    ImageMimeType[/**
   * PNG Mime-type
   */ "PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));
var MaterialAlphaMode;
(function(MaterialAlphaMode) {
    MaterialAlphaMode[/**
   * The alpha value is ignored and the rendered output is fully opaque
   */ "OPAQUE"] = "OPAQUE";
    MaterialAlphaMode[/**
   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value
   */ "MASK"] = "MASK";
    MaterialAlphaMode[/**
   * The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
   */ "BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));
var TextureMagFilter;
(function(TextureMagFilter) {
    TextureMagFilter[TextureMagFilter[/**
   * Nearest
   */ "NEAREST"] = 9728] = "NEAREST";
    TextureMagFilter[TextureMagFilter[/**
   * Linear
   */ "LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));
var TextureMinFilter;
(function(TextureMinFilter) {
    TextureMinFilter[TextureMinFilter[/**
   * Nearest
   */ "NEAREST"] = 9728] = "NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Linear
   */ "LINEAR"] = 9729] = "LINEAR";
    TextureMinFilter[TextureMinFilter[/**
   * Nearest Mip-Map Nearest
   */ "NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Linear Mipmap Nearest
   */ "LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Nearest Mipmap Linear
   */ "NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureMinFilter[TextureMinFilter[/**
   * Linear Mipmap Linear
   */ "LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));
var TextureWrapMode;
(function(TextureWrapMode) {
    TextureWrapMode[TextureWrapMode[/**
   * Clamp to Edge
   */ "CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    TextureWrapMode[TextureWrapMode[/**
   * Mirrored Repeat
   */ "MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    TextureWrapMode[TextureWrapMode[/**
   * Repeat
   */ "REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * @internal
 */ var GLTFParserContext = /*#__PURE__*/ function() {
    function GLTFParserContext(url) {
        this.hasSkinned = false;
        this.chainPromises = [];
        this.accessorBufferCache = {};
        this.texturesPromiseInfo = new PromiseInfo();
        this.materialsPromiseInfo = new PromiseInfo();
        this.meshesPromiseInfo = new PromiseInfo();
        this.animationClipsPromiseInfo = new PromiseInfo();
        this.defaultSceneRootPromiseInfo = new PromiseInfo();
        this.masterPromiseInfo = new PromiseInfo();
        this.promiseMap = {};
        var promiseMap = this.promiseMap;
        promiseMap["" + url + "?q=textures"] = this._initPromiseInfo(this.texturesPromiseInfo);
        promiseMap["" + url + "?q=materials"] = this._initPromiseInfo(this.materialsPromiseInfo);
        promiseMap["" + url + "?q=meshes"] = this._initPromiseInfo(this.meshesPromiseInfo);
        promiseMap["" + url + "?q=animations"] = this._initPromiseInfo(this.animationClipsPromiseInfo);
        promiseMap["" + url + "?q=defaultSceneRoot"] = this._initPromiseInfo(this.defaultSceneRootPromiseInfo);
        promiseMap["" + url] = this._initPromiseInfo(this.masterPromiseInfo);
    }
    var _proto = GLTFParserContext.prototype;
    _proto._initPromiseInfo = function _initPromiseInfo(promiseInfo) {
        var promise = new AssetPromise(function(resolve, reject, setProgress, onCancel) {
            promiseInfo.resolve = resolve;
            promiseInfo.reject = reject;
            promiseInfo.setProgress = setProgress;
            promiseInfo.onCancel = onCancel;
        });
        promiseInfo.promise = promise;
        return promise;
    };
    return GLTFParserContext;
}();
/**
 * @internal
 */ var BufferInfo = function BufferInfo(data, interleaved, stride) {
    this.data = data;
    this.interleaved = interleaved;
    this.stride = stride;
    this.vertexBindingInfos = {};
};
/**
 * @internal
 */ var PromiseInfo = function PromiseInfo() {
};

/**
 * @internal
 */ var GLTFUtils = /*#__PURE__*/ function() {
    function GLTFUtils() {}
    GLTFUtils.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 2);
        for(var i = 0; i < bufferLen; i += 2){
            array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 3);
        for(var i = 0; i < bufferLen; i += 3){
            array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
        }
        return array;
    };
    GLTFUtils.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 4);
        for(var i = 0; i < bufferLen; i += 4){
            array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
        }
        return array;
    };
    GLTFUtils.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
        var bufferLen = buffer.length;
        var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
        if (isColor3) {
            for(var i = 0; i < bufferLen; i += 3){
                colors[i / 3] = new Color$1(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
            }
        } else {
            for(var i1 = 0; i1 < bufferLen; i1 += 4){
                colors[i1 / 4] = new Color$1(buffer[i1], buffer[i1 + 1], buffer[i1 + 2], buffer[i1 + 3]);
            }
        }
        return colors;
    };
    /**
   * Get the number of bytes occupied by accessor type.
   */ GLTFUtils.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
        switch(accessorType){
            case AccessorType.SCALAR:
                return 1;
            case AccessorType.VEC2:
                return 2;
            case AccessorType.VEC3:
                return 3;
            case AccessorType.VEC4:
                return 4;
            case AccessorType.MAT2:
                return 4;
            case AccessorType.MAT3:
                return 9;
            case AccessorType.MAT4:
                return 16;
        }
    };
    /**
   * Get the TypedArray corresponding to the component type.
   */ GLTFUtils.getComponentType = function getComponentType(componentType) {
        switch(componentType){
            case AccessorComponentType.BYTE:
                return Int8Array;
            case AccessorComponentType.UNSIGNED_BYTE:
                return Uint8Array;
            case AccessorComponentType.SHORT:
                return Int16Array;
            case AccessorComponentType.UNSIGNED_SHORT:
                return Uint16Array;
            case AccessorComponentType.UNSIGNED_INT:
                return Uint32Array;
            case AccessorComponentType.FLOAT:
                return Float32Array;
        }
    };
    GLTFUtils.getNormalizedComponentScale = function getNormalizedComponentScale(componentType) {
        // Reference: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
        switch(componentType){
            case AccessorComponentType.BYTE:
                return 1 / 127;
            case AccessorComponentType.UNSIGNED_BYTE:
                return 1 / 255;
            case AccessorComponentType.SHORT:
                return 1 / 32767;
            case AccessorComponentType.UNSIGNED_SHORT:
                return 1 / 65535;
            default:
                throw new Error("Galacean.GLTFLoader: Unsupported normalized accessor component type.");
        }
    };
    GLTFUtils.getAccessorBuffer = function getAccessorBuffer(context, bufferViews, accessor) {
        var buffers = context.buffers;
        var componentType = accessor.componentType;
        var bufferView = bufferViews[accessor.bufferView];
        var bufferIndex = bufferView.buffer;
        var buffer = buffers[bufferIndex];
        var bufferByteOffset = bufferView.byteOffset || 0;
        var byteOffset = accessor.byteOffset || 0;
        var TypedArray = GLTFUtils.getComponentType(componentType);
        var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var dataElementBytes = TypedArray.BYTES_PER_ELEMENT;
        var elementStride = dataElementSize * dataElementBytes;
        var accessorCount = accessor.count;
        var bufferStride = bufferView.byteStride;
        var bufferInfo;
        // According to the glTF official documentation only byteStride not undefined is allowed
        if (bufferStride !== undefined && bufferStride !== elementStride) {
            var bufferSlice = Math.floor(byteOffset / bufferStride);
            var bufferCacheKey = accessor.bufferView + ":" + componentType + ":" + bufferSlice + ":" + accessorCount;
            var accessorBufferCache = context.accessorBufferCache;
            bufferInfo = accessorBufferCache[bufferCacheKey];
            if (!bufferInfo) {
                var offset = bufferByteOffset + bufferSlice * bufferStride;
                var count = accessorCount * (bufferStride / dataElementBytes);
                var data = new TypedArray(buffer, offset, count);
                accessorBufferCache[bufferCacheKey] = bufferInfo = new BufferInfo(data, true, bufferStride);
                bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset, count));
            }
        } else {
            var offset1 = bufferByteOffset + byteOffset;
            var count1 = accessorCount * dataElementSize;
            var data1 = new TypedArray(buffer, offset1, count1);
            bufferInfo = new BufferInfo(data1, false, elementStride);
            bufferInfo.restoreInfo = new BufferDataRestoreInfo(new RestoreDataAccessor(bufferIndex, TypedArray, offset1, count1));
        }
        if (accessor.sparse) {
            GLTFUtils.processingSparseData(bufferViews, accessor, buffers, bufferInfo);
        }
        return bufferInfo;
    };
    /**
   * @deprecated
   * Get accessor data.
   */ GLTFUtils.getAccessorData = function getAccessorData(glTF, accessor, buffers) {
        var bufferViews = glTF.bufferViews;
        var bufferView = bufferViews[accessor.bufferView];
        var arrayBuffer = buffers[bufferView.buffer];
        var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
        var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
        var byteOffset = accessorByteOffset + bufferViewByteOffset;
        var accessorTypeSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var length = accessorTypeSize * accessor.count;
        var _bufferView_byteStride;
        var byteStride = (_bufferView_byteStride = bufferView.byteStride) != null ? _bufferView_byteStride : 0;
        var arrayType = GLTFUtils.getComponentType(accessor.componentType);
        var uint8Array;
        if (byteStride) {
            var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
            uint8Array = new Uint8Array(accessor.count * accessorByteSize);
            var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
            for(var i = 0; i < accessor.count; i++){
                for(var j = 0; j < accessorByteSize; j++){
                    uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
                }
            }
        } else {
            uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
        }
        var typedArray = new arrayType(uint8Array.buffer);
        if (accessor.sparse) {
            var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
            var indicesBufferView = bufferViews[indices.bufferView];
            var valuesBufferView = bufferViews[values.bufferView];
            var indicesArrayBuffer = buffers[indicesBufferView.buffer];
            var valuesArrayBuffer = buffers[valuesBufferView.buffer];
            var _indices_byteOffset, _indicesBufferView_byteOffset;
            var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
            var indicesByteLength = indicesBufferView.byteLength;
            var _values_byteOffset, _valuesBufferView_byteOffset;
            var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
            var valuesByteLength = valuesBufferView.byteLength;
            var indicesType = GLTFUtils.getComponentType(indices.componentType);
            var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
            var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
            for(var i1 = 0; i1 < count; i1++){
                var replaceIndex = indicesArray[i1];
                for(var j1 = 0; j1 < accessorTypeSize; j1++){
                    typedArray[replaceIndex * accessorTypeSize + j1] = valuesArray[i1 * accessorTypeSize + j1];
                }
            }
        }
        return typedArray;
    };
    GLTFUtils.getBufferViewData = function getBufferViewData(bufferView, buffers) {
        var _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset;
        var arrayBuffer = buffers[bufferView.buffer];
        return arrayBuffer.slice(byteOffset, byteOffset + bufferView.byteLength);
    };
    /**
   * Get accessor data.
   */ GLTFUtils.processingSparseData = function processingSparseData(bufferViews, accessor, buffers, bufferInfo) {
        var restoreInfo = bufferInfo.restoreInfo;
        var accessorTypeSize = GLTFUtils.getAccessorTypeSize(accessor.type);
        var TypedArray = GLTFUtils.getComponentType(accessor.componentType);
        var data = bufferInfo.data.slice();
        var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        var indicesBufferIndex = indicesBufferView.buffer;
        var valuesBufferIndex = valuesBufferView.buffer;
        var indicesArrayBuffer = buffers[indicesBufferIndex];
        var valuesArrayBuffer = buffers[valuesBufferIndex];
        var _indices_byteOffset, _indicesBufferView_byteOffset;
        var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
        var indicesByteLength = indicesBufferView.byteLength;
        var _values_byteOffset, _valuesBufferView_byteOffset;
        var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
        var valuesByteLength = valuesBufferView.byteLength;
        restoreInfo.typeSize = accessorTypeSize;
        restoreInfo.sparseCount = count;
        var IndexTypeArray = GLTFUtils.getComponentType(indices.componentType);
        var indexLength = indicesByteLength / IndexTypeArray.BYTES_PER_ELEMENT;
        var indicesArray = new IndexTypeArray(indicesArrayBuffer, indicesByteOffset, indexLength);
        restoreInfo.sparseIndices = new RestoreDataAccessor(indicesBufferIndex, IndexTypeArray, indicesByteOffset, indexLength);
        var valueLength = valuesByteLength / TypedArray.BYTES_PER_ELEMENT;
        var valuesArray = new TypedArray(valuesArrayBuffer, valuesByteOffset, valueLength);
        restoreInfo.sparseValues = new RestoreDataAccessor(valuesBufferIndex, TypedArray, valuesByteOffset, valueLength);
        for(var i = 0; i < count; i++){
            var replaceIndex = indicesArray[i];
            for(var j = 0; j < accessorTypeSize; j++){
                data[replaceIndex * accessorTypeSize + j] = valuesArray[i * accessorTypeSize + j];
            }
        }
        bufferInfo.data = data;
    };
    GLTFUtils.getIndexFormat = function getIndexFormat(type) {
        switch(type){
            case AccessorComponentType.UNSIGNED_BYTE:
                return IndexFormat.UInt8;
            case AccessorComponentType.UNSIGNED_SHORT:
                return IndexFormat.UInt16;
            case AccessorComponentType.UNSIGNED_INT:
                return IndexFormat.UInt32;
        }
    };
    GLTFUtils.getElementFormat = function getElementFormat(type, size, normalized) {
        if (normalized === void 0) normalized = false;
        if (type == AccessorComponentType.FLOAT) {
            switch(size){
                case 1:
                    return VertexElementFormat.Float;
                case 2:
                    return VertexElementFormat.Vector2;
                case 3:
                    return VertexElementFormat.Vector3;
                case 4:
                    return VertexElementFormat.Vector4;
            }
        }
        if (type == AccessorComponentType.SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
            }
        }
        if (type == AccessorComponentType.BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
            }
        }
    };
    /**
   * Load image buffer
   */ GLTFUtils.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
        return new Promise(function(resolve, reject) {
            var blob = new PlatformManager$1.polyfill.window.Blob([
                imageBuffer
            ], {
                type: type
            });
            var img = new PlatformManager$1.polyfill.Image();
            img.onerror = function() {
                reject(new Error("Failed to load image buffer"));
            };
            img.onload = function() {
                // Call requestAnimationFrame to avoid iOS's bug.
                PlatformManager$1.polyfill.requestAnimationFrame(function() {
                    resolve(img);
                    img.onload = null;
                    img.onerror = null;
                    img.onabort = null;
                });
            };
            img.crossOrigin = "anonymous";
            img.src = PlatformManager$1.polyfill.URL.createObjectURL(blob);
        });
    };
    /**
   * Parse the glb format.
   */ GLTFUtils.parseGLB = function parseGLB(context, glb) {
        var UINT32_LENGTH = 4;
        var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
        var GLB_HEADER_LENGTH = 12;
        var GLB_CHUNK_TYPES = {
            JSON: 0x4e4f534a,
            BIN: 0x004e4942
        };
        var dataView = new DataView(glb);
        // read header
        var header = {
            magic: dataView.getUint32(0, true),
            version: dataView.getUint32(UINT32_LENGTH, true),
            length: dataView.getUint32(2 * UINT32_LENGTH, true)
        };
        if (header.magic !== GLB_HEADER_MAGIC) {
            console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
            return null;
        }
        // read main data
        var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
        var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
        // read glTF json
        if (chunkType !== GLB_CHUNK_TYPES.JSON) {
            console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
            return null;
        }
        var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
        var glTF = JSON.parse(Utils.decodeText(glTFData));
        // read all buffers
        var buffers = [];
        var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
        var restoreGLBBufferSlice = context.contentRestorer.glbBufferSlices;
        while(byteOffset < header.length){
            chunkLength = dataView.getUint32(byteOffset, true);
            chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
            if (chunkType !== GLB_CHUNK_TYPES.BIN) {
                console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
                return null;
            }
            var currentOffset = byteOffset + 2 * UINT32_LENGTH;
            var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
            buffers.push(buffer);
            restoreGLBBufferSlice.push(new Vector2(currentOffset, chunkLength));
            byteOffset += chunkLength + 2 * UINT32_LENGTH;
        }
        return {
            glTF: glTF,
            buffers: buffers
        };
    };
    GLTFUtils._formatRelativePath = function _formatRelativePath(path) {
        // For example input is "a/b", "/a/b", "./a/b", "./a/./b", "./a/../a/b", output is "a/b"
        return path.split("/").filter(Boolean).reduce(function(acc, cur) {
            if (cur === "..") acc.pop();
            else if (cur !== ".") acc.push(cur);
            return acc;
        }, []).join("/");
    };
    return GLTFUtils;
}();

function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}

function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
        return Array.from(iter);
    }
}

function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}

/**
 * Base class of glTF extension parser.
 */ var GLTFExtensionParser = /*#__PURE__*/ function() {
    function GLTFExtensionParser() {}
    var _proto = GLTFExtensionParser.prototype;
    /**
   * Initialize the parser.
   * @remarks Some plugins require initialization.
   * @returns The void or promise
   */ _proto.initialize = function initialize() {};
    /**
   * Create and parse the resource.
   * @remarks This method overrides the default resource creation.
   * @param context - The parser context
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The resource or promise
   */ _proto.createAndParse = function createAndParse(context, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        throw "Not implemented.";
    };
    /**
   * Additive parse to the resource.
   * @param context - The parser context
   * @param parseResource - The parsed resource
   * @param extensionSchema - The extension schema
   * @param extensionOwnerSchema - The extension owner schema
   * @returns The void or promise
   */ _proto.additiveParse = function additiveParse(context, parseResource, extensionSchema, extensionOwnerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        throw "Not implemented.";
    };
    return GLTFExtensionParser;
}();
var GLTFExtensionMode;
(function(GLTFExtensionMode) {
    GLTFExtensionMode[GLTFExtensionMode[/**
   * Cerate instance and parse mode.
   * @remarks
   * If the glTF property has multiple extensions of `CreateAndParse` mode, only execute the last one.
   * If this method is registered, the default pipeline processing will be ignored.
   */ "CreateAndParse"] = 0] = "CreateAndParse";
    GLTFExtensionMode[GLTFExtensionMode[/** Additive parse mode. */ "AdditiveParse"] = 1] = "AdditiveParse";
})(GLTFExtensionMode || (GLTFExtensionMode = {}));

/**
 * Base class of glTF parser.
 */ var GLTFParser = /*#__PURE__*/ function() {
    function GLTFParser() {}
    /**
   * Execute all parses of extension to initialize plugin.
   * @remarks Some plugins require initialization.
   * @returns The void or promise
   */ GLTFParser.executeExtensionsInitialize = function executeExtensionsInitialize(extensionName) {
        var parsers = GLTFParser._extensionParsers[extensionName];
        var length = parsers == null ? void 0 : parsers.length;
        if (length) {
            return parsers[length - 1].initialize();
        }
    };
    /**
   * Execute all parses of extension to create resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   * @returns
   */ GLTFParser.executeExtensionsCreateAndParse = function executeExtensionsCreateAndParse(extensions, context, ownerSchema) {
        if (extensions === void 0) extensions = {};
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        var resource = null;
        var extensionArray = Object.keys(extensions);
        for(var i = extensionArray.length - 1; i >= 0; --i){
            var _GLTFParser;
            var extensionName = extensionArray[i];
            var extensionSchema = extensions[extensionName];
            resource = (_GLTFParser = GLTFParser)._createAndParse.apply(_GLTFParser, [
                extensionName,
                context,
                extensionSchema,
                ownerSchema
            ].concat(_to_consumable_array(extra)));
            if (resource) {
                return resource;
            }
        }
    };
    /**
   * Execute all parses of extension to parse resource.
   * @param extensions - Related extensions field
   * @param context - The parser context
   * @param parseResource -  The parsed resource
   * @param ownerSchema - The extension owner schema
   * @param extra - Extra params
   */ GLTFParser.executeExtensionsAdditiveAndParse = function executeExtensionsAdditiveAndParse(extensions, context, parseResource, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        for(var extensionName in extensions){
            var _GLTFParser;
            var extensionSchema = extensions[extensionName];
            (_GLTFParser = GLTFParser)._additiveParse.apply(_GLTFParser, [
                extensionName,
                context,
                parseResource,
                extensionSchema,
                ownerSchema
            ].concat(_to_consumable_array(extra)));
        }
    };
    /**
   * Whether the plugin is registered.
   * @param extensionName - Extension name
   * @returns Boolean
   */ GLTFParser.hasExtensionParser = function hasExtensionParser(extensionName) {
        var _GLTFParser__extensionParsers_extensionName;
        return !!((_GLTFParser__extensionParsers_extensionName = GLTFParser._extensionParsers[extensionName]) == null ? void 0 : _GLTFParser__extensionParsers_extensionName.length);
    };
    /**
   * Get the last plugin by glTF extension mode.
   * @param extensionName - Extension name
   * @param mode - GLTF extension mode
   * @returns GLTF extension parser
   */ GLTFParser.getExtensionParser = function getExtensionParser(extensionName, mode) {
        var parsers = GLTFParser._extensionParsers[extensionName];
        var length = parsers == null ? void 0 : parsers.length;
        if (length) {
            // only use the last parser.
            for(var i = length - 1; i >= 0; --i){
                var currentParser = parsers[i];
                if (currentParser._mode === mode) {
                    return currentParser;
                }
            }
        }
    };
    /**
   * @internal
   */ GLTFParser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
        if (!GLTFParser._extensionParsers[extensionName]) {
            GLTFParser._extensionParsers[extensionName] = [];
        }
        GLTFParser._extensionParsers[extensionName].push(extensionParser);
    };
    GLTFParser._createAndParse = function _createAndParse(extensionName, context, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.CreateAndParse);
        if (parser) {
            var _parser;
            return (_parser = parser).createAndParse.apply(_parser, [
                context,
                extensionSchema,
                ownerSchema
            ].concat(_to_consumable_array(extra)));
        }
    };
    GLTFParser._additiveParse = function _additiveParse(extensionName, context, parseResource, extensionSchema, ownerSchema) {
        for(var _len = arguments.length, extra = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){
            extra[_key - 5] = arguments[_key];
        }
        var parser = GLTFParser.getExtensionParser(extensionName, GLTFExtensionMode.AdditiveParse);
        if (parser) {
            var _parser;
            (_parser = parser).additiveParse.apply(_parser, [
                context,
                parseResource,
                extensionSchema,
                ownerSchema
            ].concat(_to_consumable_array(extra)));
        }
    };
    return GLTFParser;
}();
(function() {
    GLTFParser._extensionParsers = {};
})();
/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */ function registerGLTFExtension(extensionName, mode) {
    return function(parser) {
        var extensionParser = new parser();
        extensionParser._mode = mode;
        GLTFParser._addExtensionParser(extensionName, extensionParser);
    };
}

var GLTFAnimationParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFAnimationParser, GLTFParser1);
    function GLTFAnimationParser() {
        return GLTFParser1.apply(this, arguments);
    }
    var _proto = GLTFAnimationParser.prototype;
    _proto.parse = function parse(context) {
        var glTF = context.glTF; context.buffers; var glTFResource = context.glTFResource;
        glTFResource.entities;
        var animations = glTF.animations; glTF.accessors; glTF.bufferViews;
        if (!animations) {
            return;
        }
        var animationClipsPromiseInfo = context.animationClipsPromiseInfo;
        var animationClipCount = animations.length;
        var animationClipPromises = [];
        new Array(animationClipCount);
        for(var i = 0; i < animationClipCount; i++){
            var animationInfo = animations[i];
            var _animationInfo_name = animationInfo.name, name = _animationInfo_name === void 0 ? "AnimationClip" + i : _animationInfo_name;
            var animationClip = GLTFParser.executeExtensionsCreateAndParse(animationInfo.extensions, context, animationInfo);
            if (!animationClip) {
                animationClip = new AnimationClip(name);
                GLTFAnimationParser._parseStandardProperty(context, animationClip, animationInfo);
            }
            animationClipPromises.push(animationClip);
        }
        return AssetPromise.all(animationClipPromises).then(function(animationClips) {
            glTFResource.animations = animationClips;
            for(var i = 0; i < glTF.animations.length; i++){
                var animationInfo = glTF.animations[i];
                GLTFParser.executeExtensionsAdditiveAndParse(animationInfo.extensions, context, animationClips[i], animationInfo);
            }
            animationClipsPromiseInfo.resolve(animationClips);
            return animationClipsPromiseInfo.promise;
        });
    };
    /**
   * @internal
   */ GLTFAnimationParser._parseStandardProperty = function _parseStandardProperty(context, animationClip, animationInfo) {
        var glTF = context.glTF, glTFResource = context.glTFResource;
        var entities = glTFResource.entities;
        var accessors = glTF.accessors, bufferViews = glTF.bufferViews;
        var channels = animationInfo.channels, samplers = animationInfo.samplers;
        var sampleDataCollection = new Array();
        // parse samplers
        for(var j = 0, m = samplers.length; j < m; j++){
            var gltfSampler = samplers[j];
            var inputAccessor = accessors[gltfSampler.input];
            var outputAccessor = accessors[gltfSampler.output];
            var input = GLTFUtils.getAccessorBuffer(context, bufferViews, inputAccessor).data;
            var output = GLTFUtils.getAccessorBuffer(context, bufferViews, outputAccessor).data;
            if (outputAccessor.normalized) {
                var scale = GLTFUtils.getNormalizedComponentScale(outputAccessor.componentType);
                var scaled = new Float32Array(output.length);
                for(var k = 0, v = output.length; k < v; k++){
                    scaled[k] = output[k] * scale;
                }
                output = scaled;
            }
            var outputStride = output.length / input.length;
            var _gltfSampler_interpolation;
            var interpolation = (_gltfSampler_interpolation = gltfSampler.interpolation) != null ? _gltfSampler_interpolation : AnimationSamplerInterpolation.Linear;
            var samplerInterpolation = void 0;
            switch(interpolation){
                case AnimationSamplerInterpolation.CubicSpine:
                    samplerInterpolation = InterpolationType.CubicSpine;
                    break;
                case AnimationSamplerInterpolation.Step:
                    samplerInterpolation = InterpolationType.Step;
                    break;
                case AnimationSamplerInterpolation.Linear:
                    samplerInterpolation = InterpolationType.Linear;
                    break;
            }
            input[input.length - 1];
            sampleDataCollection.push({
                type: outputAccessor.type,
                interpolation: samplerInterpolation,
                input: input,
                output: output,
                outputSize: outputStride
            });
        }
        for(var j1 = 0, m1 = channels.length; j1 < m1; j1++){
            var gltfChannel = channels[j1];
            var target = gltfChannel.target;
            var channelTargetEntity = entities[target.node];
            var relativePath = "";
            var entity = channelTargetEntity;
            while(entity.parent){
                relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
                entity = entity.parent;
            }
            var ComponentType = void 0;
            var propertyName = void 0;
            switch(target.path){
                case AnimationChannelTargetPath.TRANSLATION:
                    ComponentType = Transform;
                    propertyName = "position";
                    break;
                case AnimationChannelTargetPath.ROTATION:
                    ComponentType = Transform;
                    propertyName = "rotationQuaternion";
                    break;
                case AnimationChannelTargetPath.SCALE:
                    ComponentType = Transform;
                    propertyName = "scale";
                    break;
                case AnimationChannelTargetPath.WEIGHTS:
                    ComponentType = SkinnedMeshRenderer;
                    propertyName = "blendShapeWeights";
                    break;
            }
            var curve = this._addCurve(target.path, gltfChannel, sampleDataCollection);
            animationClip.addCurveBinding(relativePath, ComponentType, propertyName, curve);
        }
    };
    GLTFAnimationParser._addCurve = function _addCurve(animationChannelTargetPath, gltfChannel, sampleDataCollection) {
        var sampleData = sampleDataCollection[gltfChannel.sampler];
        var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
        switch(animationChannelTargetPath){
            case AnimationChannelTargetPath.TRANSLATION:
            case AnimationChannelTargetPath.SCALE:
                {
                    var curve = new AnimationVector3Curve();
                    var interpolation = curve.interpolation = sampleData.interpolation;
                    var offset = 0;
                    for(var i = 0, n = input.length; i < n; i++){
                        var keyframe = new Keyframe();
                        keyframe.time = input[i];
                        if (interpolation === InterpolationType.CubicSpine) {
                            keyframe.inTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.outTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                        } else {
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                        }
                        curve.addKey(keyframe);
                    }
                    return curve;
                }
            case AnimationChannelTargetPath.ROTATION:
                {
                    var curve1 = new AnimationQuaternionCurve();
                    var interpolation1 = curve1.interpolation = sampleData.interpolation;
                    var offset1 = 0;
                    for(var i1 = 0, n1 = input.length; i1 < n1; i1++){
                        var keyframe1 = new Keyframe();
                        keyframe1.time = input[i1];
                        if (interpolation1 === InterpolationType.CubicSpine) {
                            keyframe1.inTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.outTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        } else {
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        }
                        curve1.addKey(keyframe1);
                    }
                    return curve1;
                }
            case AnimationChannelTargetPath.WEIGHTS:
                {
                    var curve2 = new AnimationFloatArrayCurve();
                    curve2.interpolation = sampleData.interpolation;
                    var offset2 = 0;
                    for(var i2 = 0, n2 = input.length; i2 < n2; i2++){
                        var keyframe2 = new Keyframe();
                        keyframe2.time = input[i2];
                        if (curve2.interpolation === InterpolationType.CubicSpine) {
                            keyframe2.inTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                            keyframe2.outTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                        } else {
                            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                        }
                        curve2.addKey(keyframe2);
                    }
                    return curve2;
                }
        }
    };
    return GLTFAnimationParser;
}(GLTFParser);

var GLTFBufferParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFBufferParser, GLTFParser);
    function GLTFBufferParser() {
        return GLTFParser.apply(this, arguments);
    }
    var _proto = GLTFBufferParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, contentRestorer = context.contentRestorer;
        var url = glTFResource.url;
        var restoreBufferRequests = contentRestorer.bufferRequests;
        var requestConfig = {
            type: "arraybuffer"
        };
        var isGLB = this._isGLB(url);
        contentRestorer.isGLB = isGLB;
        if (isGLB) {
            return request(url, requestConfig).then(function(glb) {
                restoreBufferRequests.push(new BufferRequestInfo(url, requestConfig));
                return GLTFUtils.parseGLB(context, glb);
            }).then(function(param) {
                var glTF = param.glTF, buffers = param.buffers;
                context.glTF = glTF;
                context.buffers = buffers;
            });
        } else {
            return request(url, {
                type: "json"
            }).then(function(glTF) {
                context.glTF = glTF;
                return Promise.all(glTF.buffers.map(function(buffer) {
                    var absoluteUrl = Utils.resolveAbsoluteUrl(url, buffer.uri);
                    restoreBufferRequests.push(new BufferRequestInfo(absoluteUrl, requestConfig));
                    return request(absoluteUrl, requestConfig);
                })).then(function(buffers) {
                    context.buffers = buffers;
                });
            });
        }
    };
    _proto._isGLB = function _isGLB(url) {
        var index = url.lastIndexOf(".");
        return url.substring(index + 1, index + 4) === "glb";
    };
    return GLTFBufferParser;
}(GLTFParser);

var GLTFEntityParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFEntityParser, GLTFParser);
    function GLTFEntityParser() {
        return GLTFParser.apply(this, arguments);
    }
    var _proto = GLTFEntityParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, nodes = context.glTF.nodes;
        var engine = glTFResource.engine;
        if (!nodes) return;
        var entities = [];
        for(var i = 0; i < nodes.length; i++){
            var gltfNode = nodes[i];
            var matrix = gltfNode.matrix, translation = gltfNode.translation, rotation = gltfNode.rotation, scale = gltfNode.scale;
            var entity = new Entity(engine, gltfNode.name || "" + GLTFEntityParser._defaultName + i);
            var transform = entity.transform;
            if (matrix) {
                var localMatrix = transform.localMatrix;
                localMatrix.copyFromArray(matrix);
                transform.localMatrix = localMatrix;
            } else {
                if (translation) {
                    transform.setPosition(translation[0], translation[1], translation[2]);
                }
                if (rotation) {
                    transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
                }
                if (scale) {
                    transform.setScale(scale[0], scale[1], scale[2]);
                }
            }
            entities[i] = entity;
        }
        glTFResource.entities = entities;
        this._buildEntityTree(context, glTFResource);
        this._createSceneRoots(context, glTFResource);
    };
    _proto._buildEntityTree = function _buildEntityTree(context, glTFResource) {
        var nodes = context.glTF.nodes;
        var entities = glTFResource.entities;
        for(var i = 0; i < nodes.length; i++){
            var children = nodes[i].children;
            var entity = entities[i];
            if (children) {
                for(var j = 0; j < children.length; j++){
                    var childEntity = entities[children[j]];
                    entity.addChild(childEntity);
                }
            }
        }
    };
    _proto._createSceneRoots = function _createSceneRoots(context, glTFResource) {
        var _context_glTF = context.glTF, tmp = _context_glTF.scene, sceneID = tmp === void 0 ? 0 : tmp, scenes = _context_glTF.scenes;
        var engine = glTFResource.engine, entities = glTFResource.entities;
        if (!scenes) return;
        var sceneRoots = [];
        for(var i = 0; i < scenes.length; i++){
            var nodes = scenes[i].nodes;
            if (!nodes) continue;
            if (nodes.length === 1) {
                sceneRoots[i] = entities[nodes[0]];
            } else {
                var rootEntity = new Entity(engine, "GLTF_ROOT");
                for(var j = 0; j < nodes.length; j++){
                    rootEntity.addChild(entities[nodes[j]]);
                }
                sceneRoots[i] = rootEntity;
            }
        }
        glTFResource.sceneRoots = sceneRoots;
        glTFResource.defaultSceneRoot = sceneRoots[sceneID];
        // @ts-ignore
        glTFResource.defaultSceneRoot._hookResource = glTFResource;
        // @ts-ignore
        glTFResource._addReferCount(1);
    };
    return GLTFEntityParser;
}(GLTFParser);
(function() {
    /** @internal */ GLTFEntityParser._defaultName = "_GLTF_ENTITY_";
})();

var GLTFMaterialParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMaterialParser, GLTFParser1);
    function GLTFMaterialParser() {
        return GLTFParser1.apply(this, arguments);
    }
    var _proto = GLTFMaterialParser.prototype;
    _proto.parse = function parse(context) {
        var glTF = context.glTF, glTFResource = context.glTFResource, materialsPromiseInfo = context.materialsPromiseInfo;
        if (!glTF.materials) return;
        var engine = glTFResource.engine;
        var materialPromises = [];
        for(var i = 0; i < glTF.materials.length; i++){
            var materialInfo = glTF.materials[i];
            var material = GLTFParser.executeExtensionsCreateAndParse(materialInfo.extensions, context, materialInfo);
            if (!material) {
                material = new PBRMaterial(engine);
                material.name = materialInfo.name;
                GLTFMaterialParser._parseStandardProperty(context, material, materialInfo);
            }
            materialPromises.push(material);
        }
        return AssetPromise.all(materialPromises).then(function(materials) {
            glTFResource.materials = materials;
            for(var i = 0; i < glTF.materials.length; i++){
                var materialInfo = glTF.materials[i];
                GLTFParser.executeExtensionsAdditiveAndParse(materialInfo.extensions, context, materials[i], materialInfo);
            }
            materialsPromiseInfo.resolve(materials);
            return materialsPromiseInfo.promise;
        });
    };
    /**
   * @internal
   */ GLTFMaterialParser._checkOtherTextureTransform = function _checkOtherTextureTransform(texture, textureName) {
        var _texture_extensions;
        if ((_texture_extensions = texture.extensions) == null ? void 0 : _texture_extensions.KHR_texture_transform) {
            Logger.warn("" + textureName + " texture always use the KHR_texture_transform of the base texture.");
        }
    };
    /**
   * @internal
   */ GLTFMaterialParser._parseStandardProperty = function _parseStandardProperty(context, material, materialInfo) {
        var textures = context.glTFResource.textures;
        var pbrMetallicRoughness = materialInfo.pbrMetallicRoughness, normalTexture = materialInfo.normalTexture, occlusionTexture = materialInfo.occlusionTexture, emissiveTexture = materialInfo.emissiveTexture, emissiveFactor = materialInfo.emissiveFactor, alphaMode = materialInfo.alphaMode, alphaCutoff = materialInfo.alphaCutoff, doubleSided = materialInfo.doubleSided;
        if (pbrMetallicRoughness) {
            var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
            if (baseColorFactor) {
                material.baseColor = new Color$1(Color$1.linearToGammaSpace(baseColorFactor[0]), Color$1.linearToGammaSpace(baseColorFactor[1]), Color$1.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
            }
            if (baseColorTexture) {
                material.baseTexture = textures[baseColorTexture.index];
                GLTFParser.executeExtensionsAdditiveAndParse(baseColorTexture.extensions, context, material, baseColorTexture);
            }
            if (material.constructor === PBRMaterial) {
                material.metallic = metallicFactor != null ? metallicFactor : 1;
                material.roughness = roughnessFactor != null ? roughnessFactor : 1;
                if (metallicRoughnessTexture) {
                    material.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
                    GLTFMaterialParser._checkOtherTextureTransform(metallicRoughnessTexture, "Roughness metallic");
                }
            }
        }
        if (material.constructor === PBRMaterial || material.constructor === PBRSpecularMaterial) {
            if (emissiveTexture) {
                material.emissiveTexture = textures[emissiveTexture.index];
                GLTFMaterialParser._checkOtherTextureTransform(emissiveTexture, "Emissive");
            }
            if (emissiveFactor) {
                material.emissiveColor = new Color$1(Color$1.linearToGammaSpace(emissiveFactor[0]), Color$1.linearToGammaSpace(emissiveFactor[1]), Color$1.linearToGammaSpace(emissiveFactor[2]));
            }
            if (normalTexture) {
                var index = normalTexture.index, scale = normalTexture.scale;
                material.normalTexture = textures[index];
                GLTFMaterialParser._checkOtherTextureTransform(normalTexture, "Normal");
                if (scale !== undefined) {
                    material.normalTextureIntensity = scale;
                }
            }
            if (occlusionTexture) {
                var index1 = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
                material.occlusionTexture = textures[index1];
                GLTFMaterialParser._checkOtherTextureTransform(occlusionTexture, "Occlusion");
                if (strength !== undefined) {
                    material.occlusionTextureIntensity = strength;
                }
                if (texCoord === TextureCoordinate.UV1) {
                    material.occlusionTextureCoord = TextureCoordinate.UV1;
                } else if (texCoord > TextureCoordinate.UV1) {
                    Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                }
            }
        }
        if (doubleSided) {
            material.renderFace = RenderFace.Double;
        } else {
            material.renderFace = RenderFace.Front;
        }
        switch(alphaMode){
            case MaterialAlphaMode.OPAQUE:
                material.isTransparent = false;
                break;
            case MaterialAlphaMode.BLEND:
                material.isTransparent = true;
                break;
            case MaterialAlphaMode.MASK:
                material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
                break;
        }
    };
    return GLTFMaterialParser;
}(GLTFParser);

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

var GLTFMeshParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFMeshParser, GLTFParser1);
    function GLTFMeshParser() {
        return GLTFParser1.apply(this, arguments);
    }
    var _proto = GLTFMeshParser.prototype;
    _proto.parse = function parse(context) {
        var _loop = function(i) {
            var _loop = function(j) {
                var gltfPrimitive = gltfMesh.primitives[j];
                primitivePromises[j] = new Promise(function(resolve) {
                    var mesh = GLTFParser.executeExtensionsCreateAndParse(gltfPrimitive.extensions, context, gltfPrimitive, gltfMesh);
                    if (mesh) {
                        if (_instanceof(mesh, ModelMesh)) {
                            resolve(mesh);
                        } else {
                            mesh.then(function(mesh) {
                                return resolve(mesh);
                            });
                        }
                    } else {
                        var mesh1 = new ModelMesh(engine, gltfMesh.name || j + "");
                        var meshRestoreInfo = new ModelMeshRestoreInfo();
                        meshRestoreInfo.mesh = mesh1;
                        context.contentRestorer.meshes.push(meshRestoreInfo);
                        GLTFMeshParser._parseMeshFromGLTFPrimitive(context, mesh1, meshRestoreInfo, gltfMesh, gltfPrimitive, glTF, function(attributeSemantic) {
                            return null;
                        }, function(attributeName, shapeIndex) {
                            var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
                            var attributeAccessorIdx = shapeAccessorIdx[attributeName];
                            if (attributeAccessorIdx) {
                                var accessor = glTF.accessors[attributeAccessorIdx];
                                return GLTFUtils.getAccessorBuffer(context, context.glTF.bufferViews, accessor);
                            } else {
                                return null;
                            }
                        }, function() {
                            var indexAccessor = glTF.accessors[gltfPrimitive.indices];
                            return GLTFUtils.getAccessorData(glTF, indexAccessor, buffers);
                        }, context.keepMeshData).then(resolve);
                    }
                });
            };
            var gltfMesh = glTF.meshes[i];
            var primitivePromises = [];
            for(var j = 0; j < gltfMesh.primitives.length; j++)_loop(j);
            meshPromises[i] = Promise.all(primitivePromises);
        };
        var glTF = context.glTF, buffers = context.buffers, glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        if (!glTF.meshes) return;
        var meshesPromiseInfo = context.meshesPromiseInfo;
        var meshPromises = [];
        for(var i = 0; i < glTF.meshes.length; i++)_loop(i);
        AssetPromise.all(meshPromises).then(function(meshes) {
            glTFResource.meshes = meshes;
            meshesPromiseInfo.resolve(meshes);
        }).catch(meshesPromiseInfo.reject);
        return meshesPromiseInfo.promise;
    };
    /**
   * @internal
   */ GLTFMeshParser._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(context, mesh, meshRestoreInfo, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
        var accessors = gltf.accessors;
        context.buffers;
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var engine = mesh.engine;
        var vertexElements = new Array();
        var vertexCount;
        var bufferBindIndex = 0;
        var positions;
        var boneIndices;
        var boneWeights;
        if (keepMeshData) {
            positions = new Array(vertexCount);
            boneIndices = new Array(vertexCount);
            boneWeights = new Array(vertexCount);
        }
        for(var attribute in attributes){
            var accessor = accessors[attributes[attribute]];
            var accessorBuffer = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, accessor);
            var dataElementSize = GLTFUtils.getAccessorTypeSize(accessor.type);
            var accessorCount = accessor.count;
            var vertices = accessorBuffer.data;
            var vertexElement = void 0;
            var meshId = mesh.instanceId;
            var vertexBindingInfos = accessorBuffer.vertexBindingInfos;
            var elementNormalized = accessor.normalized;
            var elementFormat = GLTFUtils.getElementFormat(accessor.componentType, dataElementSize, elementNormalized);
            var scaleFactor = void 0;
            elementNormalized && (scaleFactor = GLTFUtils.getNormalizedComponentScale(accessor.componentType));
            var elementOffset = void 0;
            if (accessorBuffer.interleaved) {
                var byteOffset = accessor.byteOffset || 0;
                var stride = accessorBuffer.stride;
                elementOffset = byteOffset % stride;
                if (vertexBindingInfos[meshId] === undefined) {
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                    var vertexBuffer = accessorBuffer.vertexBuffer;
                    if (!vertexBuffer) {
                        vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
                        vertexBuffer.setData(vertices);
                        accessorBuffer.vertexBuffer = vertexBuffer;
                        meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer, accessorBuffer.restoreInfo));
                    }
                    mesh.setVertexBufferBinding(vertexBuffer, stride, bufferBindIndex);
                    vertexBindingInfos[meshId] = bufferBindIndex++;
                } else {
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, vertexBindingInfos[meshId]);
                }
            } else {
                elementOffset = 0;
                vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                var vertexBuffer1 = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
                vertexBuffer1.setData(vertices);
                meshRestoreInfo.vertexBuffers.push(new BufferRestoreInfo(vertexBuffer1, accessorBuffer.restoreInfo));
                mesh.setVertexBufferBinding(vertexBuffer1, accessorBuffer.stride, bufferBindIndex);
                vertexBindingInfos[meshId] = bufferBindIndex++;
            }
            vertexElements.push(vertexElement);
            if (attribute === "POSITION") {
                vertexCount = accessorCount;
                var _mesh_bounds = mesh.bounds, min = _mesh_bounds.min, max = _mesh_bounds.max;
                if (accessor.min && accessor.max) {
                    min.copyFromArray(accessor.min);
                    max.copyFromArray(accessor.max);
                    if (keepMeshData) {
                        var baseOffset = elementOffset / vertices.BYTES_PER_ELEMENT;
                        var stride1 = vertices.length / accessorCount;
                        for(var j = 0; j < accessorCount; j++){
                            var offset = baseOffset + j * stride1;
                            var position = new Vector3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
                            elementNormalized && position.scale(scaleFactor);
                            positions[j] = position;
                        }
                    }
                } else {
                    var position1 = GLTFMeshParser._tempVector3;
                    min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                    max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    var baseOffset1 = elementOffset / vertices.BYTES_PER_ELEMENT;
                    var stride2 = vertices.length / accessorCount;
                    for(var j1 = 0; j1 < accessorCount; j1++){
                        var offset1 = baseOffset1 + j1 * stride2;
                        position1.copyFromArray(vertices, offset1);
                        Vector3.min(min, position1, min);
                        Vector3.max(max, position1, max);
                        if (keepMeshData) {
                            var clonePosition = position1.clone();
                            elementNormalized && clonePosition.scale(scaleFactor);
                            positions[j1] = clonePosition;
                        }
                    }
                }
                if (elementNormalized) {
                    min.scale(scaleFactor);
                    max.scale(scaleFactor);
                }
            } else if (attribute === "JOINTS_0" && keepMeshData) {
                var baseOffset2 = elementOffset / vertices.BYTES_PER_ELEMENT;
                var stride3 = vertices.length / accessorCount;
                for(var j2 = 0; j2 < accessorCount; j2++){
                    var offset2 = baseOffset2 + j2 * stride3;
                    var boneIndex = new Vector4(vertices[offset2], vertices[offset2 + 1], vertices[offset2 + 2], vertices[offset2 + 3]);
                    elementNormalized && boneIndex.scale(scaleFactor);
                    boneIndices[j2] = boneIndex;
                }
            } else if (attribute === "WEIGHTS_0" && keepMeshData) {
                var baseOffset3 = elementOffset / vertices.BYTES_PER_ELEMENT;
                var stride4 = vertices.length / accessorCount;
                for(var j3 = 0; j3 < accessorCount; j3++){
                    var offset3 = baseOffset3 + j3 * stride4;
                    var boneWeight = new Vector4(vertices[offset3], vertices[offset3 + 1], vertices[offset3 + 2], vertices[offset3 + 3]);
                    elementNormalized && boneWeight.scale(scaleFactor);
                    boneWeights[j3] = boneWeight;
                }
            }
        }
        mesh.setVertexElements(vertexElements);
        // Indices
        if (indices !== undefined) {
            var indexAccessor = gltf.accessors[indices];
            var accessorBuffer1 = GLTFUtils.getAccessorBuffer(context, gltf.bufferViews, indexAccessor);
            mesh.setIndices(accessorBuffer1.data);
            mesh.addSubMesh(0, indexAccessor.count, mode);
            meshRestoreInfo.indexBuffer = accessorBuffer1.restoreInfo;
        } else {
            mesh.addSubMesh(0, vertexCount, mode);
        }
        // BlendShapes
        targets && GLTFMeshParser._createBlendShape(mesh, meshRestoreInfo, gltfMesh, targets, getBlendShapeData);
        mesh.uploadData(!keepMeshData);
        //@ts-ignore
        mesh._positions = positions;
        //@ts-ignore
        mesh._boneIndices = boneIndices;
        //@ts-ignore
        mesh._boneWeights = boneWeights;
        return Promise.resolve(mesh);
    };
    /**
   * @internal
   */ GLTFMeshParser._createBlendShape = function _createBlendShape(mesh, meshRestoreInfo, glTFMesh, glTFTargets, getBlendShapeData) {
        var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
        for(var i = 0, n = glTFTargets.length; i < n; i++){
            var name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
            var deltaPosBufferInfo = getBlendShapeData("POSITION", i);
            var deltaNorBufferInfo = getBlendShapeData("NORMAL", i);
            var deltaTanBufferInfo = getBlendShapeData("TANGENT", i);
            var deltaPositions = deltaPosBufferInfo.data ? GLTFUtils.floatBufferToVector3Array(deltaPosBufferInfo.data) : null;
            var deltaNormals = (deltaNorBufferInfo == null ? void 0 : deltaNorBufferInfo.data) ? GLTFUtils.floatBufferToVector3Array(deltaNorBufferInfo == null ? void 0 : deltaNorBufferInfo.data) : null;
            var deltaTangents = (deltaTanBufferInfo == null ? void 0 : deltaTanBufferInfo.data) ? GLTFUtils.floatBufferToVector3Array(deltaTanBufferInfo == null ? void 0 : deltaTanBufferInfo.data) : null;
            var blendShape = new BlendShape(name);
            blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
            mesh.addBlendShape(blendShape);
            meshRestoreInfo.blendShapes.push(new BlendShapeRestoreInfo(blendShape, deltaPosBufferInfo.restoreInfo, deltaNorBufferInfo == null ? void 0 : deltaNorBufferInfo.restoreInfo, deltaTanBufferInfo == null ? void 0 : deltaTanBufferInfo.restoreInfo));
        }
    };
    return GLTFMeshParser;
}(GLTFParser);
(function() {
    GLTFMeshParser._tempVector3 = new Vector3();
})();

var GLTFSceneParser = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFSceneParser, GLTFParser1);
    function GLTFSceneParser() {
        return GLTFParser1.apply(this, arguments);
    }
    var _proto = GLTFSceneParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, glTF = context.glTF;
        var entities = glTFResource.entities;
        var nodes = glTF.nodes, cameras = glTF.cameras;
        if (!nodes) return;
        var defaultSceneRootPromiseInfo = context.defaultSceneRootPromiseInfo;
        for(var i = 0; i < nodes.length; i++){
            var glTFNode = nodes[i];
            var cameraID = glTFNode.camera, meshID = glTFNode.mesh, extensions = glTFNode.extensions;
            var entity = entities[i];
            if (cameraID !== undefined) {
                this._createCamera(glTFResource, cameras[cameraID], entity);
            }
            if (meshID !== undefined) {
                this._createRenderer(context, glTFNode, entity);
            }
            GLTFParser.executeExtensionsAdditiveAndParse(extensions, context, entity, glTFNode);
        }
        if (glTFResource.defaultSceneRoot) {
            this._createAnimator(context);
        }
        defaultSceneRootPromiseInfo.resolve(glTFResource.defaultSceneRoot);
        return defaultSceneRootPromiseInfo.promise;
    };
    _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
        var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
        var camera = entity.addComponent(exports.Camera);
        if (type === CameraType.ORTHOGRAPHIC) {
            var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
            camera.isOrthographic = true;
            if (znear !== undefined) {
                camera.nearClipPlane = znear;
            }
            if (zfar !== undefined) {
                camera.farClipPlane = zfar;
            }
            camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
        } else if (type === CameraType.PERSPECTIVE) {
            var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, zfar1 = perspective.zfar, znear1 = perspective.znear;
            if (aspectRatio !== undefined) {
                camera.aspectRatio = aspectRatio;
            }
            if (yfov !== undefined) {
                camera.fieldOfView = yfov * 180 / Math.PI;
            }
            if (zfar1 !== undefined) {
                camera.farClipPlane = zfar1;
            }
            if (znear1 !== undefined) {
                camera.nearClipPlane = znear1;
            }
        }
        if (!context.cameras) context.cameras = [];
        context.cameras.push(camera);
        // @todo: use engine camera by default
        camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, glTFNode, entity) {
        var _loop = function(i) {
            var gltfPrimitive = glTFMeshPrimitives[i];
            var mesh = meshes[meshID][i];
            var renderer = void 0;
            if (skinID !== undefined || blendShapeWeights) {
                context.hasSkinned = true;
                var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
                skinRenderer.mesh = mesh;
                if (skinID !== undefined) {
                    skinRenderer.skin = skins[skinID];
                }
                if (blendShapeWeights) {
                    skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
                }
                renderer = skinRenderer;
            } else {
                renderer = entity.addComponent(MeshRenderer);
                renderer.mesh = mesh;
            }
            var materialIndex = gltfPrimitive.material;
            var material = (materials == null ? void 0 : materials[materialIndex]) || GLTFSceneParser._getDefaultMaterial(engine);
            renderer.setMaterial(material);
            // Enable vertex color if mesh has COLOR_0 vertex element
            mesh.vertexElements.forEach(function(element) {
                if (element.semantic === "COLOR_0") {
                    renderer.enableVertexColor = true;
                }
            });
            GLTFParser.executeExtensionsAdditiveAndParse(gltfPrimitive.extensions, context, renderer, gltfPrimitive);
        };
        var glTFResource = context.glTFResource, glTF = context.glTF;
        var glTFMeshes = glTF.meshes;
        var engine = glTFResource.engine, meshes = glTFResource.meshes, materials = glTFResource.materials, skins = glTFResource.skins;
        var meshID = glTFNode.mesh, skinID = glTFNode.skin;
        var glTFMesh = glTFMeshes[meshID];
        var glTFMeshPrimitives = glTFMesh.primitives;
        var blendShapeWeights = glTFNode.weights || glTFMesh.weights;
        for(var i = 0; i < glTFMeshPrimitives.length; i++)_loop(i);
    };
    _proto._createAnimator = function _createAnimator(context) {
        if (!context.hasSkinned && !context.glTFResource.animations) {
            return;
        }
        var _context_glTFResource = context.glTFResource, defaultSceneRoot = _context_glTFResource.defaultSceneRoot, animations = _context_glTFResource.animations;
        var animator = defaultSceneRoot.addComponent(Animator);
        var animatorController = new AnimatorController();
        var layer = new AnimatorControllerLayer("layer");
        var animatorStateMachine = new AnimatorStateMachine();
        animatorController.addLayer(layer);
        animator.animatorController = animatorController;
        layer.stateMachine = animatorStateMachine;
        if (animations) {
            for(var i = 0; i < animations.length; i++){
                var animationClip = animations[i];
                var name = animationClip.name;
                var uniqueName = animatorStateMachine.makeUniqueStateName(name);
                if (uniqueName !== name) {
                    console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
                }
                var animatorState = animatorStateMachine.addState(uniqueName);
                animatorState.clip = animationClip;
            }
        }
    };
    GLTFSceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
        if (!GLTFSceneParser._defaultMaterial) {
            GLTFSceneParser._defaultMaterial = new BlinnPhongMaterial(engine);
        }
        return GLTFSceneParser._defaultMaterial;
    };
    return GLTFSceneParser;
}(GLTFParser);

var GLTFSkinParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFSkinParser, GLTFParser);
    function GLTFSkinParser() {
        return GLTFParser.apply(this, arguments);
    }
    var _proto = GLTFSkinParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, glTF = context.glTF; context.buffers;
        var entities = glTFResource.entities;
        var gltfSkins = glTF.skins;
        if (!gltfSkins) return;
        var count = gltfSkins.length;
        var skins = new Array(count);
        for(var i = 0; i < count; i++){
            var _gltfSkins_i = gltfSkins[i], inverseBindMatrices = _gltfSkins_i.inverseBindMatrices, skeleton = _gltfSkins_i.skeleton, joints = _gltfSkins_i.joints, _gltfSkins_i_name = _gltfSkins_i.name, name = _gltfSkins_i_name === void 0 ? "SKIN_" + i : _gltfSkins_i_name;
            var jointCount = joints.length;
            var skin = new Skin(name);
            skin.inverseBindMatrices.length = jointCount;
            // parse IBM
            var accessor = glTF.accessors[inverseBindMatrices];
            var buffer = GLTFUtils.getAccessorBuffer(context, glTF.bufferViews, accessor).data;
            for(var i1 = 0; i1 < jointCount; i1++){
                var inverseBindMatrix = new Matrix();
                inverseBindMatrix.copyFromArray(buffer, i1 * 16);
                skin.inverseBindMatrices[i1] = inverseBindMatrix;
            }
            // get joints
            for(var i2 = 0; i2 < jointCount; i2++){
                var jointIndex = joints[i2];
                var jointName = entities[jointIndex].name;
                skin.joints[i2] = jointName;
                // @todo Temporary solution, but it can alleviate the current BUG, and the skinning data mechanism of SkinnedMeshRenderer will be completely refactored in the future
                for(var j = entities.length - 1; j >= 0; j--){
                    if (jointIndex !== j && entities[j].name === jointName) {
                        entities[j].name = jointName + "_" + j;
                    }
                }
            }
            // get skeleton
            if (skeleton !== undefined) {
                skin.skeleton = entities[skeleton].name;
            } else {
                var rootBone = this._findSkeletonRootBone(joints, entities);
                if (rootBone) {
                    skin.skeleton = rootBone.name;
                } else {
                    throw "Failed to find skeleton root bone.";
                }
            }
            skins[i] = skin;
        }
        glTFResource.skins = skins;
    };
    _proto._findSkeletonRootBone = function _findSkeletonRootBone(joints, entities) {
        var paths = {};
        for(var _iterator = _create_for_of_iterator_helper_loose(joints), _step; !(_step = _iterator()).done;){
            var index = _step.value;
            var path = new Array();
            var entity = entities[index];
            while(entity){
                path.unshift(entity);
                entity = entity.parent;
            }
            paths[index] = path;
        }
        var rootNode = null;
        for(var i = 0;; i++){
            var path1 = paths[joints[0]];
            if (i >= path1.length) {
                return rootNode;
            }
            var entity1 = path1[i];
            for(var j = 1, m = joints.length; j < m; j++){
                path1 = paths[joints[j]];
                if (i >= path1.length || entity1 !== path1[i]) {
                    return rootNode;
                }
            }
            rootNode = entity1;
        }
    };
    return GLTFSkinParser;
}(GLTFParser);

var GLTFTextureParser = /*#__PURE__*/ function(GLTFParser) {
    _inherits(GLTFTextureParser, GLTFParser);
    function GLTFTextureParser() {
        return GLTFParser.apply(this, arguments);
    }
    var _proto = GLTFTextureParser.prototype;
    _proto.parse = function parse(context) {
        var _this = this;
        var glTFResource = context.glTFResource, glTF = context.glTF, buffers = context.buffers;
        var engine = glTFResource.engine, url = glTFResource.url;
        if (glTF.textures) {
            var texturesPromiseInfo = context.texturesPromiseInfo;
            AssetPromise.all(glTF.textures.map(function(param, index) {
                var sampler = param.sampler, _param_source = param.source, source = _param_source === void 0 ? 0 : _param_source, textureName = param.name;
                var _glTF_images_source = glTF.images[source], uri = _glTF_images_source.uri, bufferViewIndex = _glTF_images_source.bufferView, mimeType = _glTF_images_source.mimeType, imageName = _glTF_images_source.name;
                if (uri) {
                    // TODO: support ktx extension https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md
                    var index1 = uri.lastIndexOf(".");
                    var ext = uri.substring(index1 + 1);
                    var type = ext.startsWith("ktx") ? exports.AssetType.KTX : exports.AssetType.Texture2D;
                    return engine.resourceManager.load({
                        url: Utils.resolveAbsoluteUrl(url, uri),
                        type: type
                    }).then(function(texture) {
                        if (!texture.name) {
                            texture.name = textureName || imageName || "texture_" + index1;
                        }
                        if (sampler !== undefined) {
                            _this._parseSampler(texture, glTF.samplers[sampler]);
                        }
                        return texture;
                    });
                } else {
                    var bufferView = glTF.bufferViews[bufferViewIndex];
                    var buffer = buffers[bufferView.buffer];
                    var imageBuffer = new Uint8Array(buffer, bufferView.byteOffset, bufferView.byteLength);
                    return GLTFUtils.loadImageBuffer(imageBuffer, mimeType).then(function(image) {
                        var texture = new Texture2D(engine, image.width, image.height);
                        texture.setImageSource(image);
                        texture.generateMipmaps();
                        texture.name = textureName || imageName || "texture_" + index;
                        if (sampler !== undefined) {
                            _this._parseSampler(texture, glTF.samplers[sampler]);
                        }
                        var bufferTextureRestoreInfo = new BufferTextureRestoreInfo(texture, bufferView, mimeType);
                        context.contentRestorer.bufferTextures.push(bufferTextureRestoreInfo);
                        return texture;
                    });
                }
            })).then(function(textures) {
                glTFResource.textures = textures;
                texturesPromiseInfo.resolve(textures);
            }).catch(texturesPromiseInfo.reject);
            return texturesPromiseInfo.promise;
        }
    };
    _proto._parseSampler = function _parseSampler(texture, sampler) {
        var magFilter = sampler.magFilter, minFilter = sampler.minFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
        if (magFilter || minFilter) {
            if (magFilter === TextureMagFilter.NEAREST) {
                texture.filterMode = TextureFilterMode.Point;
            } else if (minFilter <= TextureMinFilter.LINEAR_MIPMAP_NEAREST) {
                texture.filterMode = TextureFilterMode.Bilinear;
            } else {
                texture.filterMode = TextureFilterMode.Trilinear;
            }
        }
        if (wrapS) {
            texture.wrapModeU = GLTFTextureParser._wrapMap[wrapS];
        }
        if (wrapT) {
            texture.wrapModeV = GLTFTextureParser._wrapMap[wrapT];
        }
    };
    return GLTFTextureParser;
}(GLTFParser);
(function() {
    var _obj;
    GLTFTextureParser._wrapMap = (_obj = {}, _obj[TextureWrapMode.CLAMP_TO_EDGE] = TextureWrapMode$1.Clamp, _obj[TextureWrapMode.MIRRORED_REPEAT] = TextureWrapMode$1.Mirror, _obj[TextureWrapMode.REPEAT] = TextureWrapMode$1.Repeat, _obj);
})();

var GLTFValidator = /*#__PURE__*/ function(GLTFParser1) {
    _inherits(GLTFValidator, GLTFParser1);
    function GLTFValidator() {
        return GLTFParser1.apply(this, arguments);
    }
    var _proto = GLTFValidator.prototype;
    _proto.parse = function parse(context) {
        var _context_glTF = context.glTF, version = _context_glTF.asset.version, extensionsUsed = _context_glTF.extensionsUsed, extensionsRequired = _context_glTF.extensionsRequired;
        var glTFVersion = Number(version);
        if (!(glTFVersion >= 2 && glTFVersion < 3)) {
            throw "Only support glTF 2.x.";
        }
        var promises = [];
        if (extensionsUsed) {
            Logger.info("extensionsUsed: ", extensionsUsed);
            for(var i = 0; i < extensionsUsed.length; i++){
                var extensionUsed = extensionsUsed[i];
                if (!GLTFParser.hasExtensionParser(extensionUsed)) {
                    Logger.warn("Extension " + extensionUsed + " is not implemented, you can customize this extension in gltf.");
                }
            }
        }
        if (extensionsRequired) {
            Logger.info("extensionsRequired: " + extensionsRequired);
            for(var i1 = 0; i1 < extensionsRequired.length; i1++){
                var extensionRequired = extensionsRequired[i1];
                if (!GLTFParser.hasExtensionParser(extensionRequired)) {
                    Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
                } else {
                    promises.push(GLTFParser.executeExtensionsInitialize(extensionRequired));
                }
            }
        }
        return AssetPromise.all(promises).then(null);
    };
    return GLTFValidator;
}(GLTFParser);

/**
 * GLTF pipeline.
 */ var GLTFPipeline = /*#__PURE__*/ function() {
    function GLTFPipeline() {
        for(var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++){
            parsers[_key] = arguments[_key];
        }
        var _this = this;
        this._parsers = [];
        parsers.forEach(function(pipe, index) {
            _this._parsers[index] = new pipe();
        });
    }
    var _proto = GLTFPipeline.prototype;
    /**
   * @internal
   */ _proto._parse = function _parse(context) {
        var _this = this;
        var glTFResource = context.glTFResource;
        var lastParser;
        return new AssetPromise(function(resolve, reject) {
            _this._parsers.forEach(function(parser) {
                if (lastParser) {
                    lastParser = lastParser.then(function() {
                        return parser.parse(context);
                    });
                    if (lastParser.cancel) {
                        context.chainPromises.push(lastParser);
                    }
                } else {
                    lastParser = parser.parse(context);
                }
            });
            if (lastParser) {
                lastParser.then(function() {
                    resolve(glTFResource);
                }).catch(reject);
            }
        });
    };
    return GLTFPipeline;
}();
(function() {
    /**
   * Default pipeline.
   */ GLTFPipeline.defaultPipeline = new GLTFPipeline(GLTFBufferParser, GLTFValidator, GLTFTextureParser, GLTFMaterialParser, GLTFMeshParser, GLTFEntityParser, GLTFSkinParser, GLTFAnimationParser, GLTFSceneParser);
})();

/**
 * Product after glTF parser, usually, `defaultSceneRoot` is only needed to use.
 */ var GLTFResource = /*#__PURE__*/ function(ReferResource) {
    _inherits(GLTFResource, ReferResource);
    function GLTFResource(engine, url) {
        var _this;
        _this = ReferResource.call(this, engine) || this;
        _this.url = url;
        return _this;
    }
    return GLTFResource;
}(ReferResource);

var GLTFLoader = /*#__PURE__*/ function(Loader) {
    _inherits(GLTFLoader, Loader);
    function GLTFLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = GLTFLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var url = item.url;
        var params = item.params;
        var context = new GLTFParserContext(url);
        var glTFResource = new GLTFResource(resourceManager.engine, url);
        var restorer = new GLTFContentRestorer(glTFResource);
        var masterPromiseInfo = context.masterPromiseInfo;
        context.contentRestorer = restorer;
        context.glTFResource = glTFResource;
        var _params_keepMeshData;
        context.keepMeshData = (_params_keepMeshData = params == null ? void 0 : params.keepMeshData) != null ? _params_keepMeshData : false;
        masterPromiseInfo.onCancel(function() {
            var chainPromises = context.chainPromises;
            for(var _iterator = _create_for_of_iterator_helper_loose(chainPromises), _step; !(_step = _iterator()).done;){
                var promise = _step.value;
                promise.cancel();
            }
        });
        ((params == null ? void 0 : params.pipeline) || GLTFPipeline.defaultPipeline)._parse(context).then(function(glTFResource) {
            resourceManager.addContentRestorer(restorer);
            masterPromiseInfo.resolve(glTFResource);
        }).catch(function(e) {
            console.error(e);
            masterPromiseInfo.reject("Error loading glTF model from " + url + " .");
        });
        return context.promiseMap;
    };
    return GLTFLoader;
}(Loader);
GLTFLoader = __decorate([
    resourceLoader(exports.AssetType.GLTF, [
        "gltf",
        "glb"
    ])
], GLTFLoader);

var _HDRLoader;
var PI = Math.PI;
var HDRLoader = (_HDRLoader = /*#__PURE__*/ function(Loader) {
    _inherits(HDRLoader1, Loader);
    function HDRLoader1() {
        return Loader.apply(this, arguments);
    }
    var _proto = HDRLoader1.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var engine = resourceManager.engine;
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(buffer) {
                var uint8Array = new Uint8Array(buffer);
                var _HDRLoader__parseHeader = HDRLoader._parseHeader(uint8Array), width = _HDRLoader__parseHeader.width, height = _HDRLoader__parseHeader.height, dataPosition = _HDRLoader__parseHeader.dataPosition;
                var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
                var cubeSize = height >> 1;
                var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
                var texture = new TextureCube(engine, cubeSize);
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
                }
                texture.generateMipmaps();
                resolve(texture);
            }).catch(reject);
        });
    };
    HDRLoader1._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
        if (!pixels) {
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (pixels.length != inputWidth * inputHeight * 4) {
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
        var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
        var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
        var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
        var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
        var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
        return [
            textureRight,
            textureLeft,
            textureUp,
            textureDown,
            textureFront,
            textureBack
        ];
    };
    HDRLoader1._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
        var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
        var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
        var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
        var dy = 1 / texSize;
        var fy = 0;
        for(var y = 0; y < texSize; y++){
            var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
            var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
            for(var x = 0; x < texSize; x++){
                var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
                v.normalize();
                var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
                this._RGBEToLinear(color);
                this._linearToRGBM(color, 5);
                // 4 channels per pixels
                var index = y * texSize * 4 + x * 4;
                textureArray[index] = color.r;
                textureArray[index + 1] = color.g;
                textureArray[index + 2] = color.b;
                textureArray[index + 3] = color.a;
                xv1.add(rotDX1);
                xv2.add(rotDX2);
            }
            fy += dy;
        }
        return textureArray;
    };
    HDRLoader1._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
        var theta = Math.atan2(vDir.z, vDir.x);
        var phi = Math.acos(vDir.y);
        while(theta < -PI){
            theta += 2 * PI;
        }
        while(theta > PI){
            theta -= 2 * PI;
        }
        var dx = theta / PI;
        var dy = phi / PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        var px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        } else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        var py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        } else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        var inputY = inputHeight - py - 1;
        var index = inputY * inputWidth * 4 + px * 4;
        var r = pixels[index];
        var g = pixels[index + 1];
        var b = pixels[index + 2];
        var a = pixels[index + 3];
        return new Color$1(r, g, b, a);
    };
    HDRLoader1._readStringLine = function _readStringLine(uint8array, startIndex) {
        var line = "";
        var character = "";
        for(var i = startIndex; i < uint8array.length - startIndex; i++){
            character = String.fromCharCode(uint8array[i]);
            if (character == "\n") {
                break;
            }
            line += character;
        }
        return line;
    };
    HDRLoader1._parseHeader = function _parseHeader(uint8array) {
        var height = 0;
        var width = 0;
        var line = this._readStringLine(uint8array, 0);
        if (line[0] != "#" || line[1] != "?") {
            throw "Bad HDR Format.";
        }
        var endOfHeader = false;
        var findFormat = false;
        var lineIndex = 0;
        do {
            lineIndex += line.length + 1;
            line = this._readStringLine(uint8array, lineIndex);
            if (line == "FORMAT=32-bit_rle_rgbe") {
                findFormat = true;
            } else if (line.length == 0) {
                endOfHeader = true;
            }
        }while (!endOfHeader);
        if (!findFormat) {
            throw "HDR Bad header format, unsupported FORMAT";
        }
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
        var match = sizeRegexp.exec(line);
        // TODO. Support +Y and -X if needed.
        if (!match || match.length < 3) {
            throw "HDR Bad header format, no size";
        }
        width = parseInt(match[2]);
        height = parseInt(match[1]);
        if (width < 8 || width > 0x7fff) {
            throw "HDR Bad header format, unsupported size";
        }
        lineIndex += line.length + 1;
        return {
            height: height,
            width: width,
            dataPosition: lineIndex
        };
    };
    HDRLoader1._readPixels = function _readPixels(buffer, width, height) {
        var scanLineWidth = width;
        var byteLength = buffer.byteLength;
        var dataRGBA = new Uint8Array(4 * width * height);
        var offset = 0, pos = 0;
        var ptrEnd = 4 * scanLineWidth;
        var rgbeStart = new Uint8Array(4);
        var scanLineBuffer = new Uint8Array(ptrEnd);
        var numScanLines = height; // read in each successive scanLine
        while(numScanLines > 0 && pos < byteLength){
            rgbeStart[0] = buffer[pos++];
            rgbeStart[1] = buffer[pos++];
            rgbeStart[2] = buffer[pos++];
            rgbeStart[3] = buffer[pos++];
            if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
                throw "HDR Bad header format, wrong scan line width";
            }
            // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent
            var ptr = 0, count = void 0;
            while(ptr < ptrEnd && pos < byteLength){
                count = buffer[pos++];
                var isEncodedRun = count > 128;
                if (isEncodedRun) count -= 128;
                if (0 === count || ptr + count > ptrEnd) {
                    throw "HDR Bad Format, bad scanline data (run)";
                }
                if (isEncodedRun) {
                    // a (encoded) run of the same value
                    var byteValue = buffer[pos++];
                    for(var i = 0; i < count; i++){
                        scanLineBuffer[ptr++] = byteValue;
                    } //ptr += count;
                } else {
                    // a literal-run
                    scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
                    ptr += count;
                    pos += count;
                }
            } // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)
            var l = scanLineWidth; //scanLine_buffer.byteLength;
            for(var i1 = 0; i1 < l; i1++){
                var off = 0;
                dataRGBA[offset] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 1] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 2] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 3] = scanLineBuffer[i1 + off];
                offset += 4;
            }
            numScanLines--;
        }
        return dataRGBA;
    };
    HDRLoader1._RGBEToLinear = function _RGBEToLinear(color) {
        var scaleFactor = Math.pow(2, color.a - 128) / 255;
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a = 1;
    };
    HDRLoader1._linearToRGBM = function _linearToRGBM(color, maxRange) {
        var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
        var M = Math.min(maxRGB / maxRange, 1);
        M = Math.ceil(M * 255);
        var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a *= M;
    };
    return HDRLoader1;
}(Loader), function() {
    _HDRLoader._rightBottomBack = new Vector3(1.0, -1.0, -1.0);
}(), function() {
    _HDRLoader._rightBottomFront = new Vector3(1.0, -1.0, 1.0);
}(), function() {
    _HDRLoader._rightUpBack = new Vector3(1.0, 1.0, -1.0);
}(), function() {
    _HDRLoader._rightUpFront = new Vector3(1.0, 1.0, 1.0);
}(), function() {
    _HDRLoader._leftBottomBack = new Vector3(-1.0, -1.0, -1.0);
}(), function() {
    _HDRLoader._leftBottomFront = new Vector3(-1.0, -1.0, 1.0);
}(), function() {
    _HDRLoader._leftUpBack = new Vector3(-1.0, 1.0, -1.0);
}(), function() {
    _HDRLoader._leftUpFront = new Vector3(-1.0, 1.0, 1.0);
}(), function() {
    _HDRLoader._faceRight = [
        _HDRLoader._rightBottomBack,
        _HDRLoader._rightBottomFront,
        _HDRLoader._rightUpBack,
        _HDRLoader._rightUpFront
    ];
}(), function() {
    _HDRLoader._faceLeft = [
        _HDRLoader._leftBottomFront,
        _HDRLoader._leftBottomBack,
        _HDRLoader._leftUpFront,
        _HDRLoader._leftUpBack
    ];
}(), function() {
    _HDRLoader._faceUp = [
        _HDRLoader._leftBottomFront,
        _HDRLoader._rightBottomFront,
        _HDRLoader._leftBottomBack,
        _HDRLoader._rightBottomBack
    ];
}(), function() {
    _HDRLoader._faceBottom = [
        _HDRLoader._leftUpBack,
        _HDRLoader._rightUpBack,
        _HDRLoader._leftUpFront,
        _HDRLoader._rightUpFront
    ];
}(), function() {
    _HDRLoader._faceFront = [
        _HDRLoader._leftBottomBack,
        _HDRLoader._rightBottomBack,
        _HDRLoader._leftUpBack,
        _HDRLoader._rightUpBack
    ];
}(), function() {
    _HDRLoader._faceBack = [
        _HDRLoader._rightBottomFront,
        _HDRLoader._leftBottomFront,
        _HDRLoader._rightUpFront,
        _HDRLoader._leftUpFront
    ];
}(), function() {
    _HDRLoader._tempVector3 = new Vector3();
}(), function() {
    _HDRLoader._temp2Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp3Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp4Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp5Vector3 = new Vector3();
}(), _HDRLoader);
HDRLoader = __decorate([
    resourceLoader(exports.AssetType.HDR, [
        "hdr"
    ])
], HDRLoader);

var JSONLoader = /*#__PURE__*/ function(Loader) {
    _inherits(JSONLoader, Loader);
    function JSONLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item) {
        return this.request(item.url, _extends({}, item, {
            type: "json"
        }));
    };
    return JSONLoader;
}(Loader);
JSONLoader = __decorate([
    resourceLoader(exports.AssetType.JSON, [
        "json"
    ], false)
], JSONLoader);

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    // initialize width & height for level 1
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
    for(var level = 0; level < mipmapCount; level++){
        var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
        dataOffset += 4; // size of the image + 4 for the imageSize field
        for(var face = 0; face < ktxContainer.numberOfFaces; face++){
            var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
            mipmaps.push({
                data: byteArray,
                width: width,
                height: height
            });
            dataOffset += imageSize;
            dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
        }
        width = Math.max(1.0, width * 0.5);
        height = Math.max(1.0, height * 0.5);
    }
    return mipmaps;
}
/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */ function isValid(data) {
    if (data.byteLength >= 12) {
        // 'Â«', 'K', 'T', 'X', ' ', '1', '1', 'Â»', '\r', '\n', '\x1A', '\n'
        var identifier = new Uint8Array(data, 0, 12);
        if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
            return true;
        }
    }
    return false;
}
function getEngineFormat(internalFormat) {
    switch(internalFormat){
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        // break;
        case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
            return TextureFormat.DXT1;
        case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
            return TextureFormat.DXT5;
        case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
            return TextureFormat.ETC1_RGB;
        case GLCompressedTextureInternalFormat.RGB8_ETC2:
            return TextureFormat.ETC2_RGB;
        case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
            return TextureFormat.ETC2_RGBA5;
        case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
            return TextureFormat.ETC2_RGBA8;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGB2;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA2;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGB4;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
            return TextureFormat.ASTC_4x4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
            return TextureFormat.ASTC_5x5;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
            return TextureFormat.ASTC_6x6;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
            return TextureFormat.ASTC_8x8;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
            return TextureFormat.ASTC_10x10;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
            return TextureFormat.ASTC_12x12;
        default:
            var formatName = GLCompressedTextureInternalFormat[internalFormat];
            throw new Error("this format is not supported in Galacean Engine: " + formatName);
    }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */ var khronosTextureContainerParser = {
    /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Galacean Engine native TextureFormat?
   */ parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
        if (mapEngineFormat === void 0) mapEngineFormat = false;
        if (!isValid(buffer)) {
            throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(buffer, 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        var parsedResult = {
            buffer: buffer,
            glType: headerDataView.getUint32(1 * dataSize, littleEndian),
            glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
            glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
            glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
            glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
            pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
            pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
            pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
            numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
            numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
            numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
            bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
            // would need to make this more elaborate & adjust checks above to support more than one load type
            loadType: COMPRESSED_2D
        };
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (parsedResult.glType !== 0) {
            throw new Error("only compressed formats currently supported");
        } else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
        }
        if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
            throw new Error("only 2D textures currently supported");
        }
        if (parsedResult.numberOfArrayElements !== 0) {
            throw new Error("texture arrays not currently supported");
        }
        if (parsedResult.numberOfFaces !== facesExpected) {
            throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
        }
        if (withMipmaps) {
            parsedResult.mipmaps = getMipmaps(parsedResult, true);
        }
        if (mapEngineFormat) {
            parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
        }
        return parsedResult;
    }
};

function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
        mipmaps: ktx.mipmaps,
        engineFormat: ktx.engineFormat,
        internalFormat: ktx.glInternalFormat,
        width: ktx.pixelWidth,
        height: ktx.pixelHeight
    };
}
function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for(var i = 0; i < dataArray.length; i++){
        var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
        mipmapsFaces.push(ktx.mipmaps);
        if (i === 0) {
            width = ktx.pixelWidth;
            height = ktx.pixelHeight;
            internalFormat = ktx.glInternalFormat;
            engineFormat = ktx.engineFormat;
        }
    }
    return {
        mipmapsFaces: mipmapsFaces,
        engineFormat: engineFormat,
        internalFormat: internalFormat,
        width: width,
        height: height
    };
}

var KTXCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXCubeLoader, Loader);
    function KTXCubeLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(item.urls.map(function(url) {
                return _this.request(url, _extends({}, item, {
                    type: "arraybuffer"
                }));
            })).then(function(data) {
                var parsedData = parseCubeKTX(data);
                var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
                var mipmap = mipmapsFaces[0].length > 1;
                var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
                for(var face = 0; face < 6; face++){
                    var length = mipmapsFaces[face].length;
                    for(var miplevel = 0; miplevel < length; miplevel++){
                        var _mipmapsFaces_face_miplevel = mipmapsFaces[face][miplevel], _$data = _mipmapsFaces_face_miplevel.data, width1 = _mipmapsFaces_face_miplevel.width, height = _mipmapsFaces_face_miplevel.height;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _$data, miplevel, 0, 0, width1, height);
                    }
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXCubeLoader;
}(Loader);
KTXCubeLoader = __decorate([
    resourceLoader(exports.AssetType.KTXCube, [])
], KTXCubeLoader);

var KTXLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXLoader, Loader);
    function KTXLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(bin) {
                var parsedData = parseSingleKTX(bin);
                var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
                var mipmap = mipmaps.length > 1;
                var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
                for(var miplevel = 0; miplevel < mipmaps.length; miplevel++){
                    var _mipmaps_miplevel = mipmaps[miplevel], width1 = _mipmaps_miplevel.width, height1 = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
                    texture.setPixelBuffer(data, miplevel, 0, 0, width1, height1);
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXLoader;
}(Loader);
KTXLoader = __decorate([
    resourceLoader(exports.AssetType.KTX, [
        "ktx"
    ])
], KTXLoader);

function parseProperty(object, key, value) {
    if (typeof value === "object") {
        for(var subKey in value){
            parseProperty(object[key], subKey, value[subKey]);
        }
    } else {
        object[key] = value;
    }
}
var MaterialLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MaterialLoader, Loader);
    function MaterialLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(materialSchema) {
                var _loop = function(key) {
                    var _shaderData_key = shaderData[key], type = _shaderData_key.type, value = _shaderData_key.value;
                    switch(type){
                        case "Vector2":
                            materialShaderData.setVector2(key, new Vector2(value.x, value.y));
                            break;
                        case "Vector3":
                            materialShaderData.setVector3(key, new Vector3(value.x, value.y, value.z));
                            break;
                        case "Vector4":
                            materialShaderData.setVector4(key, new Vector4(value.x, value.y, value.z, value.w));
                            break;
                        case "Color":
                            materialShaderData.setColor(key, new Color$1(value.r, value.g, value.b, value.a));
                            break;
                        case "Float":
                            materialShaderData.setFloat(key, value);
                            break;
                        case "Texture":
                            texturePromises.push(// @ts-ignore
                            resourceManager.getResourceByRef(value).then(function(texture) {
                                materialShaderData.setTexture(key, texture);
                            }));
                            break;
                    }
                };
                var engine = resourceManager.engine;
                var name = materialSchema.name, shader = materialSchema.shader, shaderData = materialSchema.shaderData, macros = materialSchema.macros, renderState = materialSchema.renderState;
                var material = new Material(engine, Shader.find(shader));
                material.name = name;
                var texturePromises = new Array();
                var materialShaderData = material.shaderData;
                for(var key in shaderData)_loop(key);
                for(var i = 0, length = macros.length; i < length; i++){
                    var _macros_i = macros[i], name1 = _macros_i.name, value = _macros_i.value;
                    if (value == undefined) {
                        materialShaderData.enableMacro(name1);
                    } else {
                        materialShaderData.enableMacro(name1, value);
                    }
                }
                parseProperty(material, "renderState", renderState);
                return Promise.all(texturePromises).then(function() {
                    resolve(material);
                });
            }).catch(reject);
        });
    };
    return MaterialLoader;
}(Loader);
MaterialLoader = __decorate([
    resourceLoader(exports.AssetType.Material, [
        "json"
    ])
], MaterialLoader);

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

var BufferReader = /*#__PURE__*/ function() {
    function BufferReader(buffer, byteOffset, byteLength, littleEndian) {
        if (byteOffset === void 0) byteOffset = 0;
        if (littleEndian === void 0) littleEndian = true;
        this.buffer = buffer;
        // byteLength = byteLength ?? _buffer.byteLength;
        this._dataView = new DataView(buffer);
        this._littleEndian = littleEndian;
        this._offset = byteOffset;
    }
    var _proto = BufferReader.prototype;
    _proto.nextUint8 = function nextUint8() {
        var value = this._dataView.getUint8(this._offset);
        this._offset += 1;
        return value;
    };
    _proto.nextUint16 = function nextUint16() {
        var value = this._dataView.getUint16(this._offset, this._littleEndian);
        this._offset += 2;
        return value;
    };
    _proto.nextUint32 = function nextUint32() {
        var value = this._dataView.getUint32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextInt32 = function nextInt32() {
        var value = this._dataView.getInt32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
        var value = new Int32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
        var value = this._dataView.getFloat32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
        var value = new Float32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
        var value = new Uint32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
        var value = new Uint8Array(this.buffer, this._offset, len);
        this._offset += len;
        return value;
    };
    _proto.nextUint64 = function nextUint64() {
        var left = this._dataView.getUint32(this._offset, this._littleEndian);
        var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
        var value = left + Math.pow(2, 32) * right;
        this._offset += 8;
        return value;
    };
    _proto.nextStr = function nextStr() {
        var strByteLength = this.nextUint16();
        var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
        this._offset += strByteLength;
        return Utils.decodeText(uint8Array);
    };
    /**
   * image data æ”¾åœ¨æœ€åŽ
   */ _proto.nextImageData = function nextImageData(count) {
        return this.buffer.slice(this._offset);
    };
    _proto.nextImagesData = function nextImagesData(count) {
        var imagesLen = new Array(count);
        // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
        for(var i = 0; i < count; i++){
            var len = this._dataView.getUint32(this._offset, this._littleEndian);
            imagesLen[i] = len;
            this._offset += 4;
        }
        var imagesData = [];
        for(var i1 = 0; i1 < count; i1++){
            var len1 = imagesLen[i1];
            var buffer = this.buffer.slice(this._offset, this._offset + len1);
            this._offset += len1;
            imagesData.push(buffer);
        }
        return imagesData;
    };
    _proto.skip = function skip(bytes) {
        this._offset += bytes;
        return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
        if (term === void 0) term = 0x00;
        var byteOffset = this._offset;
        var byteLength = 0;
        while(this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength){
            byteLength++;
            this._offset++;
        }
        if (byteLength < maxByteLength) this._offset++;
        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _create_class(BufferReader, [
        {
            key: "offset",
            get: function get() {
                return this._offset;
            }
        }
    ]);
    return BufferReader;
}();
(function() {
    BufferReader.imageMapping = {
        0: "image/png",
        1: "image/jpg",
        2: "image/webp",
        3: "ktx"
    };
})();

var decoderMap = {};
/**
 * Decoder decorator generator.
 * @param type - resource file type.
 * @returns Decoder decorator
 */ function decoder(type) {
    return function(target) {
        decoderMap[type] = target;
    };
}

var FileHeader = /*#__PURE__*/ function() {
    function FileHeader() {
        this.totalLength = 0;
        this.version = 0;
        this.type = "";
        this.name = "";
        this.headerLength = 0;
    }
    FileHeader.decode = function decode(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var totalLen = dataView.getUint32(0, true);
        var fileVersion = dataView.getUint8(4);
        var typeLen = dataView.getUint16(5, true);
        var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
        var nameLen = dataView.getUint16(7 + typeLen, true);
        var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
        var name = Utils.decodeText(nameUint8Array);
        var type = Utils.decodeText(typeUint8Array);
        var header = new FileHeader();
        header.totalLength = totalLen;
        header.name = name;
        header.type = type;
        header.version = fileVersion;
        header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
        return header;
    };
    _create_class(FileHeader, [
        {
            key: "dataLength",
            get: function get() {
                return this.totalLength - this.headerLength;
            }
        }
    ]);
    return FileHeader;
}();

var MeshDecoder = /*#__PURE__*/ function() {
    function MeshDecoder() {}
    MeshDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var modelMesh = new ModelMesh(engine);
            var jsonDataString = bufferReader.nextStr();
            var encodedMeshData = JSON.parse(jsonDataString);
            // @ts-ignore Vector3 is not compatible with {x: number, y: number, z: number}.
            encodedMeshData.bounds && modelMesh.bounds.copyFrom(encodedMeshData.bounds);
            var offset = Math.ceil(bufferReader.offset / 4) * 4;
            var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
            var vertexCount = float32Array.length / 3;
            var positions = float32ArrayToVector3(float32Array, vertexCount);
            modelMesh.setPositions(positions);
            if (encodedMeshData.normals) {
                var float32Array1 = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
                var normals = float32ArrayToVector3(float32Array1, vertexCount);
                modelMesh.setNormals(normals);
            }
            if (encodedMeshData.uvs) {
                var float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array2, vertexCount));
            }
            if (encodedMeshData.uv1) {
                var float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array3, vertexCount), 1);
            }
            if (encodedMeshData.uv2) {
                var float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array4, vertexCount), 2);
            }
            if (encodedMeshData.uv3) {
                var float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array5, vertexCount), 3);
            }
            if (encodedMeshData.uv4) {
                var float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array6, vertexCount), 4);
            }
            if (encodedMeshData.uv5) {
                var float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array7, vertexCount), 5);
            }
            if (encodedMeshData.uv6) {
                var float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array8, vertexCount), 6);
            }
            if (encodedMeshData.uv7) {
                var float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array9, vertexCount), 7);
            }
            if (encodedMeshData.colors) {
                var float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
                modelMesh.setColors(float32ArrayToVColor(float32Array10, vertexCount));
            }
            if (encodedMeshData.boneWeights) {
                var float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
                modelMesh.setBoneWeights(float32ArrayToVector4(float32Array11, vertexCount));
            }
            if (encodedMeshData.boneIndices) {
                var float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
                modelMesh.setBoneIndices(float32ArrayToVector4(float32Array12, vertexCount));
            }
            if (encodedMeshData.blendShapes) {
                encodedMeshData.blendShapes.forEach(function(blendShapeData) {
                    var blendShape = new BlendShape(blendShapeData.name);
                    blendShapeData.frames.forEach(function(frameData) {
                        var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
                        var count = positionArray.length / 3;
                        var deltaPosition = float32ArrayToVector3(positionArray, count);
                        if (frameData.deltaNormals) {
                            var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                            float32ArrayToVector3(normalsArray, count);
                        }
                        if (frameData.deltaTangents) {
                            var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                            float32ArrayToVector4(tangentsArray, count);
                        }
                        blendShape.addFrame(frameData.weight, deltaPosition);
                    });
                    modelMesh.addBlendShape(blendShape);
                });
            }
            if (encodedMeshData.indices) {
                var indices = null;
                if (encodedMeshData.indices.type === 0) {
                    indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
                } else {
                    indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
                }
                modelMesh.setIndices(indices);
            }
            encodedMeshData.subMeshes.forEach(function(subMesh) {
                return modelMesh.addSubMesh(subMesh);
            });
            modelMesh.uploadData(false);
            resolve(modelMesh);
        });
    };
    return MeshDecoder;
}();
MeshDecoder = __decorate([
    decoder("Mesh")
], MeshDecoder);
function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Color$1(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
}

var Texture2DDecoder = /*#__PURE__*/ function() {
    function Texture2DDecoder() {}
    Texture2DDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve, reject) {
            var objectId = bufferReader.nextStr();
            var mipmap = !!bufferReader.nextUint8();
            var filterMode = bufferReader.nextUint8();
            var anisoLevel = bufferReader.nextUint8();
            var wrapModeU = bufferReader.nextUint8();
            var wrapModeV = bufferReader.nextUint8();
            var format = bufferReader.nextUint8();
            var width = bufferReader.nextUint16();
            var height = bufferReader.nextUint16();
            var isPixelBuffer = bufferReader.nextUint8();
            var mipCount = bufferReader.nextUint8();
            var imagesData = bufferReader.nextImagesData(mipCount);
            var texture2D = new Texture2D(engine, width, height, format, mipmap);
            texture2D.filterMode = filterMode;
            texture2D.anisoLevel = anisoLevel;
            texture2D.wrapModeU = wrapModeU;
            texture2D.wrapModeV = wrapModeV;
            if (isPixelBuffer) {
                var pixelBuffer = new Uint8Array(imagesData[0]);
                texture2D.setPixelBuffer(pixelBuffer);
                if (mipmap) {
                    texture2D.generateMipmaps();
                    for(var i = 1; i < mipCount; i++){
                        var pixelBuffer1 = new Uint8Array(imagesData[i]);
                        texture2D.setPixelBuffer(pixelBuffer1, i);
                    }
                }
                // @ts-ignore
                engine.resourceManager._objectPool[objectId] = texture2D;
                resolve(texture2D);
            } else {
                var blob = new PlatformManager$1.polyfill.window.Blob([
                    imagesData[0]
                ]);
                var img = new PlatformManager$1.polyfill.Image();
                img.onload = function() {
                    texture2D.setImageSource(img);
                    var completedCount = 0;
                    var onComplete = function() {
                        completedCount++;
                        if (completedCount >= mipCount) {
                            resolve(texture2D);
                        }
                    };
                    onComplete();
                    if (mipmap) {
                        var _loop = function(i) {
                            var blob = new PlatformManager$1.polyfill.window.Blob([
                                imagesData[i]
                            ]);
                            var img = new PlatformManager$1.polyfill.Image();
                            img.onload = function() {
                                texture2D.setImageSource(img, i);
                                onComplete();
                            };
                            img.src = PlatformManager$1.polyfill.URL.createObjectURL(blob);
                        };
                        texture2D.generateMipmaps();
                        for(var i = 1; i < mipCount; i++)_loop(i);
                    }
                };
                img.src = PlatformManager$1.polyfill.URL.createObjectURL(blob);
            }
        });
    };
    return Texture2DDecoder;
}();
Texture2DDecoder = __decorate([
    decoder("Texture2D")
], Texture2DDecoder);

function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));

        return true;
    } catch (e) {
        return false;
    }
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of(instance, Class.prototype);

            return instance;
        };
    }

    return _construct.apply(null, arguments);
}

var ReflectionParser = /*#__PURE__*/ function() {
    function ReflectionParser() {}
    ReflectionParser.registerCustomParseComponent = function registerCustomParseComponent(componentType, handle) {
        this.customParseComponentHandles[componentType] = handle;
    };
    ReflectionParser.parseEntity = function parseEntity(entityConfig, engine) {
        return ReflectionParser.getEntityByConfig(entityConfig, engine).then(function(entity) {
            var _entityConfig_isActive;
            entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : true;
            var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
            if (position) entity.transform.position.copyFrom(position);
            if (rotation) entity.transform.rotation.copyFrom(rotation);
            if (scale) entity.transform.scale.copyFrom(scale);
            return entity;
        });
    };
    ReflectionParser.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
        // @ts-ignore
        var assetRefId = entityConfig.assetRefId;
        if (assetRefId) {
            return engine.resourceManager// @ts-ignore
            .getResourceByRef({
                refId: assetRefId,
                key: entityConfig.key,
                isClone: entityConfig.isClone
            }).then(function(entity) {
                entity.name = entityConfig.name;
                return entity;
            });
        } else {
            var entity = new Entity(engine, entityConfig.name);
            return Promise.resolve(entity);
        }
    };
    ReflectionParser.parseClassObject = function parseClassObject(item, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var Class = Loader.getClass(item.class);
        var _item_constructParams;
        var params = (_item_constructParams = item.constructParams) != null ? _item_constructParams : [];
        var instance = _construct(Class, [].concat(params));
        return this.parsePropsAndMethods(instance, item, engine, resourceManager);
    };
    ReflectionParser.parseBasicType = function parseBasicType(value, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        if (Array.isArray(value)) {
            return Promise.all(value.map(function(item) {
                return _this.parseBasicType(item, engine, resourceManager);
            }));
        } else if (typeof value === "object" && value != null) {
            if (this._isClass(value)) {
                // class object
                return this.parseClassObject(value, engine, resourceManager);
            } else if (this._isRef(value)) {
                // reference object
                return resourceManager.getResourceByRef(value);
            } else {
                // basic type
                return Promise.resolve(value);
            }
        } else {
            return Promise.resolve(value);
        }
    };
    ReflectionParser.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        var promises = [];
        if (item.methods) {
            for(var methodName in item.methods){
                var methodParams = item.methods[methodName];
                for(var i = 0, count = methodParams.length; i < count; i++){
                    var params = methodParams[i];
                    var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
                    promises.push(promise);
                }
            }
        }
        if (item.props) {
            var _this1 = this, _loop = function(key) {
                var value = item.props[key];
                var promise = _this1.parseBasicType(value, engine).then(function(v) {
                    return instance[key] = v;
                });
                promises.push(promise);
            };
            for(var key in item.props)_loop(key);
        }
        return Promise.all(promises).then(function() {
            var handle = _this.customParseComponentHandles[instance.constructor.name];
            if (handle) return handle(instance, item, engine);
            else return instance;
        });
    };
    ReflectionParser.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        return Promise.all(methodParams.map(function(param) {
            return _this.parseBasicType(param, engine, resourceManager);
        })).then(function(result) {
            var _instance;
            return (_instance = instance)[methodName].apply(_instance, result);
        });
    };
    ReflectionParser._isClass = function _isClass(value) {
        return value["class"] != undefined;
    };
    ReflectionParser._isRef = function _isRef(value) {
        return value["refId"] != undefined;
    };
    return ReflectionParser;
}();
(function() {
    ReflectionParser.customParseComponentHandles = new Map();
})();

var PrefabParser = /*#__PURE__*/ function() {
    function PrefabParser() {}
    PrefabParser.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
        var children = entitiesConfig.get(parentId).children;
        if (children && children.length > 0) {
            var parent = entities.get(parentId);
            for(var i = 0; i < children.length; i++){
                var childId = children[i];
                var entity = entities.get(childId);
                parent.addChild(entity);
                this.parseChildren(entitiesConfig, entities, childId);
            }
        }
    };
    return PrefabParser;
}();

var ComponentMap = {
    Transform: Transform,
    Animator: Animator,
    DirectLight: DirectLight,
    Camera: exports.Camera,
    MeshRenderer: MeshRenderer,
    ParticleRenderer: ParticleRenderer,
    PointLight: PointLight,
    SpotLight: SpotLight,
    Script: Script,
    SpriteMask: SpriteMask,
    SpriteRenderer: SpriteRenderer,
    TextRenderer: TextRenderer
};

var InterpolableValueType;
(function(InterpolableValueType) {
    InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
    InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
    InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
    InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
    InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
    InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
    InterpolableValueType[InterpolableValueType["Color"] = 6] = "Color";
    InterpolableValueType[InterpolableValueType["Array"] = 7] = "Array";
    InterpolableValueType[InterpolableValueType["Boolean"] = 8] = "Boolean";
})(InterpolableValueType || (InterpolableValueType = {}));
var AnimationClipDecoder = /*#__PURE__*/ function() {
    function AnimationClipDecoder() {}
    AnimationClipDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var name = bufferReader.nextStr();
            var clip = new AnimationClip(name);
            var eventsLen = bufferReader.nextUint16();
            for(var i = 0; i < eventsLen; ++i){
                var event = new AnimationEvent();
                event.time = bufferReader.nextFloat32();
                event.functionName = bufferReader.nextStr();
                event.parameter = JSON.parse(bufferReader.nextStr()).val;
                clip.addEvent(event);
            }
            var curveBindingsLen = bufferReader.nextUint16();
            for(var i1 = 0; i1 < curveBindingsLen; ++i1){
                var relativePath = bufferReader.nextStr();
                var componentStr = bufferReader.nextStr();
                var componentType = ComponentMap[componentStr];
                var property = bufferReader.nextStr();
                var curve = void 0;
                var interpolation = bufferReader.nextUint8();
                var keysLen = bufferReader.nextUint16();
                var curveType = bufferReader.nextStr();
                switch(curveType){
                    case "AnimationFloatCurve":
                        {
                            curve = curve || new AnimationFloatCurve();
                            curve.interpolation = interpolation;
                            for(var j = 0; j < keysLen; ++j){
                                var keyframe = new Keyframe();
                                keyframe.time = bufferReader.nextFloat32();
                                keyframe.value = bufferReader.nextFloat32();
                                keyframe.inTangent = bufferReader.nextFloat32();
                                keyframe.outTangent = bufferReader.nextFloat32();
                                curve.addKey(keyframe);
                            }
                            break;
                        }
                    case "AnimationArrayCurve":
                        {
                            curve = curve || new AnimationArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j1 = 0; j1 < keysLen; ++j1){
                                var keyframe1 = new Keyframe();
                                keyframe1.time = bufferReader.nextFloat32();
                                var len = bufferReader.nextUint16();
                                keyframe1.value = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.inTangent = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.outTangent = Array.from(bufferReader.nextFloat32Array(len));
                                curve.addKey(keyframe1);
                            }
                            break;
                        }
                    case "AnimationFloatArrayCurve":
                        {
                            curve = curve || new AnimationFloatArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j2 = 0; j2 < keysLen; ++j2){
                                var keyframe2 = new Keyframe();
                                keyframe2.time = bufferReader.nextFloat32();
                                var len1 = bufferReader.nextUint16();
                                keyframe2.value = bufferReader.nextFloat32Array(len1);
                                keyframe2.inTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                keyframe2.outTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                curve.addKey(keyframe2);
                            }
                            break;
                        }
                    case "AnimationVector2Curve":
                        {
                            curve = curve || new AnimationVector2Curve();
                            curve.interpolation = interpolation;
                            for(var j3 = 0; j3 < keysLen; ++j3){
                                var keyframe3 = new Keyframe();
                                keyframe3.time = bufferReader.nextFloat32();
                                keyframe3.value = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.inTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.outTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe3);
                            }
                            break;
                        }
                    case "AnimationVector3Curve":
                        {
                            curve = curve || new AnimationVector3Curve();
                            curve.interpolation = interpolation;
                            for(var j4 = 0; j4 < keysLen; ++j4){
                                var keyframe4 = new Keyframe();
                                keyframe4.time = bufferReader.nextFloat32();
                                keyframe4.value = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.inTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.outTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe4);
                            }
                            break;
                        }
                    case "AnimationVector4Curve":
                        {
                            curve = curve || new AnimationVector4Curve();
                            curve.interpolation = interpolation;
                            var keyframe5 = new Keyframe();
                            keyframe5.time = bufferReader.nextFloat32();
                            keyframe5.value = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            curve.addKey(keyframe5);
                            break;
                        }
                    case "AnimationColorCurve":
                        {
                            curve = curve || new AnimationColorCurve();
                            curve.interpolation = interpolation;
                            for(var j5 = 0; j5 < keysLen; ++j5){
                                var keyframe6 = new Keyframe();
                                keyframe6.time = bufferReader.nextFloat32();
                                keyframe6.value = new Color$1(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe6);
                            }
                            break;
                        }
                    case "AnimationQuaternionCurve":
                        {
                            curve = curve || new AnimationQuaternionCurve();
                            curve.interpolation = interpolation;
                            for(var j6 = 0; j6 < keysLen; ++j6){
                                var keyframe7 = new Keyframe();
                                keyframe7.time = bufferReader.nextFloat32();
                                keyframe7.value = new Quaternion(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe7);
                            }
                            break;
                        }
                }
                clip.addCurveBinding(relativePath, componentType, property, curve);
            }
            resolve(clip);
        });
    };
    return AnimationClipDecoder;
}();
AnimationClipDecoder = __decorate([
    decoder("AnimationClip")
], AnimationClipDecoder);

var SpecularMode;
(function(SpecularMode) {
    SpecularMode["Sky"] = "Sky";
    SpecularMode["Custom"] = "Custom";
})(SpecularMode || (SpecularMode = {}));

var SceneParserContext = /*#__PURE__*/ function() {
    function SceneParserContext(originalData, scene) {
        this.originalData = originalData;
        this.scene = scene;
        this.entityMap = new Map();
        this.components = new Map();
        this.assets = new Map();
        this.entityConfigMap = new Map();
        this.rootIds = [];
    }
    var _proto = SceneParserContext.prototype;
    _proto.destroy = function destroy() {
        this.entityMap.clear();
        this.components.clear();
        this.assets.clear();
        this.entityConfigMap.clear();
        this.rootIds.length = 0;
    };
    return SceneParserContext;
}();

/** @Internal */ var SceneParser = /*#__PURE__*/ function() {
    function SceneParser(context) {
        var _this = this;
        this.context = context;
        this._engine = this.context.scene.engine;
        this._organizeEntities = this._organizeEntities.bind(this);
        this._parseComponents = this._parseComponents.bind(this);
        this._clearAndResolveScene = this._clearAndResolveScene.bind(this);
        this.promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            _this._resolve = resolve;
        });
    }
    var _proto = SceneParser.prototype;
    /** start parse the scene */ _proto.start = function start() {
        this._parseEntities().then(this._organizeEntities).then(this._parseComponents).then(this._clearAndResolveScene).then(this._resolve).catch(this._reject);
    };
    _proto._parseEntities = function _parseEntities() {
        var entitiesConfig = this.context.originalData.entities;
        var entityConfigMap = this.context.entityConfigMap;
        var entitiesMap = this.context.entityMap;
        var rootIds = this.context.rootIds;
        var engine = this._engine;
        var promises = entitiesConfig.map(function(entityConfig) {
            entityConfigMap.set(entityConfig.id, entityConfig);
            // record root entities
            if (!entityConfig.parent) rootIds.push(entityConfig.id);
            return ReflectionParser.parseEntity(entityConfig, engine);
        });
        return Promise.all(promises).then(function(entities) {
            for(var i = 0, l = entities.length; i < l; i++){
                entitiesMap.set(entitiesConfig[i].id, entities[i]);
            }
            return entities;
        });
    };
    _proto._organizeEntities = function _organizeEntities() {
        var _this_context = this.context, entityConfigMap = _this_context.entityConfigMap, entityMap = _this_context.entityMap, scene = _this_context.scene, rootIds = _this_context.rootIds;
        for(var _iterator = _create_for_of_iterator_helper_loose(rootIds), _step; !(_step = _iterator()).done;){
            var rootId = _step.value;
            PrefabParser.parseChildren(entityConfigMap, entityMap, rootId);
        }
        var rootEntities = rootIds.map(function(id) {
            return entityMap.get(id);
        });
        for(var i = 0; i < rootEntities.length; i++){
            scene.addRootEntity(rootEntities[i]);
        }
    };
    _proto._parseComponents = function _parseComponents() {
        var entitiesConfig = this.context.originalData.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++){
            var entityConfig = entitiesConfig[i];
            var entity = entityMap.get(entityConfig.id);
            for(var i1 = 0; i1 < entityConfig.components.length; i1++){
                var componentConfig = entityConfig.components[i1];
                var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
                var component = void 0;
                // TODO: remove hack code when support additional edit
                if (key === "Animator") {
                    component = entity.getComponent(Loader.getClass(key));
                }
                component = component || entity.addComponent(Loader.getClass(key));
                var promise = ReflectionParser.parsePropsAndMethods(component, componentConfig, entity.engine);
                promises.push(promise);
            }
        }
        return Promise.all(promises);
    };
    _proto._clearAndResolveScene = function _clearAndResolveScene() {
        var scene = this.context.scene;
        this.context.destroy();
        return scene;
    };
    /**
   * Parse scene data.
   * @param engine - the engine of the parser context
   * @param sceneData - scene data which is exported by editor
   * @returns a promise of scene
   */ SceneParser.parse = function parse(engine, sceneData) {
        var scene = new Scene(engine);
        var context = new SceneParserContext(sceneData, scene);
        var parser = new SceneParser(context);
        parser.start();
        return parser.promise;
    };
    return SceneParser;
}();

var MeshLoader$1 = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(data) {
                decode(data, resourceManager.engine).then(function(mesh) {
                    resolve(mesh);
                });
            });
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader$1 = __decorate([
    resourceLoader("Mesh", [
        "prefab"
    ], true)
], MeshLoader$1);

var EditorTextureLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EditorTextureLoader, Loader);
    function EditorTextureLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = EditorTextureLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(data) {
                decode(data, resourceManager.engine).then(function(texture) {
                    resolve(texture);
                });
            });
        });
    };
    return EditorTextureLoader;
}(Loader);
EditorTextureLoader = __decorate([
    resourceLoader("EditorTexture2D", [
        "prefab"
    ], true)
], EditorTextureLoader);

/**
 * Decode engine binary resource.
 * @param arrayBuffer - array buffer of decode binary file
 * @param engine - engine
 * @returns
 */ function decode(arrayBuffer, engine) {
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
    return decoderMap[header.type].decode(engine, bufferReader).then(function(object) {
        object.name = header.name;
        return object;
    });
}

var MeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine);
            }).then(function(mesh) {
                resolve(mesh);
            }).catch(reject);
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader = __decorate([
    resourceLoader(exports.AssetType.Mesh, [
        "mesh"
    ])
], MeshLoader);

var SourceFontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SourceFontLoader, Loader);
    function SourceFontLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SourceFontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var url = item.url;
            _this._registerFont(url, url).then(function() {
                var font = new Font(resourceManager.engine, url);
                resolve(font);
            }).catch(function(e) {
                reject("load font " + url + " fail");
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        PlatformManager$1.polyfill.document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return SourceFontLoader;
}(Loader);
SourceFontLoader = __decorate([
    resourceLoader(exports.AssetType.SourceFont, [
        "ttf",
        "otf",
        "woff"
    ], false)
], SourceFontLoader);

var SpriteAtlasLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteAtlasLoader, Loader);
    function SpriteAtlasLoader() {
        var _this;
        _this = Loader.apply(this, arguments) || this;
        _this._tempRect = new Rect();
        _this._tempVec2 = new Vector2();
        _this._tempVec4 = new Vector4();
        return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject, _, onCancel) {
            var chainPromises = [];
            onCancel(function() {
                for(var i = 0; i < chainPromises.length; i++){
                    chainPromises[i].cancel();
                }
            });
            var configPromise = _this.request(item.url, _extends({}, item, {
                type: "json"
            }));
            chainPromises.push(configPromise);
            configPromise.then(function(atlasData) {
                var _loop = function(i) {
                    var atlasItem = atlasItems[i];
                    if (atlasItem.img) {
                        chainPromises.push(resourceManager.load({
                            url: Utils.resolveAbsoluteUrl(item.url, atlasItem.img),
                            type: exports.AssetType.Texture2D,
                            params: {
                                format: format,
                                mipmap: mipmap
                            }
                        }).then(function(texture) {
                            anisoLevel && (texture.anisoLevel = anisoLevel);
                            filterMode !== undefined && (texture.filterMode = filterMode);
                            wrapModeU !== undefined && (texture.wrapModeU = wrapModeU);
                            wrapModeV !== undefined && (texture.wrapModeV = wrapModeV);
                            for(var i = 0; i < atlasItem.sprites.length; i++){
                                // @ts-ignore
                                spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i], texture));
                            }
                        }).catch(reject));
                    } else {
                        for(var i1 = 0; i1 < atlasItem.sprites.length; i1++){
                            // @ts-ignore
                            spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i1]));
                        }
                    }
                };
                var atlasItems = atlasData.atlasItems, mipmap = atlasData.mipmap, anisoLevel = atlasData.anisoLevel, filterMode = atlasData.filterMode, wrapModeU = atlasData.wrapModeU, wrapModeV = atlasData.wrapModeV, format = atlasData.format;
                var atlasItemsLen = atlasItems ? atlasItems.length : 0;
                var engine = resourceManager.engine;
                var spriteAtlas = new SpriteAtlas(engine);
                if (atlasItemsLen < 0) {
                    resolve(spriteAtlas);
                    return;
                }
                chainPromises.length = 0;
                for(var i = 0; i < atlasItems.length; i++)_loop(i);
                AssetPromise.all(chainPromises).then(function() {
                    resolve(spriteAtlas);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._makeSprite = function _makeSprite(engine, config, texture) {
        // Generate a SpriteAtlas object.
        var region = config.region, atlasRegionOffset = config.atlasRegionOffset, atlasRegion = config.atlasRegion, pivot = config.pivot, border = config.border;
        var sprite = new Sprite(engine, texture, region ? this._tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? this._tempVec2.set(pivot.x, pivot.y) : undefined, border ? this._tempVec4.set(border.x, border.y, border.z, border.w) : undefined, config.name);
        if (texture) {
            var invW = 1 / texture.width;
            var invH = 1 / texture.height;
            sprite.atlasRegion.set(atlasRegion.x * invW, atlasRegion.y * invH, atlasRegion.w * invW, atlasRegion.h * invH);
            if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                sprite.atlasRegionOffset.set(offsetLeft * invW, offsetTop * invH, offsetRight * invW, offsetBottom * invH);
            }
            config.atlasRotated && (sprite.atlasRotated = true);
        }
        return sprite;
    };
    return SpriteAtlasLoader;
}(Loader);
SpriteAtlasLoader = __decorate([
    resourceLoader(exports.AssetType.SpriteAtlas, [
        "atlas"
    ], false)
], SpriteAtlasLoader);

var SpriteLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteLoader, Loader);
    function SpriteLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                if (data.belongToAtlas) {
                    resourceManager// @ts-ignore
                    .getResourceByRef(data.belongToAtlas).then(function(atlas) {
                        resolve(atlas.getSprite(data.fullPath));
                    }).catch(reject);
                } else if (data.texture) {
                    resourceManager// @ts-ignore
                    .getResourceByRef(data.texture).then(function(texture) {
                        resolve(new Sprite(resourceManager.engine, texture, data.region, data.pivot, data.border));
                    }).catch(reject);
                } else {
                    resolve(new Sprite(resourceManager.engine, null, data.region, data.pivot, data.border));
                }
            }).catch(reject);
        });
    };
    return SpriteLoader;
}(Loader);
SpriteLoader = __decorate([
    resourceLoader(exports.AssetType.Sprite, [
        "sprite"
    ], false)
], SpriteLoader);

/**
 * @internal
 */ var Texture2DContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(Texture2DContentRestorer, ContentRestorer);
    function Texture2DContentRestorer(resource, url, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.url = url;
        _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = Texture2DContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return request(this.url, this.requestConfig).then(function(image) {
            var resource = _this.resource;
            resource.setImageSource(image);
            resource.generateMipmaps();
            return resource;
        });
    };
    return Texture2DContentRestorer;
}(ContentRestorer);

var Texture2DLoader = /*#__PURE__*/ function(Loader) {
    _inherits(Texture2DLoader, Loader);
    function Texture2DLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var url = item.url;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            _this.request(url, requestConfig).then(function(image) {
                var params = item.params;
                var texture = new Texture2D(resourceManager.engine, image.width, image.height, params == null ? void 0 : params.format, params == null ? void 0 : params.mipmap);
                texture.setImageSource(image);
                texture.generateMipmaps();
                if (url.indexOf("data:") !== 0) {
                    var index = url.lastIndexOf("/");
                    texture.name = url.substring(index + 1);
                }
                resourceManager.addContentRestorer(new Texture2DContentRestorer(texture, url, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return Texture2DLoader;
}(Loader);
Texture2DLoader = __decorate([
    resourceLoader(exports.AssetType.Texture2D, [
        "png",
        "jpg",
        "webp",
        "jpeg"
    ])
], Texture2DLoader);

/**
 * @internal
 */ var TextureCubeContentRestorer = /*#__PURE__*/ function(ContentRestorer) {
    _inherits(TextureCubeContentRestorer, ContentRestorer);
    function TextureCubeContentRestorer(resource, urls, requestConfig) {
        var _this;
        _this = ContentRestorer.call(this, resource) || this;
        _this.urls = urls;
        _this.requestConfig = requestConfig;
        return _this;
    }
    var _proto = TextureCubeContentRestorer.prototype;
    _proto.restoreContent = function restoreContent() {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(_this.urls.map(function(url) {
                return request(url, _this.requestConfig);
            })).then(function(images) {
                var resource = _this.resource;
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    resource.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                resource.generateMipmaps();
                resolve(resource);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeContentRestorer;
}(ContentRestorer);

var TextureCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(TextureCubeLoader, Loader);
    function TextureCubeLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var urls = item.urls;
            var requestConfig = _extends({}, item, {
                type: "image"
            });
            Promise.all(urls.map(function(url) {
                return _this.request(url, requestConfig);
            })).then(function(images) {
                var _images_ = images[0], width = _images_.width, height = _images_.height;
                if (width !== height) {
                    console.error("The cube texture must have the same width and height");
                    return;
                }
                var texture = new TextureCube(resourceManager.engine, width);
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    texture.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                texture.generateMipmaps();
                resourceManager.addContentRestorer(new TextureCubeContentRestorer(texture, urls, requestConfig));
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeLoader;
}(Loader);
TextureCubeLoader = __decorate([
    resourceLoader(exports.AssetType.TextureCube, [
        ""
    ])
], TextureCubeLoader);

var AnimationClipLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AnimationClipLoader, Loader);
    function AnimationClipLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = AnimationClipLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine);
            }).catch(reject);
        });
    };
    return AnimationClipLoader;
}(Loader);
AnimationClipLoader = __decorate([
    resourceLoader(exports.AssetType.AnimationClip, [
        "ani"
    ])
], AnimationClipLoader);

var SceneLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SceneLoader, Loader);
    function SceneLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "json"
            }).then(function(data) {
                // @ts-ignore
                engine.resourceManager.initVirtualResources(data.files);
                return SceneParser.parse(engine, data).then(function(scene) {
                    var promises = [];
                    // parse ambient light
                    var ambient = data.scene.ambient;
                    var useCustomAmbient = ambient.specularMode === "Custom";
                    if (useCustomAmbient && ambient.customAmbientLight) {
                        // @ts-ignore
                        // prettier-ignore
                        var customAmbientPromise = resourceManager.getResourceByRef(ambient.customAmbientLight).then(function(ambientLight) {
                            scene.ambientLight = ambientLight;
                            scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                            scene.ambientLight.specularIntensity = ambient.specularIntensity;
                            scene.ambientLight.diffuseMode = ambient.diffuseMode;
                            scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
                        });
                        promises.push(customAmbientPromise);
                    } else if (!useCustomAmbient && ambient.ambientLight) {
                        // @ts-ignore
                        // prettier-ignore
                        var ambientLightPromise = resourceManager.getResourceByRef(ambient.ambientLight).then(function(ambientLight) {
                            scene.ambientLight = ambientLight;
                            scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                            scene.ambientLight.specularIntensity = ambient.specularIntensity;
                            scene.ambientLight.diffuseMode = ambient.diffuseMode;
                            scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
                        });
                        promises.push(ambientLightPromise);
                    }
                    var background = data.scene.background;
                    scene.background.mode = background.mode;
                    switch(scene.background.mode){
                        case BackgroundMode.SolidColor:
                            scene.background.solidColor.copyFrom(background.color);
                            break;
                        case BackgroundMode.Sky:
                            if (background.skyMesh && background.skyMaterial) {
                                // @ts-ignore
                                var skyMeshPromise = resourceManager.getResourceByRef(background.skyMesh).then(function(mesh) {
                                    scene.background.sky.mesh = mesh;
                                });
                                // @ts-ignore
                                // prettier-ignore
                                var skyMaterialPromise = resourceManager.getResourceByRef(background.skyMaterial).then(function(material) {
                                    scene.background.sky.material = material;
                                });
                                promises.push(skyMeshPromise, skyMaterialPromise);
                            } else {
                                Logger.warn("Sky background mode requires skyMesh and skyMaterial");
                            }
                            break;
                        case BackgroundMode.Texture:
                            if (background.texture) {
                                // @ts-ignore
                                // prettier-ignore
                                var backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                                    scene.background.texture = texture;
                                });
                                promises.push(backgroundPromise);
                            }
                            break;
                    }
                    // parse shadow
                    var shadow = data.scene.shadow;
                    if (shadow) {
                        if (shadow.castShadows != undefined) scene.castShadows = shadow.castShadows;
                        if (shadow.shadowResolution != undefined) scene.shadowResolution = shadow.shadowResolution;
                        if (shadow.shadowDistance != undefined) scene.shadowDistance = shadow.shadowDistance;
                        if (shadow.shadowCascades != undefined) scene.shadowCascades = shadow.shadowCascades;
                    }
                    return Promise.all(promises).then(function() {
                        resolve(scene);
                    });
                });
            }).catch(reject);
        });
    };
    return SceneLoader;
}(Loader);
SceneLoader = __decorate([
    resourceLoader(exports.AssetType.Scene, [
        "prefab"
    ], true)
], SceneLoader);
ReflectionParser.registerCustomParseComponent("TextRenderer", /*#__PURE__*/ _async_to_generator(function(instance, item, engine) {
    var props;
    return __generator(this, function(_state) {
        props = item.props;
        if (!props.font) {
            // @ts-ignore
            instance.font = Font.createFromOS(engine, props.fontFamily || "Arial");
        }
        return [
            2,
            instance
        ];
    });
}));

var _KHR_draco_mesh_compression;
var KHR_draco_mesh_compression = (_KHR_draco_mesh_compression = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_draco_mesh_compression1, GLTFExtensionParser);
    function KHR_draco_mesh_compression1() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_draco_mesh_compression1.prototype;
    _proto.initialize = function initialize() {
        if (!KHR_draco_mesh_compression._decoder) {
            KHR_draco_mesh_compression._decoder = new DRACODecoder();
        }
    };
    _proto.createAndParse = function createAndParse(context, schema, glTFPrimitive, glTFMesh) {
        var _this = this;
        var glTF = context.glTF, buffers = context.buffers, engine = context.glTFResource.engine;
        var bufferViews = glTF.bufferViews, accessors = glTF.accessors;
        var bufferViewIndex = schema.bufferView, gltfAttributeMap = schema.attributes;
        var attributeMap = {};
        var attributeTypeMap = {};
        for(var attributeName in gltfAttributeMap){
            attributeMap[attributeName] = gltfAttributeMap[attributeName];
        }
        for(var attributeName1 in glTFPrimitive.attributes){
            if (gltfAttributeMap[attributeName1] !== undefined) {
                var accessorDef = accessors[glTFPrimitive.attributes[attributeName1]];
                attributeTypeMap[attributeName1] = GLTFUtils.getComponentType(accessorDef.componentType).name;
            }
        }
        var indexAccessor = accessors[glTFPrimitive.indices];
        var indexType = GLTFUtils.getComponentType(indexAccessor.componentType).name;
        var taskConfig = {
            attributeIDs: attributeMap,
            attributeTypes: attributeTypeMap,
            useUniqueIDs: true,
            indexType: indexType
        };
        var buffer = GLTFUtils.getBufferViewData(bufferViews[bufferViewIndex], buffers);
        return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function(decodedGeometry) {
            var mesh = new ModelMesh(engine, glTFMesh.name);
            return _this._parseMeshFromGLTFPrimitiveDraco(mesh, glTFMesh, glTFPrimitive, glTF, function(attributeSemantic) {
                for(var j = 0; j < decodedGeometry.attributes.length; j++){
                    if (decodedGeometry.attributes[j].name === attributeSemantic) {
                        return decodedGeometry.attributes[j].array;
                    }
                }
                return null;
            }, function(attributeSemantic, shapeIndex) {
                throw "BlendShape animation is not supported when using draco.";
            }, function() {
                return decodedGeometry.index.array;
            }, context.keepMeshData);
        });
    };
    _proto._parseMeshFromGLTFPrimitiveDraco = function _parseMeshFromGLTFPrimitiveDraco(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var vertexCount;
        var accessors = gltf.accessors;
        var accessor = accessors[attributes["POSITION"]];
        var positionBuffer = getVertexBufferData("POSITION");
        var positions = GLTFUtils.floatBufferToVector3Array(positionBuffer);
        mesh.setPositions(positions);
        var bounds = mesh.bounds;
        vertexCount = accessor.count;
        if (accessor.min && accessor.max) {
            bounds.min.copyFromArray(accessor.min);
            bounds.max.copyFromArray(accessor.max);
        } else {
            var position = KHR_draco_mesh_compression._tempVector3;
            var min = bounds.min, max = bounds.max;
            min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            var stride = positionBuffer.length / vertexCount;
            for(var j = 0; j < vertexCount; j++){
                var offset = j * stride;
                position.copyFromArray(positionBuffer, offset);
                Vector3.min(min, position, min);
                Vector3.max(max, position, max);
            }
        }
        for(var attributeSemantic in attributes){
            if (attributeSemantic === "POSITION") {
                continue;
            }
            var bufferData = getVertexBufferData(attributeSemantic);
            switch(attributeSemantic){
                case "NORMAL":
                    var normals = GLTFUtils.floatBufferToVector3Array(bufferData);
                    mesh.setNormals(normals);
                    break;
                case "TEXCOORD_0":
                    var texturecoords = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords, 0);
                    break;
                case "TEXCOORD_1":
                    var texturecoords1 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords1, 1);
                    break;
                case "TEXCOORD_2":
                    var texturecoords2 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords2, 2);
                    break;
                case "TEXCOORD_3":
                    var texturecoords3 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords3, 3);
                    break;
                case "TEXCOORD_4":
                    var texturecoords4 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords4, 4);
                    break;
                case "TEXCOORD_5":
                    var texturecoords5 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords5, 5);
                    break;
                case "TEXCOORD_6":
                    var texturecoords6 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords6, 6);
                    break;
                case "TEXCOORD_7":
                    var texturecoords7 = GLTFUtils.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords7, 7);
                    break;
                case "COLOR_0":
                    var colors = GLTFUtils.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
                    mesh.setColors(colors);
                    break;
                case "TANGENT":
                    var tangents = GLTFUtils.floatBufferToVector4Array(bufferData);
                    mesh.setTangents(tangents);
                    break;
                case "JOINTS_0":
                    var joints = GLTFUtils.floatBufferToVector4Array(bufferData);
                    mesh.setBoneIndices(joints);
                    break;
                case "WEIGHTS_0":
                    var weights = GLTFUtils.floatBufferToVector4Array(bufferData);
                    mesh.setBoneWeights(weights);
                    break;
            }
        }
        // Indices
        if (indices !== undefined) {
            var indexAccessor = gltf.accessors[indices];
            var indexData = getIndexBufferData();
            mesh.setIndices(indexData);
            mesh.addSubMesh(0, indexAccessor.count, mode);
        } else {
            mesh.addSubMesh(0, vertexCount, mode);
        }
        // BlendShapes
        targets && GLTFMeshParser._createBlendShape(mesh, null, gltfMesh, targets, getBlendShapeData);
        mesh.uploadData(!keepMeshData);
        return Promise.resolve(mesh);
    };
    return KHR_draco_mesh_compression1;
}(GLTFExtensionParser), function() {
    _KHR_draco_mesh_compression._tempVector3 = new Vector3();
}(), _KHR_draco_mesh_compression);
KHR_draco_mesh_compression = __decorate([
    registerGLTFExtension("KHR_draco_mesh_compression", GLTFExtensionMode.CreateAndParse)
], KHR_draco_mesh_compression);

var KHR_lights_punctual = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_lights_punctual, GLTFExtensionParser);
    function KHR_lights_punctual() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.additiveParse = function additiveParse(context, entity, extensionSchema) {
        var lightsSchema = context.glTF.extensions.KHR_lights_punctual.lights;
        var lightSchema = lightsSchema[extensionSchema.light];
        var color = lightSchema.color, _lightSchema_intensity = lightSchema.intensity, intensity = _lightSchema_intensity === void 0 ? 1 : _lightSchema_intensity, type = lightSchema.type, range = lightSchema.range, spot = lightSchema.spot;
        var glTFResource = context.glTFResource;
        var light;
        if (type === "directional") {
            light = entity.addComponent(DirectLight);
        } else if (type === "point") {
            light = entity.addComponent(PointLight);
        } else if (type === "spot") {
            light = entity.addComponent(SpotLight);
        }
        if (color) {
            light.color.set(color[0], color[1], color[2], 1);
        }
        light.intensity = intensity;
        if (range && !_instanceof(light, DirectLight)) {
            light.distance = range;
        }
        if (spot && _instanceof(light, SpotLight)) {
            var _spot_innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot_innerConeAngle === void 0 ? 0 : _spot_innerConeAngle, _spot_outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot_outerConeAngle === void 0 ? Math.PI / 4 : _spot_outerConeAngle;
            light.angle = innerConeAngle;
            light.penumbra = outerConeAngle - innerConeAngle;
        }
        if (!glTFResource.lights) glTFResource.lights = [];
        glTFResource.lights.push(light);
    };
    return KHR_lights_punctual;
}(GLTFExtensionParser);
KHR_lights_punctual = __decorate([
    registerGLTFExtension("KHR_lights_punctual", GLTFExtensionMode.AdditiveParse)
], KHR_lights_punctual);

var KHR_materials_clearcoat = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_clearcoat, GLTFExtensionParser);
    function KHR_materials_clearcoat() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var textures = context.glTFResource.textures;
        var _schema_clearcoatFactor = schema.clearcoatFactor, clearcoatFactor = _schema_clearcoatFactor === void 0 ? 0 : _schema_clearcoatFactor, clearcoatTexture = schema.clearcoatTexture, _schema_clearcoatRoughnessFactor = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema_clearcoatRoughnessFactor === void 0 ? 0 : _schema_clearcoatRoughnessFactor, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
        material.clearCoat = clearcoatFactor;
        material.clearCoatRoughness = clearcoatRoughnessFactor;
        if (clearcoatTexture) {
            material.clearCoatTexture = textures[clearcoatTexture.index];
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatTexture, "Clear coat");
        }
        if (clearcoatRoughnessTexture) {
            material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatRoughnessTexture, "Clear coat roughness");
        }
        if (clearcoatNormalTexture) {
            material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
            GLTFMaterialParser._checkOtherTextureTransform(clearcoatNormalTexture, "Clear coat normal");
        }
    };
    return KHR_materials_clearcoat;
}(GLTFExtensionParser);
KHR_materials_clearcoat = __decorate([
    registerGLTFExtension("KHR_materials_clearcoat", GLTFExtensionMode.AdditiveParse)
], KHR_materials_clearcoat);

var KHR_materials_ior = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_ior, GLTFExtensionParser);
    function KHR_materials_ior() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_ior.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var _schema_ior = schema.ior, ior = _schema_ior === void 0 ? 1.5 : _schema_ior;
        material.ior = ior;
    };
    return KHR_materials_ior;
}(GLTFExtensionParser);
KHR_materials_ior = __decorate([
    registerGLTFExtension("KHR_materials_ior", GLTFExtensionMode.AdditiveParse)
], KHR_materials_ior);

var KHR_materials_pbrSpecularGlossiness = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_pbrSpecularGlossiness, GLTFExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createAndParse = function createAndParse(context, schema, ownerSchema) {
        var _context_glTFResource = context.glTFResource, engine = _context_glTFResource.engine, textures = _context_glTFResource.textures;
        var material = new PBRSpecularMaterial(engine);
        var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
        if (diffuseFactor) {
            material.baseColor = new Color$1(Color$1.linearToGammaSpace(diffuseFactor[0]), Color$1.linearToGammaSpace(diffuseFactor[1]), Color$1.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
        }
        if (diffuseTexture) {
            material.baseTexture = textures[diffuseTexture.index];
            GLTFParser.executeExtensionsAdditiveAndParse(diffuseTexture.extensions, context, material, diffuseTexture);
        }
        if (specularFactor) {
            material.specularColor = new Color$1(Color$1.linearToGammaSpace(specularFactor[0]), Color$1.linearToGammaSpace(specularFactor[1]), Color$1.linearToGammaSpace(specularFactor[2]));
        }
        if (glossinessFactor !== undefined) {
            material.glossiness = glossinessFactor;
        }
        if (specularGlossinessTexture) {
            material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
            GLTFMaterialParser._checkOtherTextureTransform(specularGlossinessTexture, "Specular glossiness");
        }
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
}(GLTFExtensionParser);
KHR_materials_pbrSpecularGlossiness = __decorate([
    registerGLTFExtension("KHR_materials_pbrSpecularGlossiness", GLTFExtensionMode.CreateAndParse)
], KHR_materials_pbrSpecularGlossiness);

var KHR_materials_unlit = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_materials_unlit, GLTFExtensionParser);
    function KHR_materials_unlit() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createAndParse = function createAndParse(context, _, ownerSchema) {
        var engine = context.glTFResource.engine;
        var material = new UnlitMaterial(engine);
        material.name = ownerSchema.name;
        GLTFMaterialParser._parseStandardProperty(context, material, ownerSchema);
        return material;
    };
    return KHR_materials_unlit;
}(GLTFExtensionParser);
KHR_materials_unlit = __decorate([
    registerGLTFExtension("KHR_materials_unlit", GLTFExtensionMode.CreateAndParse)
], KHR_materials_unlit);

var KHR_mesh_quantization = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_mesh_quantization, GLTFExtensionParser);
    function KHR_mesh_quantization() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    return KHR_mesh_quantization;
}(GLTFExtensionParser);
KHR_mesh_quantization = __decorate([
    registerGLTFExtension("KHR_mesh_quantization", GLTFExtensionMode.AdditiveParse)
], KHR_mesh_quantization);

var KHR_texture_transform = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(KHR_texture_transform, GLTFExtensionParser);
    function KHR_texture_transform() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.additiveParse = function additiveParse(context, material, schema) {
        var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
        if (offset) {
            material.tilingOffset.z = offset[0];
            material.tilingOffset.w = offset[1];
        }
        if (scale) {
            material.tilingOffset.x = scale[0];
            material.tilingOffset.y = scale[1];
        }
        if (rotation) {
            Logger.warn("rotation in KHR_texture_transform is not supported now");
        }
        if (texCoord) {
            Logger.warn("texCoord in KHR_texture_transform is not supported now");
        }
    };
    return KHR_texture_transform;
}(GLTFExtensionParser);
KHR_texture_transform = __decorate([
    registerGLTFExtension("KHR_texture_transform", GLTFExtensionMode.AdditiveParse)
], KHR_texture_transform);

var GALACEAN_materials_remap = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_materials_remap, GLTFExtensionParser);
    function GALACEAN_materials_remap() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = GALACEAN_materials_remap.prototype;
    _proto.createAndParse = function createAndParse(context, schema) {
        var engine = context.glTFResource.engine;
        // @ts-ignore
        return engine.resourceManager.getResourceByRef(schema);
    };
    return GALACEAN_materials_remap;
}(GLTFExtensionParser);
GALACEAN_materials_remap = __decorate([
    registerGLTFExtension("GALACEAN_materials_remap", GLTFExtensionMode.CreateAndParse)
], GALACEAN_materials_remap);

var GALACEAN_animation_event = /*#__PURE__*/ function(GLTFExtensionParser) {
    _inherits(GALACEAN_animation_event, GLTFExtensionParser);
    function GALACEAN_animation_event() {
        return GLTFExtensionParser.apply(this, arguments);
    }
    var _proto = GALACEAN_animation_event.prototype;
    _proto.additiveParse = function additiveParse(context, animationClip, schema) {
        context.glTFResource.engine;
        var events = schema.events;
        events.map(function(eventData) {
            var event = new AnimationEvent();
            event.functionName = eventData.functionName;
            event.time = eventData.time;
            event.parameter = eventData.parameter;
            animationClip.addEvent(event);
        });
    };
    return GALACEAN_animation_event;
}(GLTFExtensionParser);
GALACEAN_animation_event = __decorate([
    registerGLTFExtension("GALACEAN_animation_event", GLTFExtensionMode.AdditiveParse)
], GALACEAN_animation_event);

//@ts-ignore
var version = "1.0.0-beta.14";
console.log("Galacean engine version: " + version);
for(var key in CoreObjects){
    Loader.registerClass(key, CoreObjects[key]);
}

exports.Color = Color$1;
exports.DirectLight = DirectLight;
exports.Font = Font;
exports.MathUtil = MathUtil$1;
exports.Matrix = Matrix;
exports.PlatformManager = PlatformManager$1;
exports.Script = Script;
exports.TextRenderer = TextRenderer;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.WebGLEngine = WebGLEngine;
